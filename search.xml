<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Java 并发容器 之 ConcurrentHashMap(二)</title>
      <link href="/java/java-ConcurrentHashMap2/"/>
      <url>/java/java-ConcurrentHashMap2/</url>
      
        <content type="html"><![CDATA[<h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>&emsp;接着上一篇文章《Java 并发容器 之 ConcurrentHashMap(一)》，我们继续分析 ConcurrentHashMap。</p><h2 id="8-transfer"><a href="#8-transfer" class="headerlink" title="8. transfer()"></a>8. transfer()</h2><p>&emsp;真正执行数据迁移的是 transfer 函数，transfer 函数非常的长：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">transfer</span><span class="params">(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一部分</span></span><br><span class="line"><span class="comment">         * 计算单个线程能处理的最少桶结点个数和一些属性的初始化操作。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="comment">//计算单个线程允许处理的最少table桶首节点个数，不能小于 16</span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        <span class="comment">//刚开始扩容，初始化nextTab</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            <span class="comment">//transferIndex 指向最后一个桶，方便从后向前遍历 </span></span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">//定义 ForwardingNode 用于标记迁移完成的桶</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第二部分</span></span><br><span class="line"><span class="comment">         * 并发扩容控制的核心</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">boolean</span> advance = <span class="keyword">true</span>;</span><br><span class="line">        <span class="comment">//标志整张表是否完成迁移</span></span><br><span class="line">        <span class="keyword">boolean</span> finishing = <span class="keyword">false</span>; <span class="comment">// to ensure sweep before committing nextTab</span></span><br><span class="line">        <span class="comment">//i 指向当前桶，bound 指向当前线程需要处理的桶结点的区间下限</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, bound = <span class="number">0</span>;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> fh;</span><br><span class="line"></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2.1 计算当前线程当前允许操作的桶索引区间</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//while 循环计算负责迁移的桶的区间</span></span><br><span class="line">            <span class="comment">// advance 为 true 表示可以进行下一个位置的迁移了</span></span><br><span class="line">            <span class="comment">// 简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span></span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.1.1 i还在区间内</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//--i，向下一个位置迁移</span></span><br><span class="line">                <span class="comment">//移动后判断是否超出边界</span></span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    <span class="comment">//还在区间内，暂时置为false，当前节点迁移结束才会变成true</span></span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 说明已经没有需要迁移的桶了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.1.2 更新操作区间</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//更新 transferIndex</span></span><br><span class="line">                <span class="comment">//为当前线程分配任务，处理的桶结点区间为（nextBound,nextIndex）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="comment">//(bound,i]</span></span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2.2 当前线程的所有任务完成</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">                <span class="keyword">int</span> sc;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.2.1 如果整张表已经完成迁移，更新 table 和 sizeCtl</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                    <span class="comment">//清除缓存</span></span><br><span class="line">                    nextTable = <span class="keyword">null</span>;</span><br><span class="line">                    table = nextTab;</span><br><span class="line">                    <span class="comment">//修改sizeCtl</span></span><br><span class="line">                    sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//设置sizeCtl，当前参与迁移的线程数量-1</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">/**</span></span><br><span class="line"><span class="comment">                     * 2.2.2 其它线程还在扩容，只更新 sizeCtl 标志</span></span><br><span class="line"><span class="comment">                     */</span></span><br><span class="line">                    <span class="comment">//(resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2 </span></span><br><span class="line">                    <span class="comment">//相等说明只有当前线程在迁移数据，不等说明还有其它线程</span></span><br><span class="line">                    <span class="comment">//如果 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，说明当前线程就是最后一个还在扩容的线程，</span></span><br><span class="line">                    <span class="comment">//还有线程在扩容</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    <span class="comment">//没有线程在扩容，设置为true</span></span><br><span class="line">                    finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                    i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 第三部分：桶处理过程</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3.1 待迁移桶为空，那么在此位置 CAS 添加 ForwardingNode 结点标识该桶已经被处理过了</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i)) == <span class="keyword">null</span>)</span><br><span class="line">                advance = casTabAt(tab, i, <span class="keyword">null</span>, fwd);</span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3.2 如果扫描到 ForwardingNode，说明此桶已经被处理过了，跳过即可</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                advance = <span class="keyword">true</span>; <span class="comment">// already processed</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3.3 进行实际的迁移节点操作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//加锁</span></span><br><span class="line">                <span class="comment">//f为首节点</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="comment">// 将原链表一分为二，插入到新的table</span></span><br><span class="line">                        <span class="comment">// 找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span></span><br><span class="line">                        <span class="comment">// lastRun 之前的节点需要进行克隆，然后分到两个链表中</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">//链表的迁移操作</span></span><br><span class="line">                            <span class="comment">//n=2^k 只有一位是1</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;<span class="comment">//0或1，用来帮助将原链表拆分成两条子链表</span></span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">//整个for循环是为了找到最后一段连续节点 p.hash &amp; n 都相同的节点</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                                <span class="comment">//是否与前驱节点相同</span></span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//lastRun连接着后面其余节点的连接</span></span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//将lastRun前面的节点插入到子链表中</span></span><br><span class="line">                            <span class="comment">//lastRun后面的节点，已经连接到 ln 或者 hn 上了</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    <span class="comment">//前插法</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//把两条链表整体迁移到nextTab中</span></span><br><span class="line">                            <span class="comment">// 其中的一个链表放在新数组的位置 i</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">// 另一个链表放在新数组的位置 i+n</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                            <span class="comment">// 其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            <span class="comment">//迁移完成之后，设置为true，代表该位置已经迁移完毕，允许向下一个节点移动</span></span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//红黑树的复制算法</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; lo = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                            TreeNode&lt;K,V&gt; hi = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                            <span class="keyword">int</span> lc = <span class="number">0</span>, hc = <span class="number">0</span>;</span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = t.first; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> h = e.hash;</span><br><span class="line">                                TreeNode&lt;K,V&gt; p = <span class="keyword">new</span> TreeNode&lt;K,V&gt;</span><br><span class="line">                                    (h, e.key, e.val, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                                <span class="keyword">if</span> ((h &amp; n) == <span class="number">0</span>) &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = loTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        lo = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        loTail.next = p;</span><br><span class="line">                                    loTail = p;</span><br><span class="line">                                    ++lc;</span><br><span class="line">                                &#125;</span><br><span class="line">                                <span class="keyword">else</span> &#123;</span><br><span class="line">                                    <span class="keyword">if</span> ((p.prev = hiTail) == <span class="keyword">null</span>)</span><br><span class="line">                                        hi = p;</span><br><span class="line">                                    <span class="keyword">else</span></span><br><span class="line">                                        hiTail.next = p;</span><br><span class="line">                                    hiTail = p;</span><br><span class="line">                                    ++hc;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                             <span class="comment">// 如果一分为二后，节点数少于 8，那么将红黑树转换回链表</span></span><br><span class="line">                            ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) :</span><br><span class="line">                                (hc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(lo) : t;</span><br><span class="line">                            hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) :</span><br><span class="line">                                (lc != <span class="number">0</span>) ? <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hi) : t;</span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            <span class="comment">//迁移完成之后，设置为true，允许向下一个节点移动</span></span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;transfer 的整体过程为：</p><ul><li>1.计算单个线程能处理的最少桶结点个数和一些属性的初始化操作。</li><li>2.并发扩容控制的核心。<ul><li>2.1 计算当前线程当前允许操作的桶索引区间<ul><li>2.1.1 i还在区间内，索引向下一个位置移动</li><li>2.1.2 超出区间，更新操作区间</li></ul></li><li>2.2 如果当前线程的所有任务完成<ul><li>2.2.1 如果整张表已经完成迁移，更新 table 和 sizeCtl</li><li>2.2.2 其它线程还在扩容，只更新 sizeCtl 标志</li></ul></li></ul></li><li>3.桶处理过程<ul><li>3.1 待迁移桶为空，那么在此位置 CAS 添加 ForwardingNode 结点标识该桶已经被处理过了</li><li>3.2 如果扫描到 ForwardingNode，说明此桶已经被处理过了，跳过即可</li><li>3.3 加锁，进行实际的迁移节点操作，分为链表和红黑树两种情况，迁移结束后设置该位置为 ForwardingNode，标识该桶已经被处理</li></ul></li></ul><p>&emsp;上面的代码比较长，我们分段来分析。<br>&emsp;第一部分是计算单个线程能处理的最少桶结点个数(步长stribe)和一些属性的初始化操作。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一部分</span></span><br><span class="line"><span class="comment">         * 计算单个线程能处理的最少桶结点个数和一些属性的初始化操作。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">int</span> n = tab.length, stride;</span><br><span class="line">        <span class="comment">//计算单个线程允许处理的最少table桶首节点个数，不能小于 16</span></span><br><span class="line">        <span class="keyword">if</span> ((stride = (NCPU &gt; <span class="number">1</span>) ? (n &gt;&gt;&gt; <span class="number">3</span>) / NCPU : n) &lt; MIN_TRANSFER_STRIDE)</span><br><span class="line">            stride = MIN_TRANSFER_STRIDE; <span class="comment">// subdivide range</span></span><br><span class="line">        <span class="comment">//刚开始扩容，初始化nextTab</span></span><br><span class="line">        <span class="keyword">if</span> (nextTab == <span class="keyword">null</span>) &#123;            <span class="comment">// initiating</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                nextTab = nt;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable ex) &#123;      <span class="comment">// try to cope with OOME</span></span><br><span class="line">                sizeCtl = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            nextTable = nextTab;</span><br><span class="line">            <span class="comment">//transferIndex 指向最后一个桶，方便从后向前遍历 </span></span><br><span class="line">            transferIndex = n;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> nextn = nextTab.length;</span><br><span class="line">        <span class="comment">//定义 ForwardingNode 用于标记迁移完成的桶</span></span><br><span class="line">        ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br></pre></td></tr></table></figure><br>&emsp;这里需要注意的是，transferIndex 会在 nextTab 初始化的时候被设置 transferIndex = n，指向旧 table 的最后一个位置。transferIndex 是一个全局的变量，桶迁移过程是从最后一个位置往前遍历的，transferIndex 指向最新完成迁移(或者已经被分配给某个线程，将被处理)的桶位置。</p><p>&emsp;下面看一下第二部分的代码，首先看2.1，计算操作区间：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">        transferIndex = n;</span><br><span class="line">        ......</span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2.1 计算当前线程当前允许操作的桶索引区间</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="comment">//while 循环计算负责迁移的桶的区间</span></span><br><span class="line">            <span class="comment">// advance 为 true 表示可以进行下一个位置的迁移了</span></span><br><span class="line">            <span class="comment">// 简单理解结局：i 指向了 transferIndex，bound 指向了 transferIndex-stride</span></span><br><span class="line">            <span class="keyword">while</span> (advance) &#123;</span><br><span class="line">                <span class="keyword">int</span> nextIndex, nextBound;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.1.1 i还在区间内</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//--i，向下一个位置迁移</span></span><br><span class="line">                <span class="comment">//移动后判断是否超出边界</span></span><br><span class="line">                <span class="keyword">if</span> (--i &gt;= bound || finishing)</span><br><span class="line">                    <span class="comment">//还在区间内，暂时置为false，当前节点迁移结束才会变成true</span></span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//transferIndex &lt;= 0 说明已经没有需要迁移的桶了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 2.1.2 更新操作区间</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//更新 transferIndex</span></span><br><span class="line">                <span class="comment">//为当前线程分配任务，处理的桶结点区间为（nextBound,nextIndex）</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="comment">//(bound,i]</span></span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;在进行实际的数据迁移之前，要先计算当前线程允许操作的桶索引区间，单个线程允许处理的最少table桶首节点个数，不能小于 16，这个数量称为 stribe，步长。i 作为操作的桶索引，每一次允许操作的桶索引区间为（nextBound,nextIndex），其中 nextBound = nextIndex - stride。nextIndex 一开始等于 transferIndex，每个线程领取一个长度为 stribe 的区间，然后将 transferIndex 设置为 transferIndex - stribe：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这里设置了nextIndex</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> ((nextIndex = transferIndex) &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    i = -<span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//这里使用 UnSafe 设置 全局 transferIndex 为 transferIndex - stribe</span></span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt</span><br><span class="line">                         (<span class="keyword">this</span>, TRANSFERINDEX, nextIndex,</span><br><span class="line">                          nextBound = (nextIndex &gt; stride ?</span><br><span class="line">                                       nextIndex - stride : <span class="number">0</span>))) &#123;</span><br><span class="line">                    <span class="comment">//这里确定了操作区间为（bound,nextIndexs）</span></span><br><span class="line">                    bound = nextBound;</span><br><span class="line">                    i = nextIndex - <span class="number">1</span>;</span><br><span class="line">                    advance = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><br>&emsp;举例来说，原table的长度 n = 128，stribe = 16<br>&emsp;线程1首先进入扩容，设置 transferIndex = 128，transferIndex &gt; 0，则领取操作区间 (112,128],然后设置 transferIndex 为 112<br>&emsp;接着线程2进入协助扩容，此时 transferIndex = 112 &gt; 0,领取操作区间(96,112],然后设置 transferIndex 为 96<br>&emsp;接着线程1完成(112,128]区间的数据迁移，再次尝试领取操作区间，此时 transferIndex = 96 &gt; 0 ，领取区间 (80,96]，然后设置 transferIndex 为 80<br>&emsp;….<br>&emsp;直至 transferIndex &lt;= 0<br>&emsp;通过这种方式，就能够实现多个线程同时迁移不同的区间，做到并行化。</p><p>&emsp;接下来看代码2.2，当线程完成当前区间任务，且领取不到新的区间时，此时有两种情况：</p><ul><li>1.所有线程已经完成了所有区间的数据迁移</li><li>2.还有其它线程正在迁移某个区间</li></ul><p>&emsp;是否还存在其它线程正在迁移是通过 sizeCtl 来判断的<br>&emsp;sizeCtl = resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT + 2 表示只有一个线程在参与迁移，因此如果 (sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT 则说明还存在其它线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">            * 2.2 当前线程的所有任务完成</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (i &lt; <span class="number">0</span> || i &gt;= n || i + n &gt;= nextn) &#123;</span><br><span class="line">               <span class="keyword">int</span> sc;</span><br><span class="line">               <span class="comment">/**</span></span><br><span class="line"><span class="comment">                * 2.2.1 如果整张表已经完成迁移，更新 table 和 sizeCtl</span></span><br><span class="line"><span class="comment">                */</span></span><br><span class="line">               <span class="keyword">if</span> (finishing) &#123;</span><br><span class="line">                   <span class="comment">//清除缓存</span></span><br><span class="line">                   nextTable = <span class="keyword">null</span>;</span><br><span class="line">                   table = nextTab;</span><br><span class="line">                   <span class="comment">//修改sizeCtl</span></span><br><span class="line">                   sizeCtl = (n &lt;&lt; <span class="number">1</span>) - (n &gt;&gt;&gt; <span class="number">1</span>);</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="comment">//设置sizeCtl，当前参与迁移的线程数量-1</span></span><br><span class="line">               <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc = sizeCtl, sc - <span class="number">1</span>)) &#123;</span><br><span class="line">                   <span class="comment">/**</span></span><br><span class="line"><span class="comment">                    * 2.2.2 其它线程还在扩容，只更新 sizeCtl 标志</span></span><br><span class="line"><span class="comment">                    */</span></span><br><span class="line">                   <span class="comment">//(resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) + 2 </span></span><br><span class="line">                   <span class="comment">//相等说明只有当前线程在迁移数据，不等说明还有其它线程</span></span><br><span class="line">                   <span class="comment">//如果 (sc - 2) == resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT，说明当前线程就是最后一个还在扩容的线程，</span></span><br><span class="line">                   <span class="comment">//还有线程在扩容</span></span><br><span class="line">                   <span class="keyword">if</span> ((sc - <span class="number">2</span>) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT)</span><br><span class="line">                       <span class="keyword">return</span>;</span><br><span class="line">                   <span class="comment">//没有线程在扩容，设置为true</span></span><br><span class="line">                   finishing = advance = <span class="keyword">true</span>;</span><br><span class="line">                   i = n; <span class="comment">// recheck before commit</span></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;接下来看一下第三部分具体的桶处理过程，3.1和3.2比较简单，我们看一下3.3实际的迁移节点操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 3.3 进行实际的迁移节点操作</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//加锁</span></span><br><span class="line">                <span class="comment">//f为首节点</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        Node&lt;K,V&gt; ln, hn;</span><br><span class="line">                        <span class="comment">// 将原链表一分为二，插入到新的table</span></span><br><span class="line">                        <span class="comment">// 找到原链表中的 lastRun，然后 lastRun 及其之后的节点是一起进行迁移的</span></span><br><span class="line">                        <span class="comment">// lastRun 之前的节点需要进行克隆，然后分到两个链表中</span></span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">//链表的迁移操作</span></span><br><span class="line">                            <span class="comment">//n=2^k 只有一位是1</span></span><br><span class="line">                            <span class="keyword">int</span> runBit = fh &amp; n;<span class="comment">//0或1，用来帮助将原链表拆分成两条子链表</span></span><br><span class="line">                            Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">                            <span class="comment">//整个for循环是为了找到最后一段连续节点 p.hash &amp; n 都相同的节点</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">                                <span class="comment">//是否与前驱节点相同</span></span><br><span class="line">                                <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">                                    runBit = b;</span><br><span class="line">                                    lastRun = p;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//lastRun连接着后面其余节点的连接</span></span><br><span class="line">                            <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">                                ln = lastRun;</span><br><span class="line">                                hn = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                hn = lastRun;</span><br><span class="line">                                ln = <span class="keyword">null</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//将lastRun前面的节点插入到子链表中</span></span><br><span class="line">                            <span class="comment">//lastRun后面的节点，已经连接到 ln 或者 hn 上了</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">                                <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                                    <span class="comment">//前插法</span></span><br><span class="line">                                    ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//把两条链表整体迁移到nextTab中</span></span><br><span class="line">                            <span class="comment">// 其中的一个链表放在新数组的位置 i</span></span><br><span class="line">                            setTabAt(nextTab, i, ln);</span><br><span class="line">                            <span class="comment">// 另一个链表放在新数组的位置 i+n</span></span><br><span class="line">                            setTabAt(nextTab, i + n, hn);</span><br><span class="line">                            <span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line">                            <span class="comment">// 其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">                            setTabAt(tab, i, fwd);</span><br><span class="line">                            <span class="comment">//迁移完成之后，设置为true，代表该位置已经迁移完毕，允许向下一个节点移动</span></span><br><span class="line">                            advance = <span class="keyword">true</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//红黑树的复制算法</span></span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;</span><br><span class="line">                            ...</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;看一下链表的情况，跟 HashMap 的扩容类似，这里也是将原链表拆分成两条子链表然后插入到新的链表去，只是这里的实际操作有点不一样<br>&emsp;runBit = fh &amp; n，n=2^k 只有一位是1，做与操作，所以 runBit 为0或1，fh 是一个 hash 值，所以 runBit 的值应该是一个随机值0或1<br>接下遍历整个链表:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; lastRun = f;</span><br><span class="line">    <span class="comment">//整个for循环是为了找到最后一段连续节点 p.hash &amp; n 都相同的节点</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;K,V&gt; p = f.next; p != <span class="keyword">null</span>; p = p.next) &#123;</span><br><span class="line">    <span class="keyword">int</span> b = p.hash &amp; n;</span><br><span class="line">        <span class="comment">//是否与前驱节点相同</span></span><br><span class="line">    <span class="keyword">if</span> (b != runBit) &#123;</span><br><span class="line">            runBit = b;</span><br><span class="line">            lastRun = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里整个for循环是为了找到最后一段连续节点 p.hash &amp; n 都相同的节点<br>&emsp;举例来说，runBit = 1，链表上的每个节点依次取 p.hash &amp; n 之后为：0101011110001110101111，最后一段连续的是最后的 1111<br>&emsp;最终结果是 runBit = 1，lastRun 值向倒数第4个1的位置，也就是说，lastRun后面的所有节点的 p.hash &amp; n 都为1.<br>&emsp;具体为什么要这么做需要看到后面才能理解。<br>&emsp;紧接着：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//lastRun连接着后面其余节点的连接</span></span><br><span class="line">    <span class="keyword">if</span> (runBit == <span class="number">0</span>) &#123;</span><br><span class="line">        ln = lastRun;</span><br><span class="line">        hn = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        hn = lastRun;</span><br><span class="line">        ln = <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这时最后四个节点被连接到了 hn 链表上去<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将lastRun前面的节点插入到子链表中</span></span><br><span class="line">        <span class="comment">//lastRun后面的节点，已经连接到 ln 或者 hn 上了</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123;</span><br><span class="line">            <span class="keyword">int</span> ph = p.hash; K pk = p.key; V pv = p.val;</span><br><span class="line">            <span class="keyword">if</span> ((ph &amp; n) == <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//前插法</span></span><br><span class="line">                ln = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, ln);</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                hn = <span class="keyword">new</span> Node&lt;K,V&gt;(ph, pk, pv, hn);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里从头遍历 lastRun 前面的节点，如果 (ph &amp; n) == 0，则插入到 ln 链表，否则插入到 hn 链表，这里插入都是使用头插法。<br>&emsp;到这里我们可以知道，原链表 lastRun 前面的节点中 (ph &amp; n) == 0 的节点都被分配到 ln，不等于0的节点都被分配到 hn，而 lastRun 后面的节点已经被提前加到 hn 上面了，并且它们都是  (ph &amp; n) == 1，不需要再进行多余的判断了。所以前面先寻找 lastRun，将 lastRun 后面的节点一次性加入到 hn，能够省去后面很多的判断和链表操作。<br>&emsp;不得不感叹，源码作者的设计真的是非常的细致！</p><p>&emsp;最后，将 ln 和 hn 放到新 table 的 i 位置和 i+n 位置，然后把原 table 的该位置设置为 ForwardingNode，表示该位置已经完成数据迁移。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//把两条链表整体迁移到nextTab中</span></span><br><span class="line"><span class="comment">// 其中的一个链表放在新数组的位置 i</span></span><br><span class="line">setTabAt(nextTab, i, ln);</span><br><span class="line"><span class="comment">// 另一个链表放在新数组的位置 i+n</span></span><br><span class="line">setTabAt(nextTab, i + n, hn);</span><br><span class="line"><span class="comment">// 将原数组该位置处设置为 fwd，代表该位置已经处理完毕，</span></span><br><span class="line"><span class="comment">// 其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移了</span></span><br><span class="line">setTabAt(tab, i, fwd);</span><br><span class="line"><span class="comment">//迁移完成之后，设置为true，代表该位置已经迁移完毕，允许向下一个节点移动</span></span><br><span class="line">advance = <span class="keyword">true</span>;</span><br></pre></td></tr></table></figure></p><h2 id="9-addCount-amp-amp-size"><a href="#9-addCount-amp-amp-size" class="headerlink" title="9. addCount() &amp;&amp; size"></a>9. addCount() &amp;&amp; size</h2><p>&emsp;在 putVal 函数中，当我们成功的添加完成一个结点，最后是需要判断添加操作后是否会导致哈希表达到它的阈值，并针对不同情况决定是否需要进行扩容，还有 CAS 式更新哈希表实际存储的键值对数量。这些操作都封装在 addCount 这个方法中，下面我们看看该方法的具体实现，该方法主要做两个事情。一是更新数量，二是判断是否需要扩容，如果如果是增加节点(check&gt;=0)，则有可能超过阈值，就需要扩容。关于扩容部分不再赘述。这里更新数量的思想和 <a href="http://zhoujiapeng.top/java/java-atomicOperationClass/">LongAdder</a> 一样。它的方法是在内部维护多个 Cell 变量，多个线程对 value 的 CAS 操作可以分散到多个 Cell 变量上，减少了争夺共享资源的并发量，最后,在获取数量当前值时, 是把所有 Cell 变量的 value 值累加后再加上 base 返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//x为需要增加的数量</span></span><br><span class="line"><span class="comment">//check&gt;=0 增加节点，，check为更新后的数量</span></span><br><span class="line"><span class="comment">//check&lt;0，删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">addCount</span><span class="params">(<span class="keyword">long</span> x, <span class="keyword">int</span> check)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 第一部分，更新数量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        CounterCell[] as; <span class="keyword">long</span> b, s;</span><br><span class="line">        <span class="keyword">if</span> ((as = counterCells) != <span class="keyword">null</span> ||</span><br><span class="line">            <span class="comment">//更性 baseCount 为 b+x</span></span><br><span class="line">            !U.compareAndSwapLong(<span class="keyword">this</span>, BASECOUNT, b = baseCount, s = b + x)) &#123;</span><br><span class="line">            <span class="comment">//如果更新失败</span></span><br><span class="line">            </span><br><span class="line">            CounterCell a; <span class="keyword">long</span> v; <span class="keyword">int</span> m;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[ThreadLocalRandom.getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123;</span><br><span class="line">                <span class="comment">//高并发下 CAS 失败会执行 fullAddCount 方法</span></span><br><span class="line">                <span class="comment">// See LongAdder version for explanation</span></span><br><span class="line">                <span class="comment">//这里借鉴了 LongAdder 的思想</span></span><br><span class="line">                <span class="comment">//http://zhoujiapeng.top/java/java-atomicOperationClass/</span></span><br><span class="line">                fullAddCount(x, uncontended);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (check &lt;= <span class="number">1</span>)</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            s = sumCount();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//说明是增加节点，则有可能使得节点数量超过阈值</span></span><br><span class="line">        <span class="keyword">if</span> (check &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            Node&lt;K,V&gt;[] tab, nt; <span class="keyword">int</span> n, sc;</span><br><span class="line">            <span class="comment">//s = sumCount() 超过阈值 sizeCtl，需要扩容</span></span><br><span class="line">            <span class="keyword">while</span> (s &gt;= (<span class="keyword">long</span>)(sc = sizeCtl) &amp;&amp; (tab = table) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                   (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                <span class="comment">//获取扩容检验标识</span></span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123; <span class="comment">//如果正在初始化或扩容</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//协助扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//首先发起扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                             (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">                s = sumCount();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">size</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> n = sumCount();</span><br><span class="line">        <span class="keyword">return</span> ((n &lt; <span class="number">0L</span>) ? <span class="number">0</span> :</span><br><span class="line">                (n &gt; (<span class="keyword">long</span>)Integer.MAX_VALUE) ? Integer.MAX_VALUE :</span><br><span class="line">                (<span class="keyword">int</span>)n);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//和LongAddr一样，sum=baseCount+CounterCell[]</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">sumCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        CounterCell[] as = counterCells; CounterCell a;</span><br><span class="line">        <span class="keyword">long</span> sum = baseCount;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="10-remove"><a href="#10-remove" class="headerlink" title="10. remove()"></a>10. remove()</h2><p>&emsp;remove一个节点的思路为：</p><ul><li>1.如果table为空，或者找不到key，直接返回</li><li>2.table 正在扩容，协助迁移</li><li>3.找到对应的桶，锁住头节点，找到对应的节点进行移除操作</li><li>4.调用 addCount 减少数量<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">remove</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> replaceNode(key, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">replaceNode</span><span class="params">(Object key, V value, Object cv)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">//如果table为空，或者找不到key，直接返回</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span> ||</span><br><span class="line">                (f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="comment">//正在迁移，协助迁移</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//找到对应的桶</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">boolean</span> validated = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123;<span class="comment">//链表</span></span><br><span class="line">                            validated = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="comment">//遍历链表</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f, pred = <span class="keyword">null</span>;;) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    V ev = e.val;</span><br><span class="line">                                    <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == ev ||</span><br><span class="line">                                        (ev != <span class="keyword">null</span> &amp;&amp; cv.equals(ev))) &#123;</span><br><span class="line">                                        oldVal = ev;</span><br><span class="line">                                        <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                            e.val = value;</span><br><span class="line">                                        <span class="keyword">else</span> <span class="keyword">if</span> (pred != <span class="keyword">null</span>)</span><br><span class="line">                                            pred.next = e.next;</span><br><span class="line">                                        <span class="keyword">else</span></span><br><span class="line">                                            setTabAt(tab, i, e.next);</span><br><span class="line">                                    &#125;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                pred = e;</span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>)</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;<span class="comment">//树</span></span><br><span class="line">                            validated = <span class="keyword">true</span>;</span><br><span class="line">                            TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f;</span><br><span class="line">                            TreeNode&lt;K,V&gt; r, p;</span><br><span class="line">                            <span class="keyword">if</span> ((r = t.root) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                (p = r.findTreeNode(hash, key, <span class="keyword">null</span>)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                V pv = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (cv == <span class="keyword">null</span> || cv == pv ||</span><br><span class="line">                                    (pv != <span class="keyword">null</span> &amp;&amp; cv.equals(pv))) &#123;</span><br><span class="line">                                    oldVal = pv;</span><br><span class="line">                                    <span class="keyword">if</span> (value != <span class="keyword">null</span>)</span><br><span class="line">                                        p.val = value;</span><br><span class="line">                                    <span class="keyword">else</span> <span class="keyword">if</span> (t.removeTreeNode(p))</span><br><span class="line">                                        setTabAt(tab, i, untreeify(t.first));</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (validated) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (value == <span class="keyword">null</span>)</span><br><span class="line">                            <span class="comment">//更新数量</span></span><br><span class="line">                            addCount(-<span class="number">1L</span>, -<span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="11-clear"><a href="#11-clear" class="headerlink" title="11. clear()"></a>11. clear()</h2><p>&emsp;clear 方法将删除整张哈希表中所有的键值对，同样，如果发现table正在扩容，则需要先协助扩容，再进行hash表的清除操作，清除过程是一个桶一个桶删除，删除每一个桶之前会获取头节点的监视器锁，然后再删除hash表对该桶的引用，该桶就能够被自动回收了。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> delta = <span class="number">0L</span>; <span class="comment">// negative number of deletions</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        Node&lt;K,V&gt;[] tab = table;</span><br><span class="line">        <span class="comment">//遍历表中的所有桶</span></span><br><span class="line">        <span class="keyword">while</span> (tab != <span class="keyword">null</span> &amp;&amp; i &lt; tab.length) &#123;</span><br><span class="line">            <span class="keyword">int</span> fh;</span><br><span class="line">            Node&lt;K,V&gt; f = tabAt(tab, i);</span><br><span class="line">            <span class="keyword">if</span> (f == <span class="keyword">null</span>)</span><br><span class="line">                ++i;</span><br><span class="line">            <span class="comment">//正在扩容</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED) &#123;</span><br><span class="line">                <span class="comment">//协助扩容</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">                i = <span class="number">0</span>; <span class="comment">// restart</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//获取头节点的监视器锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="comment">//首节点</span></span><br><span class="line">                        Node&lt;K,V&gt; p = (fh &gt;= <span class="number">0</span> ? f :</span><br><span class="line">                                       (f <span class="keyword">instanceof</span> TreeBin) ?</span><br><span class="line">                                       ((TreeBin&lt;K,V&gt;)f).first : <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">while</span> (p != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            --delta;</span><br><span class="line">                            p = p.next;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//删除对桶的引用</span></span><br><span class="line">                        setTabAt(tab, i++, <span class="keyword">null</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (delta != <span class="number">0L</span>)</span><br><span class="line">            addCount(delta, -<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="12-get"><a href="#12-get" class="headerlink" title="12. get()"></a>12. get()</h2><p>&emsp;get 方法可以根据指定的键，返回对应的键值对，由于是读操作，可以不需要加锁。<br>get 方法的思路为：</p><ul><li>1.计算 hash 值 </li><li>2.根据 hash 值找到数组对应位置的桶: (n - 1) &amp; h </li><li>3.在该桶上找到对应的节点</li><li>4.如果找不到对应节点，返回null</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; <span class="keyword">int</span> n, eh; K ek;</span><br><span class="line">        <span class="comment">//计算hash</span></span><br><span class="line">        <span class="keyword">int</span> h = spread(key.hashCode());</span><br><span class="line">        <span class="comment">//定位到对应的桶</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (e = tabAt(tab, (n - <span class="number">1</span>) &amp; h)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//头节点就是</span></span><br><span class="line">            <span class="keyword">if</span> ((eh = e.hash) == h) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">             <span class="comment">// 如果头结点的 hash 小于 0，说明 正在扩容，或者该位置是红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (eh &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> (p = e.find(h, key)) != <span class="keyword">null</span> ? p.val : <span class="keyword">null</span>;</span><br><span class="line">            <span class="comment">//遍历链表</span></span><br><span class="line">            <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (e.hash == h &amp;&amp;</span><br><span class="line">                    ((ek = e.key) == key || (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek))))</span><br><span class="line">                    <span class="keyword">return</span> e.val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h2 id="13-总结"><a href="#13-总结" class="headerlink" title="13. 总结"></a>13. 总结</h2><p>&emsp;操作HashMap的时候遇到其它线程正在扩容的，不是阻塞等待，而是主动加入帮助扩容<br>说实话，Java8 ConcurrentHashMap 源码真心不简单，最难的在于扩容，数据迁移操作不容易看懂。<br>切分链表 runBit  lastRun</p><p>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.cnblogs.com/zaizhoumo/p/7709755.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaizhoumo/p/7709755.html</a><br><a href="https://www.cnblogs.com/yangming1996/p/8031199.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangming1996/p/8031199.html</a><br><a href="https://blog.csdn.net/sihai12345/article/details/79383766" target="_blank" rel="noopener">https://blog.csdn.net/sihai12345/article/details/79383766</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发容器 之 ConcurrentHashMap(一)</title>
      <link href="/java/java-ConcurrentHashMap/"/>
      <url>/java/java-ConcurrentHashMap/</url>
      
        <content type="html"><![CDATA[<blockquote><p>许久未更新，翻出一篇在草稿箱躺了半年的文章来更新一下，证明我回来了。立个flag，保持更新，做好知识总结。</p></blockquote><h1 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h1><p>&emsp;本文主要分析 JDK1.8 中的 ConcurrentHashMap。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;HashMap 是我们日常最常见的一种容器，它以键值对的形式完成对数据的存储，但众所周知，它在高并发的情境下是不安全的。ConcurrentHashMap 是 HashMap 的并发版本，它是线程安全的，并且在高并发的情境下，性能优于 HashMap 很多。</p><p>&emsp;jdk 1.7 采用分段锁技术，整个 Hash 表被分成多个段，每个段中会对应一个 Segment 段锁，段与段之间可以并发访问，但是多线程想要操作同一个段是需要获取锁的。所有的 put，get，remove 等方法都是根据键的 hash 值对应到相应的段中，然后尝试获取锁进行访问。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/ConcurrentHashMapJDK7.png" alt="HashMap"><br>(图片来源网络)</p><p>&emsp;jdk 1.8 取消了基于 Segment 的分段锁思想，改用 CAS + synchronized 控制并发操作，在某些方面提升了性能。并且追随 1.8 版本的 HashMap 底层实现，使用数组+链表+红黑树进行数据存储。本篇主要介绍 1.8 版本的 ConcurrentHashMap 的具体实现。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/ConcurrentHashMap.png" alt="HashMap"><br>(图片来源网络)</p><p>&emsp;毕竟 ConcurrentHaspMap 只在 HashMap 的基础上实现的，两者在思想会有很多重叠的地方，建议先阅读文章<a href="http://zhoujiapeng.top/java/java-HashMap">《深入理解 HashMap》</a>之后再来阅读本文，可能会理解得比较透彻。</p><h2 id="2-重要属性和构造函数"><a href="#2-重要属性和构造函数" class="headerlink" title="2. 重要属性和构造函数"></a>2. 重要属性和构造函数</h2><p>&emsp;首先看一下一些重要的属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//代表整个Hash表，容量总是2的n次幂</span></span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="comment">//临时表，用于哈希表扩容，扩容完成后会被重置为 null。</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line"></span><br><span class="line"><span class="comment">//baseCount+counterCells用来记录总元素的数量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">long</span> baseCount;</span><br><span class="line"><span class="comment">//2的n次幂</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> CounterCell[] counterCells;</span><br><span class="line"><span class="comment">//自旋锁，用于操作CounterCells</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> cellsBusy;</span><br><span class="line"></span><br><span class="line"><span class="comment">//非常重要的属性，下面详细介绍</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> sizeCtl;</span><br><span class="line"></span><br><span class="line"><span class="comment">//扩容时迁移数据用的，偏移量</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> <span class="keyword">int</span> transferIndex;</span><br></pre></td></tr></table></figure><br>&emsp;可以看到，这里用了baseCount+counterCells数组来记录元素总量，它的思想和 LongAddr 一样，主要是为了解决CAS自旋在高并发情况下的性能问题，具体可以参考文章<a href="http://zhoujiapeng.top/java/java-atomicOperationClass">《Java 并发编程 之 原子操作类》</a>，<br>LongAddr，这里简单介绍一下：<br>&emsp;它的方法是在内部维护多个 Cell 变量，多个线程对 value 的 CAS 操作可以分散到多个 Cell 变量上，减少了争夺共享资源的并发量，最后,在获取元素总数量时, 是把所有 Cell 变量的 value 值累加后再加上 baseCount 返回。</p><p>&emsp;另外，这里有一个非常重要的属性：sizeCtl。无论是初始化哈希表，还是扩容 rehash 的过程，都是需要依赖这个关键属性的。该属性有以下几种取值：</p><ul><li>0：默认值</li><li>-1：代表哈希表正在进行初始化</li><li>大于0：相当于 HashMap 中的 threshold，表示阈值</li><li>小于-1：代表有多个线程正在进行扩容</li></ul><p>&emsp;这个属性的使用是比较复杂的，在后面分析扩容过程结合实际场景再给出更详细的介绍。</p><p>&emsp;接下来看一下构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentHashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">int</span> cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ?</span><br><span class="line">                   MAXIMUM_CAPACITY :</span><br><span class="line">                   tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">this</span>.sizeCtl = cap;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这个初始化方法有点意思，通过提供初始容量，计算了 sizeCtl，sizeCtl = (1.5 <em> initialCapacity + 1)，然后向上取最近的 2 的 n 次方。这里的 (initialCapacity &gt;&gt;&gt; 1) 就等于 0.5</em>initialCapacity。例如， initialCapacity 为 10，那么得到 sizeCtl 为 16，如果 initialCapacity 为 11，得到 sizeCtl 为 32。</p><h2 id="2-put-方法"><a href="#2-put-方法" class="headerlink" title="2. put 方法"></a>2. put 方法</h2><p>&emsp;对于 HashMap 来说，多线程并发添加元素会导致数据丢失等并发问题，那么 ConcurrentHashMap 又是如何做到并发添加的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> putVal(key, value, <span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/** Implementation for put and putIfAbsent */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(K key, V value, <span class="keyword">boolean</span> onlyIfAbsent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (key == <span class="keyword">null</span> || value == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="comment">//计算hash</span></span><br><span class="line">        <span class="keyword">int</span> hash = spread(key.hashCode());</span><br><span class="line">        <span class="keyword">int</span> binCount = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;K,V&gt;[] tab = table;;) &#123;</span><br><span class="line">            Node&lt;K,V&gt; f; <span class="keyword">int</span> n, i, fh;</span><br><span class="line">            <span class="comment">//如果table还为初始化，那么初始化它</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">                tab = initTable();</span><br><span class="line">            <span class="comment">//根据hash找到相应的索引位置</span></span><br><span class="line">            <span class="comment">//如果该位置上为空，则使用CAS向该位置插入一个节点</span></span><br><span class="line">            <span class="comment">//注意这里给f和i赋值了</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((f = tabAt(tab, i = (n - <span class="number">1</span>) &amp; hash)) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (casTabAt(tab, i, <span class="keyword">null</span>,</span><br><span class="line">                             <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key, value, <span class="keyword">null</span>)))</span><br><span class="line">                    <span class="comment">//跳出循环</span></span><br><span class="line">                    <span class="keyword">break</span>;                   <span class="comment">// no lock when adding to empty bin</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//MOVED说明该桶的首节点是 Forwarding 类型</span></span><br><span class="line">            <span class="comment">//Forwarding 类型说明正在扩容，但是该位置的数据已经完成迁移，需要协助扩容</span></span><br><span class="line">            <span class="comment">//协助扩容完成之后重新循环</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((fh = f.hash) == MOVED)</span><br><span class="line">                <span class="comment">//协助扩容</span></span><br><span class="line">                tab = helpTransfer(tab, f);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//到这里说明，f是该位置的头节点，而且不为空</span></span><br><span class="line">                V oldVal = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//获取该头节点的监视器锁，准备插入新的节点</span></span><br><span class="line">                <span class="keyword">synchronized</span> (f) &#123; </span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, i) == f) &#123;</span><br><span class="line">                        <span class="keyword">if</span> (fh &gt;= <span class="number">0</span>) &#123; <span class="comment">// 头结点的 hash 值大于 0，说明是链表</span></span><br><span class="line">                            <span class="comment">//binCount随着链表的遍历增长</span></span><br><span class="line">                            binCount = <span class="number">1</span>;</span><br><span class="line">                            <span class="comment">//遍历链表</span></span><br><span class="line">                            <span class="keyword">for</span> (Node&lt;K,V&gt; e = f;; ++binCount) &#123;</span><br><span class="line">                                K ek;</span><br><span class="line">                                <span class="comment">//发现具有相同key的节点</span></span><br><span class="line">                                <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                                    ((ek = e.key) == key ||</span><br><span class="line">                                     (ek != <span class="keyword">null</span> &amp;&amp; key.equals(ek)))) &#123;</span><br><span class="line">                                    oldVal = e.val;</span><br><span class="line">                                    <span class="comment">//判断是否可以覆盖</span></span><br><span class="line">                                    <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                        e.val = value;</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                                Node&lt;K,V&gt; pred = e;</span><br><span class="line">                                <span class="comment">//最后一个节点，将新值插入到链表最后面</span></span><br><span class="line">                                <span class="keyword">if</span> ((e = e.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    pred.next = <span class="keyword">new</span> Node&lt;K,V&gt;(hash, key,</span><br><span class="line">                                                              value, <span class="keyword">null</span>);</span><br><span class="line">                                    <span class="keyword">break</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (f <span class="keyword">instanceof</span> TreeBin) &#123;<span class="comment">//红黑树</span></span><br><span class="line">                            Node&lt;K,V&gt; p;</span><br><span class="line">                            <span class="comment">//注意这里是2，不会增长</span></span><br><span class="line">                            binCount = <span class="number">2</span>;</span><br><span class="line">                            <span class="keyword">if</span> ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key,</span><br><span class="line">                                                           value)) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                                oldVal = p.val;</span><br><span class="line">                                <span class="keyword">if</span> (!onlyIfAbsent)</span><br><span class="line">                                    p.val = value;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//不等于0说明上面插入了新的节点</span></span><br><span class="line">                <span class="keyword">if</span> (binCount != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//红黑树的binCount = 2</span></span><br><span class="line">                    <span class="comment">//链表长度超过阈值，只有链表的情况才有可能是条件成立</span></span><br><span class="line">                    <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">                        <span class="comment">// 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，</span></span><br><span class="line">                        <span class="comment">// 如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树</span></span><br><span class="line">                        treeifyBin(tab, i);</span><br><span class="line">                    <span class="keyword">if</span> (oldVal != <span class="keyword">null</span>)</span><br><span class="line">                        <span class="keyword">return</span> oldVal;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        addCount(<span class="number">1L</span>, binCount);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;代码中的注释已经说明了大致每一步的操作，下面总结一下整个流程：</p><ul><li>table是否初始化<ul><li>否，初始化</li><li>是，根据key计算索引位置，该位置是否有数据<ul><li>无，CAS 插入一个新节点</li><li>有，是否为 MOVED，即正在扩容？<ul><li>是，协助扩容</li><li>否，锁住头节点，在该桶插入新的节点</li></ul></li></ul></li></ul></li><li>最后，判断插入新节点后长度是否超过阈值<ul><li>是，判断Hash表长度是否小于64<ul><li>是，Hash 表扩容</li><li>否，链表转化为红黑树</li></ul></li></ul></li></ul><p>&emsp;建议对照着这个框架再次走读一下代码，能够更清晰地把握整个脉络。</p><p>&emsp;put的主要流程解释完了，但却留下几个问题：</p><ol><li>为什么节点的Hash会等于MOVED？(fh = f.hash) == MOVED</li><li>Hash表的初始化在并发情况下是怎么进行的？initTable()</li><li>等于MOVED的时候需要协助扩容，那么协助扩容是怎么进行的？helpTransfer()</li><li>什么情况下会触发扩容？treeifyBin()</li></ol><p>&emsp;下面具体分析一下这几个问题。</p><h2 id="3-MOVED-amp-ForwardingNode"><a href="#3-MOVED-amp-ForwardingNode" class="headerlink" title="3. MOVED &amp; ForwardingNode"></a>3. MOVED &amp; ForwardingNode</h2><p>&emsp;首先看一下 ForwardingNode 的结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ForwardingNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Node&lt;K,V&gt;[] nextTable;</span><br><span class="line">        ForwardingNode(Node&lt;K,V&gt;[] tab) &#123;</span><br><span class="line">            <span class="keyword">super</span>(MOVED, <span class="keyword">null</span>, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">            <span class="keyword">this</span>.nextTable = tab;</span><br><span class="line">        &#125;</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;可以看到，ForwardingNode 的构造函数将 MOVED 作为参数传入了父类的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Node(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">this</span>.hash = hash;</span><br><span class="line">            <span class="keyword">this</span>.key = key;</span><br><span class="line">            <span class="keyword">this</span>.val = val;</span><br><span class="line">            <span class="keyword">this</span>.next = next;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;Node 的 hash 被设置成了 MOVED，它的意思是标志当前的Hash表正处于扩容的状态，而且当前桶的数据已经迁移到了新的table。<br>&emsp;在 transfer 函数里面，当 Hash 表中的某个桶的数据迁移结束之后，就会该桶头节点设置为 ForwardingNode：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ForwardingNode&lt;K,V&gt; fwd = <span class="keyword">new</span> ForwardingNode&lt;K,V&gt;(nextTab);</span><br><span class="line">...</span><br><span class="line">setTabAt(tab, i, fwd);</span><br></pre></td></tr></table></figure><br>&emsp;其他线程一旦看到该位置的 hash 值为 MOVED，就不会进行迁移，跳过该节点</p><p>&emsp;另外，ForwardingNode 里面还有一个属性 nextTable，它是对全局 nextTable 的引用，所有参与扩容的线程都会想将数据迁移到全局的 nextTable，扩容完成之后 nextTable 会被赋给全局 table，然后 nextTable 被置为 null。</p><h2 id="4-initTable"><a href="#4-initTable" class="headerlink" title="4. initTable()"></a>4. initTable()</h2><p>&emsp;initTable 方法是一个初始化哈希表的操作，可能会有多个线程同时调用这个方法，但它同时只允许一个线程进行初始化操作。它的并发问题是通过对 sizeCtl 进行一个 CAS 操作来控制的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Node&lt;K,V&gt;[] initTable() &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//说明其它线程正在初始化或者扩容table</span></span><br><span class="line">            <span class="keyword">if</span> ((sc = sizeCtl) &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="comment">//暂时放弃初始化，下一次循环在次重试</span></span><br><span class="line">                Thread.yield(); <span class="comment">// lost initialization race; just spin</span></span><br><span class="line">            <span class="comment">//进入这里可能不是第一次循环，可能其他线程已经完成了初始化</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="comment">//可能其它线程已经完成了table的初始化，需要再次判断</span></span><br><span class="line">                    <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || tab.length == <span class="number">0</span>) &#123;</span><br><span class="line">                        <span class="comment">// DEFAULT_CAPACITY 默认初始容量是 16</span></span><br><span class="line">                        <span class="keyword">int</span> n = (sc &gt; <span class="number">0</span>) ? sc : DEFAULT_CAPACITY;</span><br><span class="line">                        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                        Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                        table = tab = nt;</span><br><span class="line">                        <span class="comment">// 其实就是 0.75 * n，阈值</span></span><br><span class="line">                        sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//初始化结束之后，设置为阈值</span></span><br><span class="line">                    sizeCtl = sc;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;该方法的核心思想就是，只允许一个线程对表进行初始化，如果不巧有其他线程进来了，那么会让其他线程交出 CPU 等待下次系统调度。这样，保证了表同时只会被一个线程初始化。sizeCtl 为 -1 的时候就表示有其它线程正在执行初始化操作。</p><h2 id="5-treeifyBin"><a href="#5-treeifyBin" class="headerlink" title="5. treeifyBin()"></a>5. treeifyBin()</h2><p>&emsp;在 putVal 方法的最后，当判断插入节点之后数量超过阈值，就有可能触发扩容操作：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD)</span><br><span class="line">    treeifyBin(tab, i);</span><br></pre></td></tr></table></figure><br>&emsp;treeifyBin 这个方法和 HashMap 中稍微有一点点不同，那就是它不是一定会进行红黑树转换，如果当前数组的长度小于 64，那么会选择进行数组扩容，而不是转换为红黑树。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">treeifyBin</span><span class="params">(Node&lt;K,V&gt;[] tab, <span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; b; <span class="keyword">int</span> n, sc;</span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//长度小于64，进行数组扩容</span></span><br><span class="line">            <span class="keyword">if</span> ((n = tab.length) &lt; MIN_TREEIFY_CAPACITY)</span><br><span class="line">                tryPresize(n &lt;&lt; <span class="number">1</span>);</span><br><span class="line">            <span class="comment">//转化成红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((b = tabAt(tab, index)) != <span class="keyword">null</span> &amp;&amp; b.hash &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//加锁</span></span><br><span class="line">                <span class="keyword">synchronized</span> (b) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tabAt(tab, index) == b) &#123;</span><br><span class="line">                        TreeNode&lt;K,V&gt; hd = <span class="keyword">null</span>, tl = <span class="keyword">null</span>;</span><br><span class="line">                        <span class="keyword">for</span> (Node&lt;K,V&gt; e = b; e != <span class="keyword">null</span>; e = e.next) &#123;</span><br><span class="line">                            TreeNode&lt;K,V&gt; p =</span><br><span class="line">                                <span class="keyword">new</span> TreeNode&lt;K,V&gt;(e.hash, e.key, e.val,</span><br><span class="line">                                                  <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">                            <span class="keyword">if</span> ((p.prev = tl) == <span class="keyword">null</span>)</span><br><span class="line">                                hd = p;</span><br><span class="line">                            <span class="keyword">else</span></span><br><span class="line">                                tl.next = p;</span><br><span class="line">                            tl = p;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//将红黑树设置到数组相应的位置</span></span><br><span class="line">                        setTabAt(tab, index, <span class="keyword">new</span> TreeBin&lt;K,V&gt;(hd));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;treeifyBin 函数的逻辑比较简单，扩容是调用 tryPresize 函数，扩容后数组容量为原来的 2 倍。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//size为目标容量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">tryPresize</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">        <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * 1.计算新table的容量</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="comment">//取最近的 2 的 n 次方。</span></span><br><span class="line">        <span class="keyword">int</span> c = (size &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; <span class="number">1</span>)) ? MAXIMUM_CAPACITY :</span><br><span class="line">            tableSizeFor(size + (size &gt;&gt;&gt; <span class="number">1</span>) + <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="keyword">while</span> ((sc = sizeCtl) &gt;= <span class="number">0</span>) &#123;<span class="comment">//可以执行扩容操作</span></span><br><span class="line">            <span class="comment">/**</span></span><br><span class="line"><span class="comment">             * 2. 初始化table</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            Node&lt;K,V&gt;[] tab = table; <span class="keyword">int</span> n;</span><br><span class="line">            <span class="comment">//如果未初始化，则初始化，和 initTable 函数差不多</span></span><br><span class="line">            <span class="keyword">if</span> (tab == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>) &#123;</span><br><span class="line">                n = (sc &gt; c) ? sc : c;</span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, -<span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (table == tab) &#123;</span><br><span class="line">                            <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                            <span class="comment">//next table 新的table</span></span><br><span class="line">                            Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node&lt;?,?&gt;[n];</span><br><span class="line">                            table = nt;</span><br><span class="line">                            <span class="comment">//新的阈值 0.75n</span></span><br><span class="line">                            sc = n - (n &gt;&gt;&gt; <span class="number">2</span>);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        sizeCtl = sc;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (c &lt;= sc || n &gt;= MAXIMUM_CAPACITY)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (tab == table) &#123;</span><br><span class="line">                <span class="comment">//返回一个 16 位长度的扩容校验标识</span></span><br><span class="line">                <span class="comment">//第16位为1，1~15位和table的长度有关</span></span><br><span class="line">                <span class="keyword">int</span> rs = resizeStamp(n);</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 3.1 已经有其它线程正在扩容</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="keyword">if</span> (sc &lt; <span class="number">0</span>) &#123;<span class="comment">// sc = sizeCtl 有其它线程正在扩容</span></span><br><span class="line">                    Node&lt;K,V&gt;[] nt;\</span><br><span class="line">                    <span class="comment">//RESIZE_STAMP_SHIFT=16,不带符号右移动16，取高16位，高16位为扩容检验标识</span></span><br><span class="line">                    <span class="comment">//(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs 扩容检验标识错误</span></span><br><span class="line">                    <span class="comment">//sc == rs + 1 没有线程正在扩容，前面判断 sc&lt;0，所以表示有线程正在初始化table</span></span><br><span class="line">                    <span class="comment">//sc == rs + MAX_RESIZERS 当前参与扩容的线程数量已经达到上限</span></span><br><span class="line">                    <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                        sc == rs + MAX_RESIZERS || (nt = nextTable) == <span class="keyword">null</span> ||</span><br><span class="line">                        transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//sc+1，当前线程加入扩容</span></span><br><span class="line">                    <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>))</span><br><span class="line">                        <span class="comment">//数据迁移</span></span><br><span class="line">                        <span class="comment">//nt = nextTable</span></span><br><span class="line">                        <span class="comment">//已经有其它线程开始扩容，所以nt不为null</span></span><br><span class="line">                        <span class="comment">//表示迁移到已经存在的 nextTable</span></span><br><span class="line">                        <span class="comment">//tranfer 内部不需要去初始化 nextTable</span></span><br><span class="line">                        transfer(tab, nt);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">/**</span></span><br><span class="line"><span class="comment">                 * 3.2 没有其它线程正在扩容</span></span><br><span class="line"><span class="comment">                 */</span></span><br><span class="line">                <span class="comment">//当前没有其它线程在扩容，当前线程是第一个开始扩容的线程</span></span><br><span class="line">                <span class="comment">//将 sizeCtl 设置为 (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)</span></span><br><span class="line">                <span class="comment">// 参与扩容的线程数量是从+1开始，+2表示只有一个线程参与扩容，也就是当前线程</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc,</span><br><span class="line">                                               (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>))</span><br><span class="line">                    <span class="comment">//数据迁移</span></span><br><span class="line">                    <span class="comment">//传入的是null</span></span><br><span class="line">                    <span class="comment">//表示当前线程是第一个开始扩容的线程，transfer 内部会初始化 nextTable</span></span><br><span class="line">                    transfer(tab, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;tryPresize 的思路大概为：</p><ul><li>1.计算新table的容量</li><li>2.如果table还未初始化，则初始化它</li><li>3.通过sizeCtl判断是否有其它线程正在扩容<ul><li>3.1 有其它线程正在扩容，此时nextTable不为null，当前线程加入扩容，协助将数据迁移到nextTable</li><li>3.2 没有其它线程正在扩容，当前线程第一个开始扩容，此时nextTable为null，当前线程会在transfer方法里面初始化nextTable</li></ul></li></ul><p>&emsp;注意，当线程加入扩容的时候，需要验证扩容检验标识，每一次扩容，table的每一个新容量都会对应一个独一无二的检验标识，这个标识会被保存在 sizeCtl 里面，这能够确保所有线程都是在协助table扩容到相同大小。<br>扩容检验标识可以通过 resizeStamp 函数生成，下面我们看一下这个函数。</p><h2 id="6-resizeStamp-int-n"><a href="#6-resizeStamp-int-n" class="headerlink" title="6. resizeStamp(int n)"></a>6. resizeStamp(int n)</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">resizeStamp</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> Integer.numberOfLeadingZeros(n) | (<span class="number">1</span> &lt;&lt; (RESIZE_STAMP_BITS - <span class="number">1</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;这个函数很短，将 Integer.numberOfLeadingZeros(n) 和 (1 &lt;&lt; (RESIZE_STAMP_BITS - 1)) 做与运算。<br>Integer.numberOfLeadingZeros(n) 函数的作用是返回无符号整型n的最高非零位前面的0的个数，包括符号位在内。<br>&emsp;举例来说：<br>n = 1 = 0000 0000 …. 0001, 前面有31个0，所以结果是31<br>n = 8 = 0000 0000 …. 1000, 前面有28个0，所以结果是28<br>&emsp;需要注意的是，table的容量，也就是n，总是为2的k次幂，n=2^k，也就是 n 的二进制表示只有一位是1，其它位都是0，所以 n 和 Integer.numberOfLeadingZeros(n) 是一一对应的，用这个很小的数来代表 n，可以确保15位以下能够储存。<br>&emsp;再看一下后面部分，这里的 RESIZE_STAMP_BITS =16，所以 (1 &lt;&lt; (RESIZE_STAMP_BITS - 1)) = 1000 0000 0000 0000，用这个数和 Integer.numberOfLeadingZeros(n) 做与运算，resizeStamp 最终返回的是一个16位的整数，并且最高位为1，这个数对每次扩容都是不一样的，所以可以作为每次扩容时的数据检验标识。而这里为什么要将第16位置为1呢？<br>&emsp;我们知道，当 sizeCtl &lt; -1 的时候，代表有多个线程正在执行扩容操作，此时 sizeCtl 的高16位会作为扩容检验标识，低16位则为 参与扩容的线程数量-1。回到 tryPresize 函数部分，可以看到，在代码3.2 那里，第一个开始扩容的线程会调用 resizeStamp 生成扩容检验标识 rs，然后设置 sizeCtl：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + <span class="number">2</span>)</span><br></pre></td></tr></table></figure><br>&emsp;RESIZE_STAMP_SHIFT=16，此时sc的高16位为扩容检验标识rs，低16位为2，并且此时sc的最高位是1，也就是sc是一个负数，低16位表示参与扩容的线程数量+1.如果是从 1 开始，则有可能导致sc=-1，而sc=-1已经有特殊含义，表示正在初始化table，因此低16位是从2开始的。这也就解释了为什么当 sc&lt;-1 时，表示当前正在执行扩容操作。</p><h2 id="7-helpTransfer"><a href="#7-helpTransfer" class="headerlink" title="7. helpTransfer()"></a>7. helpTransfer()</h2><p>&emsp;在 tryPresize 函数里面最终会调用 transfer 函数去执行真正的数据迁移操作，transfer 函数比较长，留着<a href="">下一篇文章</a>介绍，我们先来看一下 helpTransfer 函数，这个函数最终也会调用 transfer 函数。<br>&emsp;helpTransfer 从字面上理解就是帮助转移，也就时协助扩容：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123;</span><br><span class="line">        Node&lt;K,V&gt;[] nextTab; <span class="keyword">int</span> sc;</span><br><span class="line">        <span class="comment">//table不为空，且头节点为ForwardingNode</span></span><br><span class="line">        <span class="comment">//表示当前正在扩容，并且当前索引位置已经完成数据迁移</span></span><br><span class="line">        <span class="comment">//nextTable是新table的引用</span></span><br><span class="line">        <span class="keyword">if</span> (tab != <span class="keyword">null</span> &amp;&amp; (f <span class="keyword">instanceof</span> ForwardingNode) &amp;&amp;</span><br><span class="line">            (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//扩容校验标识</span></span><br><span class="line">            <span class="keyword">int</span> rs = resizeStamp(tab.length);</span><br><span class="line">            <span class="keyword">while</span> (nextTab == nextTable &amp;&amp; table == tab &amp;&amp;</span><br><span class="line">                   (sc = sizeCtl) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//(sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs 扩容检验标识错误</span></span><br><span class="line">                <span class="comment">//sc == rs + 1 没有线程正在扩容，前面判断 sc&lt;0，所以表示有线程正在初始化table</span></span><br><span class="line">                <span class="comment">//sc == rs + MAX_RESIZERS 当前参与扩容的线程数量已经达到上限</span></span><br><span class="line">                <span class="keyword">if</span> ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + <span class="number">1</span> ||</span><br><span class="line">                    sc == rs + MAX_RESIZERS || transferIndex &lt;= <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//sc+1 标识增加了一个线程进行扩容</span></span><br><span class="line">                <span class="keyword">if</span> (U.compareAndSwapInt(<span class="keyword">this</span>, SIZECTL, sc, sc + <span class="number">1</span>)) &#123;</span><br><span class="line">                    <span class="comment">//进行扩容</span></span><br><span class="line">                    transfer(tab, nextTab);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> nextTab;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> table;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="未完"><a href="#未完" class="headerlink" title="未完"></a>未完</h2><p>&emsp;由于篇幅原因，关于 transfer 等其它函数的分析请看《Java 并发容器 之 ConcurrentHashMap(二)》</p><p>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.cnblogs.com/zaizhoumo/p/7709755.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaizhoumo/p/7709755.html</a><br><a href="https://www.cnblogs.com/yangming1996/p/8031199.html" target="_blank" rel="noopener">https://www.cnblogs.com/yangming1996/p/8031199.html</a><br><a href="https://blog.csdn.net/sihai12345/article/details/79383766" target="_blank" rel="noopener">https://blog.csdn.net/sihai12345/article/details/79383766</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BCOS 动态群组架构</title>
      <link href="/blockchain/bcos-group-architecture/"/>
      <url>/blockchain/bcos-group-architecture/</url>
      
        <content type="html"><![CDATA[<h1 id="BCOS-动态群组架构"><a href="#BCOS-动态群组架构" class="headerlink" title="BCOS 动态群组架构"></a>BCOS 动态群组架构</h1><p>分析 BCOS 动态群组架构的目的在于研究动态群组架构和共识机制中节点动态性的关系，最终基于 BCOS 的共识模块接口实现新的共识算法。</p><h1 id="1-群组架构的设计"><a href="#1-群组架构的设计" class="headerlink" title="1. 群组架构的设计"></a>1. 群组架构的设计</h1><blockquote><p>来源：<a href="https://mp.weixin.qq.com/s?__biz=MzU5NTg0MjA4MA==&amp;mid=2247483919&amp;idx=1&amp;sn=035d336c6888fa87eec1e579d7b503d1&amp;scene=19#wechat_redirect" target="_blank" rel="noopener">FISCO BCOS开源社区：群组架构的设计</a></p></blockquote><h2 id="1-1-架构设计全景"><a href="#1-1-架构设计全景" class="headerlink" title="1.1 架构设计全景"></a>1.1 架构设计全景</h2><p><img src="https://gitee.com/JP6907/Pic/raw/master/bcos/group-architecture.png" alt="架构设计全景"></p><p>如上图所示，群组架构自底向下主要划分为网络层、群组层，网络层主要负责区块链节点间通信，群组层主要负责处理群组内交易，每个群组均运行着一个独立的账本。</p><h2 id="1-2-网络层"><a href="#1-2-网络层" class="headerlink" title="1.2 网络层"></a>1.2 网络层</h2><p>群组架构中，所有群组共享P2P网络，群组层传递给网络层的数据包中含有群组ID信息，接收节点根据数据包中的群组ID，将收到的数据包传递给目标节点的相应群组</p><p>为了做到群组间通信数据隔离，群组架构引入了账本白名单机制，下图展示了群组架构下群组间收发消息的流程：</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/bcos/arcitecture-network.png" alt="网络层"></p><p><strong>账本白名单</strong><br>每个群组均持有一个账本白名单，用于维护该群组的节点列表。为了保证账本白名单群组内一致性，仅可通过发交易共识的方式修改账本白名单。</p><p><strong>发包流程</strong></p><p>以node0的第一组向node1的第一组发送消息packetA为例：<br>(1) group1将消息packetA传递到网络层；<br>(2) 网络层模块对packetA进行编码，在packetA包头加上本群组ID，记为{groupID(1) + packetA}；<br>(3) 网络层访问账本白名单，判断node0是否是group1的节点，若非group1节点，则拒绝数据包；若是group1节点，则将编码后的包发送给目标节点node1。</p><p><strong>收包流程</strong><br>node1接收到node0 group1的数据包{groupID(1) + packetA}后：<br>(1) 网络层访问账本白名单，判断源节点node0是否是group1节点，若非group1节点，则拒绝数据包，否则将数据包传递给解码模块；<br>(2) 解码模块从数据包中解码出group ID=1和数据包packetA，将数据包packetA发送到group1。</p><p>通过账本白名单，可以有效地防止群组节点获取其他群组通信消息，保障了群组网络通信的隐私性。</p><h2 id="1-3-群组层"><a href="#1-3-群组层" class="headerlink" title="1.3 群组层"></a>1.3 群组层</h2><p>群组层是群组架构的核心。为了实现群组间账本数据的隔离，每个群组持有单独的账本模块。<br>群组层自下向上一次分为核心层、接口层和调度层：核心层提供底层存储和交易执行接口；接口层是访问核心层的接口；调度层包括同步和共识模块，负责处理交易、同步交易和区块。</p><h1 id="2-动态群组架构的实现"><a href="#2-动态群组架构的实现" class="headerlink" title="2. 动态群组架构的实现"></a>2. 动态群组架构的实现</h1><p>动态群组架构涉及的各个模块之间的关系如图：</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/bcos/model.png" alt="模块关系图"></p><h2 id="2-1-节点列表的读取"><a href="#2-1-节点列表的读取" class="headerlink" title="2.1 节点列表的读取"></a>2.1 节点列表的读取</h2><p>获取节点列表信息有两种方式<br>ConsensusEngineBase::sealerList()  直接返回 m_sealerList，这种方式是sealer需要获取当前节点所在组的节点列表时使用<br>BlockChainImp::sealerList()   从账本白名单中查询节点列表，保存在 P2PService 的 m_groupID2NodeList 中，并更新 BlockChainImp.m_sealerList，这种方式会在需要发送消息时调用 P2PService 时使用；</p><p>m_groupID2NodeList 由 P2PService 维护，保存了所有的群组节点列表信息。<br>m_sealerList 由 sealer 保存，会被 P2PService 更新，保存了当前节点所在 group 的节点列表信息。</p><h2 id="2-2-群组信息的初始化"><a href="#2-2-群组信息的初始化" class="headerlink" title="2.2 群组信息的初始化"></a>2.2 群组信息的初始化</h2><p>在账本初始化的时候，LedgerInitializer 会为每个group创建一个独立的账本，并从配置文件中读取群组信息，保存到 P2PService  的 m_groupID2NodeList 和 ConsensusEngineBase 的 m_sealerList 中。</p><h2 id="2-3-群组信息保持更新"><a href="#2-3-群组信息保持更新" class="headerlink" title="2.3 群组信息保持更新"></a>2.3 群组信息保持更新</h2><p>节点需要广播信息时会通过P2PServer模块获取群组信息，P2PServer会从账本节点白名单中读取最新的节点列表，并更新到 m_sealerList 和 m_groupID2NodeList 。</p><h2 id="2-4-动态群组实现"><a href="#2-4-动态群组实现" class="headerlink" title="2.4 动态群组实现"></a>2.4 动态群组实现</h2><p>账本白名单维护了群组信息，为了保证账本白名单群组内一致性，只能通过交易共识来修改账本白名单。系统已经内置了修改白名单的预编译合约(ConsensusPrecompiled)，console 已经实现了调用这些合约的命令，如将某节点添加到某group中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 2. 将node2加入到共识节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> addSealer后面的参数是上步获取的node ID</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [group:2]&gt; addSealer 6dc585319e4cf7d73ede73819c6966ea4bed74aadbbcba1bbb777132f63d355965c3502bed7a04425d99cdcfb7694a1c133079e6d9b0ab080e3b874882b95ff4</span></span><br><span class="line">&#123;</span><br><span class="line">    "code":0,</span><br><span class="line">    "msg":"success"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>addSealer实际上是通过 web3sdk 调用了 ConsensusPrecompiled 预编译合约的 addSealer 接口，来实现对账本白名单的修改。</p><h2 id="2-5-账本白名单"><a href="#2-5-账本白名单" class="headerlink" title="2.5 账本白名单"></a>2.5 账本白名单</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">storage::Table::Ptr table = openTable(context, SYS_CONSENSUS);</span><br></pre></td></tr></table></figure><h1 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h1><p>见<a href="http://zhoujiapeng.top/blockchain/bcos-group-architecture-code/">《BCOS动态群组源码分析》</a>。</p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>BCOS在网络层P2PService中已经实现了对节点动态性的控制，共识算法中只需要考虑单个群组内部的共识问题，不需要考虑动态性的问题。如果在共识算法中接入节点动态控制，反而会增加算法的复杂性，并且不会带来好处。</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> bcos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BCOS 动态群组架构源码分析</title>
      <link href="/blockchain/bcos-group-architecture-code/"/>
      <url>/blockchain/bcos-group-architecture-code/</url>
      
        <content type="html"><![CDATA[<h1 id="BCOS-动态群组架构源码分析"><a href="#BCOS-动态群组架构源码分析" class="headerlink" title="BCOS 动态群组架构源码分析"></a>BCOS 动态群组架构源码分析</h1><p>本文基于<a href="http://zhoujiapeng.top/blockchain/bcos-group-architecture/">《BCOS 动态群组架构》</a>，从源码角度对动态群组架构的实现做进一步分析。</p><h2 id="3-1-群组信息的初始化"><a href="#3-1-群组信息的初始化" class="headerlink" title="3.1 群组信息的初始化"></a>3.1 群组信息的初始化</h2><p>这得从Ledger的构造说起。。。</p><h3 id="3-1-1-groupId-和-protocol-id"><a href="#3-1-1-groupId-和-protocol-id" class="headerlink" title="3.1.1 groupId 和 protocol_id"></a>3.1.1 groupId 和 protocol_id</h3><p>Ledger 构造的时候需要传进一个 service，以及 groupId<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Ledger(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;dev::p2p::P2PInterface&gt; service, dev::GROUP_ID <span class="keyword">const</span>&amp; _groupId,</span><br><span class="line">        dev::KeyPair <span class="keyword">const</span>&amp; _keyPair, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; _baseDir)</span><br><span class="line">      : LedgerInterface(_keyPair), m_service(service), m_groupId(_groupId)</span><br></pre></td></tr></table></figure><br>Ledger在初始化交易池的时候会计算一个protocol_id，它绑定了m_groupId<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/// init txpool</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Ledger::initTxPool</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dev::PROTOCOL_ID protocol_id = getGroupProtoclID(m_groupId, ProtocolID::TxPool);</span><br><span class="line">    ... </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>protocol_id 和 sealer 的构造有关。</p><h3 id="3-1-2-pbftEngine-和-pbftSealer"><a href="#3-1-2-pbftEngine-和-pbftSealer" class="headerlink" title="3.1.2 pbftEngine 和 pbftSealer"></a>3.1.2 pbftEngine 和 pbftSealer</h3><p>看一下 Ledger 中 pbftSealer 的构造过程：<br>Ledger模块涉及到了PBFT，新的共识算法需要在这里做修改<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sealer&gt; <span class="title">Ledger::createPBFTSealer</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//获取protocol_id</span></span><br><span class="line">    dev::PROTOCOL_ID protocol_id = getGroupProtoclID(m_groupId, ProtocolID::PBFT);</span><br><span class="line">    <span class="comment">/// create consensus engine according to "consensusType"</span></span><br><span class="line">    Ledger_LOG(DEBUG) &lt;&lt; LOG_BADGE(<span class="string">"initLedger"</span>) &lt;&lt; LOG_BADGE(<span class="string">"createPBFTSealer"</span>)</span><br><span class="line">                      &lt;&lt; LOG_KV(<span class="string">"baseDir"</span>, m_param-&gt;baseDir()) &lt;&lt; LOG_KV(<span class="string">"Protocol"</span>, protocol_id);</span><br><span class="line">   　</span><br><span class="line">    <span class="comment">//pbftSealer和protocol_id是绑定的</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PBFTSealer&gt; pbftSealer = <span class="built_in">std</span>::make_shared&lt;PBFTSealer&gt;(m_service, m_txPool,</span><br><span class="line">        m_blockChain, m_sync, m_blockVerifier, protocol_id, m_param-&gt;baseDir(), m_keyPair,</span><br><span class="line">        m_param-&gt;mutableConsensusParam().sealerList); <span class="comment">//这里读取了节点列表</span></span><br><span class="line"></span><br><span class="line">    pbftSealer-&gt;setEnableDynamicBlockSize(m_param-&gt;mutableConsensusParam().enableDynamicBlockSize);</span><br><span class="line">    pbftSealer-&gt;setBlockSizeIncreaseRatio(m_param-&gt;mutableConsensusParam().blockSizeIncreaseRatio);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// set params for PBFTEngine</span></span><br><span class="line">    <span class="comment">//使用pbftSealer创建pbftEngine</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PBFTEngine&gt; pbftEngine =</span><br><span class="line">        <span class="built_in">std</span>::dynamic_pointer_cast&lt;PBFTEngine&gt;(pbftSealer-&gt;consensusEngine());</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">return</span> pbftSealer;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>createPBFTSealer 方法中 protocol_id 作为创建 pbftSealer 的一个参数，然后根据 pbftSealer 创建 pbftEngine<br>因此 Ledger、groupId、protocol_id、pbftSealer、pbftEngine 是一一对应的关系<br>传递关系为：<br>groupId -&gt; protocol_id -&gt; Ledger -&gt; pbftSealer -&gt; pbftEngine</p><h3 id="3-1-3-service"><a href="#3-1-3-service" class="headerlink" title="3.1.3 service"></a>3.1.3 service</h3><p>Ledger 创建的时候还有另外一个构造参数 service，类型是 dev::p2p::P2PInterface，它用来提供 P2P网络服务，群组信息就是保存在 p2pservice 中的<br>这个 service 会在系统初始化的时候 Initializer 中被设置：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Initializer.h</span></span><br><span class="line"><span class="function">LedgerInitializer::Ptr <span class="title">ledgerInitializer</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> m_ledgerInitializer; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Initializer.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Initializer::init</span><span class="params">(<span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; _path)</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">        m_ledgerInitializer = <span class="built_in">std</span>::make_shared&lt;LedgerInitializer&gt;();</span><br><span class="line">        <span class="comment">//设置p2pservice</span></span><br><span class="line">        m_ledgerInitializer-&gt;setP2PService(m_p2pInitializer-&gt;p2pService());</span><br><span class="line">        m_ledgerInitializer-&gt;setKeyPair(m_secureInitializer-&gt;keyPair());</span><br><span class="line">        m_ledgerInitializer-&gt;setChannelRPCServer(m_rpcInitializer-&gt;channelRPCServer());</span><br><span class="line">        m_ledgerInitializer-&gt;initConfig(pt);</span><br><span class="line">        </span><br><span class="line">        m_rpcInitializer-&gt;setLedgerManager(m_ledgerInitializer-&gt;ledgerManager());</span><br><span class="line">        m_rpcInitializer-&gt;initConfig(pt);</span><br><span class="line">        m_ledgerInitializer-&gt;startAll();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-1-4-Ledger-的初始化"><a href="#3-1-4-Ledger-的初始化" class="headerlink" title="3.1.4 Ledger 的初始化"></a>3.1.4 Ledger 的初始化</h3><p>Ledger的初始化由LedgerInitializer统一管理，它会为每个group创建独立的账本<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">LedgerInitializer::initLedgers() <span class="comment">//为每个group创建独立的账本</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;dev::GROUP_ID&gt; newGroupIDList;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        newGroupIDList = foreachLedgerConfigure(</span><br><span class="line">            m_groupConfigPath, [&amp;](dev::GROUP_ID <span class="keyword">const</span>&amp; _groupID, <span class="keyword">const</span> <span class="built_in">string</span>&amp; _configFileName) &#123;</span><br><span class="line">                <span class="comment">// skip existing group</span></span><br><span class="line">                <span class="keyword">if</span> (m_ledgerManager-&gt;isLedgerExist(_groupID))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//为每个group创建Ledger</span></span><br><span class="line">                <span class="keyword">bool</span> succ = initLedger(_groupID, m_groupDataDir, _configFileName);</span><br><span class="line">                <span class="keyword">if</span> (!succ)</span><br><span class="line">                &#123;</span><br><span class="line">                    INITIALIZER_LOG(ERROR)</span><br><span class="line">                        &lt;&lt; LOG_BADGE(<span class="string">"LedgerInitializer"</span>) &lt;&lt; LOG_DESC(<span class="string">"initSingleGroup failed"</span>)</span><br><span class="line">                        &lt;&lt; LOG_KV(<span class="string">"configFile"</span>, _configFileName);</span><br><span class="line">                    ERROR_OUTPUT &lt;&lt; LOG_BADGE(<span class="string">"LedgerInitializer"</span>)</span><br><span class="line">                                 &lt;&lt; LOG_DESC(<span class="string">"initSingleGroup failed"</span>)</span><br><span class="line">                                 &lt;&lt; LOG_KV(<span class="string">"configFile"</span>, _configFileName) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">                    BOOST_THROW_EXCEPTION(InitLedgerConfigFailed());</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//从配置文件中读取节点列表</span></span><br><span class="line">                h512s sealerList = m_ledgerManager-&gt;getParamByGroupId(_groupID)</span><br><span class="line">                                       -&gt;mutableConsensusParam()</span><br><span class="line">                                       .sealerList;</span><br><span class="line">                <span class="comment">//将节点列表保存到p2pservice中</span></span><br><span class="line">                m_p2pService-&gt;setNodeListByGroupID(_groupID, sealerList);</span><br><span class="line">                LOG(INFO) &lt;&lt; LOG_BADGE(<span class="string">"LedgerInitializer init group succ"</span>)</span><br><span class="line">                          &lt;&lt; LOG_KV(<span class="string">"groupID"</span>, _groupID);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        INITIALIZER_LOG(ERROR) &lt;&lt; LOG_BADGE(<span class="string">"LedgerInitializer"</span>)</span><br><span class="line">                               &lt;&lt; LOG_DESC(<span class="string">"parse group config faield"</span>)</span><br><span class="line">                               &lt;&lt; LOG_KV(<span class="string">"EINFO"</span>, boost::diagnostic_information(e));</span><br><span class="line">        ERROR_OUTPUT &lt;&lt; LOG_BADGE(<span class="string">"LedgerInitializer"</span>) &lt;&lt; LOG_DESC(<span class="string">"parse group config faield"</span>)</span><br><span class="line">                     &lt;&lt; LOG_KV(<span class="string">"EINFO"</span>, boost::diagnostic_information(e)) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        BOOST_THROW_EXCEPTION(e);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> newGroupIDList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>initLedgers 方法的流程为：</p><ul><li>遍历所有group</li><li>根据groupId创建Ledger</li><li>从配置文件中读取sealerList</li><li>保存sealerList到p2pservice中</li></ul><p>根据groupId从配置文件中读取节点列表：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">h512s sealerList = m_ledgerManager-&gt;getParamByGroupId(_groupID)</span><br><span class="line">                                       -&gt;mutableConsensusParam()</span><br><span class="line">                                       .sealerList;</span><br><span class="line">m_p2pService-&gt;setNodeListByGroupID(_groupID, sealerList);</span><br></pre></td></tr></table></figure><br>将sealer节点列表保存到p2pSerivce的m_groupID2NodeList中<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setNodeListByGroupID</span><span class="params">(GROUP_ID _groupID, dev::h512s _nodeList)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">RecursiveGuard <span class="title">l</span><span class="params">(x_nodeList)</span></span>;</span><br><span class="line">        m_groupID2NodeList[_groupID] = _nodeList;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>群组关系会被储存到m_groupID2NodeList中</p><p>前面介绍过，有两个地方会保存群组信息：</p><ul><li>ConsensusEngineBase 中的 m_sealerList</li><li>P2PService 中的 m_groupID2NodeList 中</li></ul><p>initLedgers方法 或读取所有的群组信息保存到 m_groupID2NodeList 中，而 m_sealerList 是在 createPBFTSealer 方法中被初始化的：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;Sealer&gt; <span class="title">Ledger::createPBFTSealer</span><span class="params">()</span></span>&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;PBFTSealer&gt; pbftSealer = <span class="built_in">std</span>::make_shared&lt;PBFTSealer&gt;(m_service, m_txPool,</span><br><span class="line">        m_blockChain, m_sync, m_blockVerifier, protocol_id, m_param-&gt;baseDir(), m_keyPair,</span><br><span class="line">        m_param-&gt;mutableConsensusParam().sealerList); <span class="comment">//这里读取了节点列表</span></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>这里通过m_param读取了节点列表。<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Ledger(<span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;dev::p2p::P2PInterface&gt; service, dev::GROUP_ID <span class="keyword">const</span>&amp; _groupId,</span><br><span class="line">        dev::KeyPair <span class="keyword">const</span>&amp; _keyPair, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; _baseDir)</span><br><span class="line">      : LedgerInterface(_keyPair), m_service(service), m_groupId(_groupId)</span><br><span class="line">    &#123;</span><br><span class="line">        m_param = <span class="built_in">std</span>::make_shared&lt;LedgerParam&gt;();</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> prefix = _baseDir + <span class="string">"/group"</span> + <span class="built_in">std</span>::to_string(_groupId);</span><br><span class="line">        <span class="keyword">if</span> (_baseDir == <span class="string">""</span>)</span><br><span class="line">            prefix = <span class="string">"./group"</span> + <span class="built_in">std</span>::to_string(_groupId);</span><br><span class="line">        m_param-&gt;setBaseDir(prefix);</span><br><span class="line">        <span class="comment">// m_keyPair = _keyPair;</span></span><br><span class="line">        assert(m_service);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>可以看到，这里已经指定了groupid，所以m_sealerList 保存的只是当前节点所在group的节点列表。</p><h3 id="3-1-5-总结"><a href="#3-1-5-总结" class="headerlink" title="3.1.5 总结"></a>3.1.5 总结</h3><p>账本初始化 LedgerInitializer::initLedgers() 会为每个group初始化一个Ledger，并且从配置文件中读取群组信息，保存到 m_p2pService 的 m_groupID2NodeList 中，它保存了所有的群组信息。ConsensusEngineBase的m_sealerList 是在账本创建sealer的时候被初始化的，会根据groupId从配置文件中读取，它只保存当前节点所在group的节点列表信息。后面群组关系发生变化时，这两个变量会被更新。</p><h2 id="3-2-群组信息的读取和动态更新"><a href="#3-2-群组信息的读取和动态更新" class="headerlink" title="3.2 群组信息的读取和动态更新"></a>3.2 群组信息的读取和动态更新</h2><p>获取节点列表信息有两种方式</p><ul><li>ConsensusEngineBase::sealerList()  直接返回 m_sealerList，这种方式是sealer需要获取当前节点所在组的节点列表时使用</li><li>BlockChainImp::sealerList()   从账本白名单中查询节点列表，保存在 P2PService 的 m_groupID2NodeList 中，并更新 ConsensusEngineBase.m_sealerList，这种方式会在需要发送消息时调用 P2PService 时使用；</li></ul><h3 id="3-2-1-获取群组信息的时机"><a href="#3-2-1-获取群组信息的时机" class="headerlink" title="3.2.1 获取群组信息的时机"></a>3.2.1 获取群组信息的时机</h3><p>对于第一种方法，在sealer可以直接调用，第二种方法是在消息广播时触发的，广播消息的时候需要获取节点列表，才知道消息要发往何处：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">PBFTEngine::broadcastMsg</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">const</span>&amp; packetType, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; key,</span></span></span><br><span class="line"><span class="function"><span class="params">    bytesConstRef data, <span class="built_in">std</span>::<span class="built_in">unordered_set</span>&lt;h512&gt; <span class="keyword">const</span>&amp; filter, <span class="keyword">unsigned</span> <span class="keyword">const</span>&amp; ttl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//从p2pservice获取session</span></span><br><span class="line">    <span class="keyword">auto</span> sessions = m_service-&gt;sessionInfosByProtocolID(m_protocolId);</span><br><span class="line">    m_connectedNode = sessions.<span class="built_in">size</span>();</span><br><span class="line">    NodeIDs nodeIdList;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> session : sessions)</span><br><span class="line">    &#123;</span><br><span class="line">        ...</span><br><span class="line">        nodeIdList.push_back(session.nodeID());</span><br><span class="line">        broadcastMark(session.nodeID(), packetType, key);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/// send messages according to node id</span></span><br><span class="line">    m_service-&gt;asyncMulticastMessageByNodeIDList(</span><br><span class="line">        nodeIdList, transDataToMessage(data, packetType, ttl));</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">shared_ptr</span>&lt;dev::p2p::P2PInterface&gt; m_service;</span><br></pre></td></tr></table></figure><br>这里根据 m_protocolId 从 p2pservice 中获取 session，session 里面就保存了nodeID。前面已经说过，m_protocolId 是根据 groupId 生成的，因此 p2pservice 就可以根据 m_protocolId 从Ledge中读取所在group的节点列表。</p><h3 id="3-2-2-ConsensusEngineBase-sealerList"><a href="#3-2-2-ConsensusEngineBase-sealerList" class="headerlink" title="3.2.2 ConsensusEngineBase::sealerList()"></a>3.2.2 ConsensusEngineBase::sealerList()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConsensusEngineBase.h</span></span><br><span class="line"><span class="function">dev::h512s <span class="title">sealerList</span><span class="params">()</span> <span class="keyword">const</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="function">ReadGuard <span class="title">l</span><span class="params">(m_sealerListMutex)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> m_sealerList;</span><br><span class="line">    &#125;</span><br><span class="line"> <span class="comment">/// append sealer</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">appendSealer</span><span class="params">(h512 <span class="keyword">const</span>&amp; _sealer)</span> <span class="keyword">override</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">WriteGuard <span class="title">l</span><span class="params">(m_sealerListMutex)</span></span>;</span><br><span class="line">            m_sealerList.push_back(_sealer);</span><br><span class="line">        &#125;</span><br><span class="line">        resetConfig();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>在sealer中需要读取节点列表时会调用这个方法，直接返回 m_sealerList，但它并不负责对m_sealerList的更新维护。这里的 appendSealer() 方法没有被任何地方调用，貌似是用不着的？</p><h3 id="3-2-3-BlockChainImp-sealerList"><a href="#3-2-3-BlockChainImp-sealerList" class="headerlink" title="3.2.3 BlockChainImp::sealerList()"></a>3.2.3 BlockChainImp::sealerList()</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dev::h512s <span class="title">BlockChainImp::sealerList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int64_t</span> blockNumber = number();</span><br><span class="line">    <span class="function">UpgradableGuard <span class="title">l</span><span class="params">(m_nodeListMutex)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (m_cacheNumBySealer == blockNumber)</span><br><span class="line">    &#123;</span><br><span class="line">        BLOCKCHAIN_LOG(TRACE) &lt;&lt; LOG_DESC(<span class="string">"[#sealerList]Get sealer list by cache"</span>)</span><br><span class="line">                              &lt;&lt; LOG_KV(<span class="string">"size"</span>, m_sealerList.<span class="built_in">size</span>());</span><br><span class="line">        <span class="keyword">return</span> m_sealerList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取最新的节点列表</span></span><br><span class="line">    dev::h512s <span class="built_in">list</span> = getNodeListByType(blockNumber, NODE_TYPE_SEALER);</span><br><span class="line">    <span class="function">UpgradeGuard <span class="title">ul</span><span class="params">(l)</span></span>;</span><br><span class="line">    m_cacheNumBySealer = blockNumber;</span><br><span class="line">    m_sealerList = <span class="built_in">list</span>;　　　<span class="comment">//更新 m_sealerList</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每次调用 BlockChainImp::sealerList()  都会调用 getNodeListByType 方法读取最新的sealer列表，并更新m_sealerList，使得在ConsensusEngineBase中调用sealerList返回的是最新的m_sealerList。</p><h3 id="3-2-4-getNodeListByType"><a href="#3-2-4-getNodeListByType" class="headerlink" title="3.2.4 getNodeListByType()"></a>3.2.4 getNodeListByType()</h3><p>getNodeListByType() 是从账本中读取节点列表:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">dev::h512s <span class="title">BlockChainImp::getNodeListByType</span><span class="params">(<span class="keyword">int64_t</span> blockNumber, <span class="built_in">std</span>::<span class="built_in">string</span> <span class="keyword">const</span>&amp; type)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    dev::h512s <span class="built_in">list</span>;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//获取共识模块的缓存</span></span><br><span class="line">        Table::Ptr tb = getMemoryTableFactory()-&gt;openTable(storage::SYS_CONSENSUS);</span><br><span class="line">        <span class="keyword">if</span> (!tb)</span><br><span class="line">        &#123;</span><br><span class="line">            BLOCKCHAIN_LOG(ERROR) &lt;&lt; LOG_DESC(<span class="string">"[#getNodeListByType]Open table error"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取节点列表</span></span><br><span class="line">        <span class="keyword">auto</span> nodes = tb-&gt;select(PRI_KEY, tb-&gt;newCondition());</span><br><span class="line">        <span class="keyword">if</span> (!nodes)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nodes-&gt;<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> node = nodes-&gt;<span class="built_in">get</span>(i);</span><br><span class="line">            <span class="keyword">if</span> (!node)</span><br><span class="line">                <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((node-&gt;getField(NODE_TYPE) == type) &amp;&amp;</span><br><span class="line">                (boost::lexical_cast&lt;<span class="keyword">int</span>&gt;(node-&gt;getField(NODE_KEY_ENABLENUM)) &lt;= blockNumber))</span><br><span class="line">            &#123;</span><br><span class="line">                h512 nodeID = h512(node-&gt;getField(NODE_KEY_NODEID));</span><br><span class="line">                <span class="built_in">list</span>.push_back(nodeID);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">catch</span> (<span class="built_in">std</span>::exception&amp; e)</span><br><span class="line">    &#123;</span><br><span class="line">        BLOCKCHAIN_LOG(ERROR) &lt;&lt; LOG_DESC(<span class="string">"[#getNodeListByType]Failed"</span>)</span><br><span class="line">                              &lt;&lt; LOG_KV(<span class="string">"EINFO"</span>, boost::diagnostic_information(e));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">stringstream</span> s;</span><br><span class="line">    s &lt;&lt; <span class="string">"[#getNodeListByType] "</span> &lt;&lt; type &lt;&lt; <span class="string">":"</span>;</span><br><span class="line">    <span class="keyword">for</span> (dev::h512 node : <span class="built_in">list</span>)</span><br><span class="line">        s &lt;&lt; toJS(node) &lt;&lt; <span class="string">","</span>;</span><br><span class="line">    BLOCKCHAIN_LOG(TRACE) &lt;&lt; LOG_DESC(s.str());</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>从 SYS_CONSENSUS 的 MemoryTable (账本白名单)中读取的</p><h3 id="3-2-5-updateConsensusNodeList"><a href="#3-2-5-updateConsensusNodeList" class="headerlink" title="3.2.5 updateConsensusNodeList()"></a>3.2.5 updateConsensusNodeList()</h3><p>除了在获取节点列表的时候会触发更新的操作，在ConsensusEngineBase中有直接更新节点列表的方法：<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConsensusEngineBase.cpp</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ConsensusEngineBase::updateConsensusNodeList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">try</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">stringstream</span> s2;</span><br><span class="line">        s2 &lt;&lt; <span class="string">"[updateConsensusNodeList] Sealers:"</span>;</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="function">WriteGuard <span class="title">l</span><span class="params">(m_sealerListMutex)</span></span>;</span><br><span class="line">            <span class="comment">//获取sealer节点列表</span></span><br><span class="line">            m_sealerList = m_blockChain-&gt;sealerList();</span><br><span class="line">            ...</span><br><span class="line">        &#125;</span><br><span class="line">        s2 &lt;&lt; <span class="string">"Observers:"</span>;</span><br><span class="line">        <span class="comment">//获取observer节点列表</span></span><br><span class="line">        dev::h512s observerList = m_blockChain-&gt;observerList();</span><br><span class="line">        ...</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-3-动态群组实现"><a href="#3-3-动态群组实现" class="headerlink" title="3.3 动态群组实现"></a>3.3 动态群组实现</h2><p>通过控制台可以实现群组关系的变更</p><h3 id="3-3-1-控制台"><a href="#3-3-1-控制台" class="headerlink" title="3.3.1 控制台"></a>3.3.1 控制台</h3><p>通过控制台可以让节点加入某group<br>新节点加入群组前，需要确保：</p><ul><li>新加入NodeID存在</li><li>群组内节点正常共识：正常共识的节点会输出+++日志<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 2. 将node2加入到共识节点</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> addSealer后面的参数是上步获取的node ID</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> [group:2]&gt; addSealer 6dc585319e4cf7d73ede73819c6966ea4bed74aadbbcba1bbb777132f63d355965c3502bed7a04425d99cdcfb7694a1c133079e6d9b0ab080e3b874882b95ff4</span></span><br><span class="line">&#123;</span><br><span class="line">    "code":0,</span><br><span class="line">    "msg":"success"</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><p>查看控制台的源码：<br><a href="https://github.com/FISCO-BCOS/console/blob/master/src/main/java/console/ConsoleClient.java" target="_blank" rel="noopener">https://github.com/FISCO-BCOS/console/blob/master/src/main/java/console/ConsoleClient.java</a><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"addSealer"</span>:</span><br><span class="line">    precompiledFace.addSealer(params);</span><br><span class="line">    <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">precompiledFace.addSealer：</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addSealer</span><span class="params">(String[] params)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        String nodeId = params[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="string">"-h"</span>.equals(nodeId) || <span class="string">"--help"</span>.equals(nodeId)) &#123;</span><br><span class="line">            HelpInfo.addSealerHelp();</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (nodeId.length() != <span class="number">128</span>) &#123;</span><br><span class="line">            ConsoleUtils.printJson(</span><br><span class="line">                    PrecompiledCommon.transferToJson(PrecompiledCommon.InvalidNodeId));</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ConsensusService consensusService = <span class="keyword">new</span> ConsensusService(web3j, credentials);</span><br><span class="line">            String result;</span><br><span class="line">            result = consensusService.addSealer(nodeId);</span><br><span class="line">            ConsoleUtils.printJson(result);</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println();</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>调用了consensusService.addSealer方法，ConsensusService位于 web3sdk 中，控制台通过web3sdk 向链上发送了一个增加节点的请求。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.fisco.bcos.web3j.precompile.consensus.ConsensusService;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-2-Web3SDK"><a href="#3-3-2-Web3SDK" class="headerlink" title="3.3.2 Web3SDK"></a>3.3.2 Web3SDK</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConsensusService.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">addSealer</span><span class="params">(String nodeID)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!isValidNodeID(nodeID)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PrecompiledCommon.transferToJson(PrecompiledCommon.P2pNetwork);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//获取原有节点列表</span></span><br><span class="line">        List&lt;String&gt; sealerList = web3j.getSealerList().send().getResult();</span><br><span class="line">        <span class="comment">//如果已经存在该节点</span></span><br><span class="line">        <span class="keyword">if</span> (sealerList.contains(nodeID)) &#123;</span><br><span class="line">            <span class="keyword">return</span> PrecompiledCommon.transferToJson(PrecompiledCommon.SealerList);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//不存在则添加</span></span><br><span class="line">        TransactionReceipt receipt = consensus.addSealer(nodeID).send();</span><br><span class="line">        <span class="keyword">return</span> PrecompiledCommon.handleTransactionReceipt(receipt, web3j);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>这里通过调用consensus的addSealer方法。<br>consensus是一个合约，它的函数体是空的，说明它是预编译合约的接口合约，它的具体逻辑在源码的Precompiled模块中。<br>接口合约：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">pragma solidity ^0.4.2;</span><br><span class="line"></span><br><span class="line">contract Consensus &#123;</span><br><span class="line">    function addSealer(string nodeID) public returns(int);</span><br><span class="line">    function addObserver(string nodeID) public returns(int);</span><br><span class="line">    function remove(string nodeID) public returns(int);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-3-源码预编译模块"><a href="#3-3-3-源码预编译模块" class="headerlink" title="3.3.3 源码预编译模块"></a>3.3.3 源码预编译模块</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">libprecompiled/ConsensusPrecompiled.cpp</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> CSS_METHOD_ADD_SEALER = <span class="string">"addSealer(string)"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> CSS_METHOD_ADD_SER = <span class="string">"addObserver(string)"</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">char</span>* <span class="keyword">const</span> CSS_METHOD_REMOVE = <span class="string">"remove(string)"</span>;</span><br><span class="line">ConsensusPrecompiled::ConsensusPrecompiled()</span><br><span class="line">&#123;</span><br><span class="line">    name2Selector[CSS_METHOD_ADD_SEALER] = getFuncSelector(CSS_METHOD_ADD_SEALER);</span><br><span class="line">    name2Selector[CSS_METHOD_ADD_SER] = getFuncSelector(CSS_METHOD_ADD_SER);</span><br><span class="line">    name2Selector[CSS_METHOD_REMOVE] = getFuncSelector(CSS_METHOD_REMOVE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>call方法实现了合约方法的逻辑:<br><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">bytes <span class="title">ConsensusPrecompiled::call</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ExecutiveContext::Ptr context, bytesConstRef param, Address <span class="keyword">const</span>&amp; origin)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    PRECOMPILED_LOG(TRACE) &lt;&lt; LOG_BADGE(<span class="string">"ConsensusPrecompiled"</span>) &lt;&lt; LOG_DESC(<span class="string">"call"</span>)</span><br><span class="line">                           &lt;&lt; LOG_KV(<span class="string">"param"</span>, toHex(param));</span><br><span class="line"></span><br><span class="line">    <span class="comment">// parse function name</span></span><br><span class="line">    <span class="keyword">uint32_t</span> func = getParamFunc(param);</span><br><span class="line">    bytesConstRef data = getParamData(param);</span><br><span class="line"></span><br><span class="line">    dev::eth::ContractABI abi;</span><br><span class="line">    bytes out;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    showConsensusTable(context);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (func == name2Selector[CSS_METHOD_ADD_SEALER])  <span class="comment">//addSealer方法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// addSealer(string)</span></span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> nodeID;</span><br><span class="line">        abi.abiOut(data, nodeID);</span><br><span class="line">        <span class="comment">// Uniform lowercase nodeID</span></span><br><span class="line">        boost::to_lower(nodeID);</span><br><span class="line"></span><br><span class="line">        PRECOMPILED_LOG(DEBUG) &lt;&lt; LOG_BADGE(<span class="string">"ConsensusPrecompiled"</span>) &lt;&lt; LOG_DESC(<span class="string">"addSealer func"</span>)</span><br><span class="line">                               &lt;&lt; LOG_KV(<span class="string">"nodeID"</span>, nodeID);</span><br><span class="line">        <span class="keyword">if</span> (nodeID.<span class="built_in">size</span>() != <span class="number">128u</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            PRECOMPILED_LOG(ERROR) &lt;&lt; LOG_BADGE(<span class="string">"ConsensusPrecompiled"</span>)</span><br><span class="line">                                   &lt;&lt; LOG_DESC(<span class="string">"nodeID length error"</span>) &lt;&lt; LOG_KV(<span class="string">"nodeID"</span>, nodeID);</span><br><span class="line">            result = CODE_INVALID_NODEID;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            storage::Table::Ptr table = openTable(context, SYS_CONSENSUS);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//创建一个新condition对象，是一个查询条件，条件为nodeID</span></span><br><span class="line">            <span class="keyword">auto</span> condition = table-&gt;newCondition();</span><br><span class="line">            condition-&gt;EQ(NODE_KEY_NODEID, nodeID);</span><br><span class="line">            <span class="comment">//根据condition从table查找是否已经存在该node</span></span><br><span class="line">            <span class="keyword">auto</span> entries = table-&gt;select(PRI_KEY, condition);</span><br><span class="line">            <span class="keyword">auto</span> entry = table-&gt;newEntry();</span><br><span class="line">            entry-&gt;setField(NODE_TYPE, NODE_TYPE_SEALER);</span><br><span class="line">            entry-&gt;setField(PRI_COLUMN, PRI_KEY);</span><br><span class="line">            entry-&gt;setField(NODE_KEY_ENABLENUM,</span><br><span class="line">                boost::lexical_cast&lt;<span class="built_in">std</span>::<span class="built_in">string</span>&gt;(context-&gt;blockInfo().number + <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (entries.<span class="built_in">get</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (entries-&gt;<span class="built_in">size</span>() == <span class="number">0u</span>)<span class="comment">//为0,说明table里面不存在该nodeID</span></span><br><span class="line">                &#123;</span><br><span class="line">                    entry-&gt;setField(NODE_KEY_NODEID, nodeID);</span><br><span class="line">                    <span class="comment">//插入该nodeID</span></span><br><span class="line">                    count = table-&gt;insert(PRI_KEY, entry, <span class="built_in">std</span>::make_shared&lt;AccessOptions&gt;(origin));</span><br><span class="line">                    <span class="keyword">if</span> (count == storage::CODE_NO_AUTHORIZED)</span><br><span class="line">                    &#123;</span><br><span class="line">                        PRECOMPILED_LOG(DEBUG)</span><br><span class="line">                            &lt;&lt; LOG_BADGE(<span class="string">"ConsensusPrecompiled"</span>) &lt;&lt; LOG_DESC(<span class="string">"permission denied"</span>);</span><br><span class="line">                        result = storage::CODE_NO_AUTHORIZED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        PRECOMPILED_LOG(DEBUG) &lt;&lt; LOG_BADGE(<span class="string">"ConsensusPrecompiled"</span>)</span><br><span class="line">                                               &lt;&lt; LOG_DESC(<span class="string">"addSealer successfully"</span>);</span><br><span class="line">                        result = count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>　　<span class="comment">//entries不为０，说明table已经存在该node</span></span><br><span class="line">                &#123;</span><br><span class="line">                    count = table-&gt;update(</span><br><span class="line">                        PRI_KEY, entry, condition, <span class="built_in">std</span>::make_shared&lt;AccessOptions&gt;(origin));</span><br><span class="line">                    <span class="keyword">if</span> (count == storage::CODE_NO_AUTHORIZED)</span><br><span class="line">                    &#123;</span><br><span class="line">                        PRECOMPILED_LOG(DEBUG)</span><br><span class="line">                            &lt;&lt; LOG_BADGE(<span class="string">"ConsensusPrecompiled"</span>) &lt;&lt; LOG_DESC(<span class="string">"permission denied"</span>);</span><br><span class="line">                        result = storage::CODE_NO_AUTHORIZED;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        PRECOMPILED_LOG(DEBUG) &lt;&lt; LOG_BADGE(<span class="string">"ConsensusPrecompiled"</span>)</span><br><span class="line">                                               &lt;&lt; LOG_DESC(<span class="string">"addSealer successfully"</span>);</span><br><span class="line">                        result = count;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span></span><br><span class="line">    .....</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>addSealer 的基本流程为：</p><ol><li>打开SYS_CONSENSUS的table(账本节点白名单)</li><li>使用nodeId创建查询条件 condition</li><li>使用 condition 从 table 里面查找<br>3.1 查找得到，说明已经存在该nodeId<br>3.2 找不到，则插入 MemotyTable.insert()<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">storage::<span class="function">Table::Ptr <span class="title">Precompiled::openTable</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">    ExecutiveContext::Ptr context, <span class="keyword">const</span> <span class="built_in">std</span>::<span class="built_in">string</span>&amp; tableName)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    TableFactoryPrecompiled::Ptr tableFactoryPrecompiled =</span><br><span class="line">        <span class="built_in">std</span>::dynamic_pointer_cast&lt;TableFactoryPrecompiled&gt;(</span><br><span class="line">            context-&gt;getPrecompiled(Address(<span class="number">0x1001</span>)));</span><br><span class="line">    <span class="keyword">return</span> tableFactoryPrecompiled-&gt;getMemoryTableFactory()-&gt;openTable(tableName);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><h3 id="3-3-4-总结"><a href="#3-3-4-总结" class="headerlink" title="3.3.4 总结"></a>3.3.4 总结</h3><p>新增节点到群组的流程：</p><ol><li>通过 console 调用 addSealer 方法</li><li>addSealer 方法调用预编译合约 ConsensusPrecompiled 的 addSealer 方法</li><li>addSealer 方法将 nodeId 插入到名字为 SYS_CONSENSUS 的 MemotyTable(账本节点白名单) 中</li></ol><p>使用发送交易共识的方式修改账本白名单，保证了账本白名单群组内的一致性。</p><h2 id="3-4-动态群组实现总结"><a href="#3-4-动态群组实现总结" class="headerlink" title="3.4 动态群组实现总结"></a>3.4 动态群组实现总结</h2><p>每个群组均持有一个账本白名单，用于维护该群组的节点列表。为了保证账本白名单群组内一致性，仅可通过发交易共识的方式修改账本白名单，修改账本白名单的合约是预编译合约。在运行过程中，需要获取群组信息的时候是从账本白名单中读取的，保证能够实时得到最新的节点列表。</p>]]></content>
      
      
      <categories>
          
          <category> blockchain </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blockchain </tag>
            
            <tag> bcos </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>本站目录</title>
      <link href="/catalogue/catalogue/"/>
      <url>/catalogue/catalogue/</url>
      
        <content type="html"><![CDATA[<h1 id="本站目录"><a href="#本站目录" class="headerlink" title="本站目录"></a>本站目录</h1><p>&emsp;本站文章汇总目录。</p><hr><h2 id="Blockchain"><a href="#Blockchain" class="headerlink" title="Blockchain"></a>Blockchain</h2><ul><li><a href="http://zhoujiapeng.top/blockchain/bcos-group-architecture/">《BCOS 动态群组架构》</a></li><li><a href="http://zhoujiapeng.top/blockchain/bcos-group-architecture-code/">《BCOS 动态群组架构源码分析》</a></li><li>《Algorand 共识算法总结》</li></ul><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><ul><li><a href="http://zhoujiapeng.top/java/java-risk-of-autoboxing/">《Java 自动装箱的陷阱》</a></li><li><a href="http://zhoujiapeng.top/java/java-memoryModel/">《Java 内存模型》</a></li><li><a href="http://zhoujiapeng.top/java/java-special-variable">《volatile 的特殊规则和 long&amp;&amp;double 的非原子协定》</a></li><li><a href="http://zhoujiapeng.top/java/java-memory-area">《深入理解Java虚拟机 之 Java内存区域》</a></li><li><a href="http://zhoujiapeng.top/java/java-oom-test">《深入理解Java虚拟机 之 OutOfMemoryError 异常实战》</a></li><li><a href="http://zhoujiapeng.top/java/java-jvm-GC-alogrithm">《深入理解Java虚拟机 之 垃圾收集算法》</a></li><li><a href="http://zhoujiapeng.top/java/java-jvm-memory-allocate-and-collection-policy">《深入理解Java虚拟机 之 内存分配与回收策略》</a></li><li><a href="http://zhoujiapeng.top/java/java-jvm-class-file-struct">《深入理解Java虚拟机 之 类文件结构》</a></li><li><a href="http://zhoujiapeng.top/java/java-jvm-bytecode">《深入理解Java虚拟机 之 字节码指令》</a></li><li><a href="http://zhoujiapeng.top/java/java-jvm-classLoader">《深入理解Java虚拟机 之 虚拟机类加载机制》</a></li></ul><blockquote><p>参考资料<br>《深入理解Java虚拟机》</p></blockquote><hr><h2 id="Java-1-8"><a href="#Java-1-8" class="headerlink" title="Java(1.8)"></a>Java(1.8)</h2><p>Java 基础</p><ul><li><a href="http://zhoujiapeng.top/java/java-HashMap">《深入理解 HashMap(一)》</a></li><li><a href="http://zhoujiapeng.top/java/java-HashMap2">《深入理解 HashMap(二)》</a></li><li><a href="http://zhoujiapeng.top/java/java-annotation">《Java Annotation》</a></li></ul><p>并发基础</p><ul><li><a href="http://zhoujiapeng.top/java/java-thread-base">《Java 并发编程 之 线程基础》</a></li><li><a href="http://zhoujiapeng.top/java/java-ThreadLocal">《Java 并发编程 之 ThreadLocal》</a></li><li><a href="http://zhoujiapeng.top/java/java-unsafe">《Java 并发编程 之 Unsafe 类解析》</a></li><li><a href="http://zhoujiapeng.top/java/java-aba-question">《Java 并发编程 之 ABA 问题》</a></li><li><a href="http://zhoujiapeng.top/java/java-threadLocalRandom">《Java 并发编程 之 ThreadLocalRandom》</a></li><li><a href="http://zhoujiapeng.top/java/java-atomicOperationClass">《Java 并发编程 之 原子操作类》</a></li></ul><p>并发容器</p><ul><li><a href="http://zhoujiapeng.top/java/java-blockingQueue">《Java 并发容器 之 BlockingQueue》</a></li><li><a href="http://zhoujiapeng.top/java/java-ConcurrentLinkedQueue">《Java 并发容器 之 ConcurrentLinkedQueue》</a></li><li><a href="http://zhoujiapeng.top/java/java-java-ConcurrentHashMap">《Java 并发容器 之 ConcurrentHashMap(一)》</a></li><li><a href="http://zhoujiapeng.top/java/java-java-ConcurrentHashMap2">《Java 并发容器 之 ConcurrentHashMap(二)》</a></li><li><a href="http://zhoujiapeng.top/java/java-AbstractQueuedSynchronizer">《Java 并发编程 之 AbstractQueuedSynchronizer》</a></li></ul><p>线程池</p><ul><li><a href="http://zhoujiapeng.top/java/java-threadPoolExecutor-overview/">《线程池 之 ThreadPoolExecutor 概述》</a></li><li><a href="http://zhoujiapeng.top/java/java-threadPoolExecutor-use/">《线程池 之 ThreadPoolExecutor 使用》</a></li><li><a href="http://zhoujiapeng.top/java/java-threadPoolExecutor-statusControl/">《线程池 之 ThreadPoolExecutor 状态控制》</a></li><li><a href="http://zhoujiapeng.top/java/java-threadPoolExecutor-executorAnalyze/">《线程池 之 ThreadPoolExecutor 执行原理》</a></li><li><a href="http://zhoujiapeng.top/java/java-scheduledthreadPoolExecutor/">《线程池 之 ScheduledThreadPoolExecutor 概述》</a></li><li>《优雅地关闭线程池》</li></ul><p>线程同步与通信</p><ul><li><a href="http://zhoujiapeng.top/java/java-lock-summary">《Java 并发编程 之 锁的概述》</a></li><li><a href="http://zhoujiapeng.top/java/java-ReentrantReadWriteLock">《Java 并发编程 之 ReentrantReadWriteLock》</a></li><li><a href="http://zhoujiapeng.top/java/java-synchronized">《Java 并发编程 之 synchronized 的实现原理》</a></li><li><a href="http://zhoujiapeng.top/java/java-CountDownLatch">《Java 线程同步器 之 CountDownLatch 原理剖析》</a></li><li><a href="http://zhoujiapeng.top/java/java-CyclicBarrier">《Java 线程同步器 之 CyclicBarrier 原理剖析》</a></li><li><a href="http://zhoujiapeng.top/java/java-Semaphore">《Java 线程同步器 之 Semaphore 原理剖析》</a></li></ul><p>收藏</p><ul><li><a href="https://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html" target="_blank" rel="noopener">《非阻塞算法在并发容器中的实现》</a></li></ul><blockquote><p>参考资料<br>《Java并发编程之美》<br><a href="https://www.jianshu.com/u/bc1552d8e95d" target="_blank" rel="noopener">https://www.jianshu.com/u/bc1552d8e95d</a><br><a href="https://www.cnblogs.com/zaizhoumo/" target="_blank" rel="noopener">https://www.cnblogs.com/zaizhoumo/</a><br><a href="https://segmentfault.com/a/1190000016058789" target="_blank" rel="noopener">https://segmentfault.com/a/1190000016058789</a></p></blockquote><hr><h2 id="Mybatis"><a href="#Mybatis" class="headerlink" title="Mybatis"></a>Mybatis</h2><ul><li><a href="http://zhoujiapeng.top/java/mybatis-cache/">《Mybatis 缓存详解》</a></li></ul><blockquote><p>参考资料<br>《MyBatis从入门到精通(刘增辉)》</p></blockquote><hr><h2 id="面试-博客收藏"><a href="#面试-博客收藏" class="headerlink" title="面试+博客收藏"></a>面试+博客收藏</h2><ul><li><a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></li><li><a href="https://www.cnblogs.com/aspirant/category/548388.html" target="_blank" rel="noopener">https://www.cnblogs.com/aspirant/category/548388.html</a></li><li><a href="https://blog.csdn.net/u013256816" target="_blank" rel="noopener">https://blog.csdn.net/u013256816</a></li></ul><hr><h2 id="scala"><a href="#scala" class="headerlink" title="scala"></a>scala</h2><ul><li><a href="http://zhoujiapeng.top/scala/scala-tailrec/">《Scala 尾递归优化》</a></li><li><a href="http://zhoujiapeng.top/scala/scala-scala-operation/">《Scala 强大的集合操作》</a></li></ul><blockquote><p>参考资料<br>《Scala 编程实战》<br>《快学 Scala》</p></blockquote><hr><h2 id="Spark"><a href="#Spark" class="headerlink" title="Spark"></a>Spark</h2><blockquote><p>Spark版本：2.4.0</p></blockquote><p>API</p><ul><li><a href="http://spark.apache.org/docs/2.4.0/api/scala/index.html#org.apache.spark.package" target="_blank" rel="noopener">Spark ２.4.0 ScalaDoc</a></li><li><a href="http://homepage.cs.latrobe.edu.au/zhe/ZhenHeSparkRDDAPIExamples.html#glom" target="_blank" rel="noopener">Spark RDD API </a></li></ul><p>Configuration</p><ul><li><a href="http://spark.apache.org/docs/2.4.0/configuration.html#Dynamically-Loading-Spark-Properties" target="_blank" rel="noopener">Spark Configuration</a></li></ul><p>Notes</p><ul><li><a href="http://zhoujiapeng.top/Spark/spark-overview/">《Spark集群架构》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-application/">《Spark源码阅读 之 Spark Application 的提交》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-job/">《Spark源码阅读 之 Spark 作业和调度》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-fault-tolerant/">《Spark源码阅读 之 容错机制》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-storage/">《Spark源码阅读 之 Storage储存模块》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-share-variable/">《Spark源码阅读 之 共享变量》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-tuning/">《Spark 性能调优》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-partitioner/">《Spark源码阅读 之 Partitioner 详解》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-dependency/">《Spark源码阅读 之 Dependency 详解》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-dagscheduler/">《Spark源码阅读 之 DAGScheduler 详解》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-task/">《Spark源码阅读 之 Task 详解》</a></li><li><a href="http://zhoujiapeng.top/Spark/spark-deploy-mode/">《Spark源码阅读 之 部署模式》</a></li><li>《Spark 任务调度 之 数据本地性》</li><li>《Spark Shuffle 机制解析》</li></ul><blockquote><p>参考资料<br><a href="http://spark.apache.org/docs/2.4.0/" target="_blank" rel="noopener">《官方文档》</a><br>《Spark核心源码分析与开发实战》<br>《Spark内核设计的艺术》</p></blockquote><hr><h2 id="密码学"><a href="#密码学" class="headerlink" title="密码学"></a>密码学</h2><ul><li><a href="http://zhoujiapeng.top/cryptography/cryptography">《密码学基础 - 群、环、域》</a></li></ul><hr><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><ul><li><a href="https://www.orchome.com/kafka/index" target="_blank" rel="noopener">https://www.orchome.com/kafka/index</a></li><li><a href="http://kafka.apachecn.org/uses.html" target="_blank" rel="noopener">http://kafka.apachecn.org/uses.html</a></li></ul><hr><h2 id="其它"><a href="#其它" class="headerlink" title="其它"></a>其它</h2><ul><li><a href="http://zhoujiapeng.top/markdown/markdown-table">《markdown 中表格单元格合并的问题》</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> catalogue </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis 缓存详解</title>
      <link href="/java/mybatis-cache/"/>
      <url>/java/mybatis-cache/</url>
      
        <content type="html"><![CDATA[<h1 id="Mybatis-缓存"><a href="#Mybatis-缓存" class="headerlink" title="Mybatis 缓存"></a>Mybatis 缓存</h1><p>&emsp;使用缓存可以使应用更快地获取数据，避免频繁的数据库交互，尤其是在查询越多、缓存命中率越高的情况下，使用缓存的作用就越明显。MyBatis 作为持久化框架， 提供了非常强大的查询缓存特性，可以非常方便地配置和定制使用。</p><h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>&emsp;Mybatis对缓存提供支持，但是在没有配置的默认情况下，它只开启一级缓存，一级缓存只是相对于同一个SqlSession而言。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/mybatis/mybatis-cache-L1.png?raw=true" alt="L1"></p><p>&emsp;每个SqlSession中持有了Executor，每个Executor中有一个LocalCache。当用户发起查询时，MyBatis根据当前执行的语句生成MappedStatement，在Local Cache进行查询，如果缓存命中的话，直接返回结果给用户，如果缓存没有命中的话，查询数据库，结果写入Local Cache，最后返回结果给用户。使用SelSession第一次查询后，MyBatis会将其放在缓存中，以后再查询的时候，如果没有声明需要刷新，并且缓存没有超时的情况下，SqlSession都会取出当前缓存的数据，而不会再次发送SQL到数据库。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/mybatis/Sqlsession-cache-class.jpg?raw=true" alt="Sqlsession-cache-class"></p><p>&emsp;有几个问题需要注意一下：</p><ol><li>一级缓存的生命周期有多长？</li></ol><ul><li>a. 一级缓存存在于 SqlSession 的生命周期中，MyBatis在开启一个数据库会话时，会创建一个新的SqlSession对象，SqlSession对象中会有一个新的Executor对象。Executor对象中持有一个新的PerpetualCache对象；当会话结束时，SqlSession对象及其内部的Executor对象还有PerpetualCache对象也一并释放掉。</li><li>b. 如果SqlSession调用了close()方法，会释放掉一级缓存PerpetualCache对象，一级缓存将不可用。</li><li>c. 如果SqlSession调用了clearCache()，会清空PerpetualCache对象中的数据，但是该对象仍可使用。</li><li>d. SqlSession中执行了任何一个update操作(update()、delete()、insert()) ，都会清空PerpetualCache对象的数据，但是该对象可以继续使用。</li></ul><ol><li>怎么判断某两次查询是完全相同的查询？<br>mybatis认为，对于两次查询，如果以下条件都完全一样，那么就认为它们是完全相同的两次查询。</li></ol><ul><li>a. 传入的statementId</li><li>b. 查询时要求的结果集中的结果范围</li><li>c. 这次查询所产生的最终要传递给JDBC java.sql.Preparedstatement的Sql语句字符串（boundSql.getSql() ）</li><li>d. 传递给java.sql.Statement要设置的参数值</li></ul><p>&emsp;MyBatis 会把执行的方法和参数通过算法生成缓存的键值，将键值和查询结果存入一个Map对象中。如果同一个SqlSession 中执行的方法和参数完全一致，那么通过算法会生成相同的键值，当Map 缓存对象中己经存在该键值时，则会返回缓存中的对象。</p><p>&emsp;我们看一下一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BaseMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> SqlSessionFactory sqlSessionFactory;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@BeforeClass</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            Reader reader = Resources.getResourceAsReader(<span class="string">"mybatis-config.xml"</span>);</span><br><span class="line">            sqlSessionFactory = <span class="keyword">new</span> SqlSessionFactoryBuilder().build(reader);</span><br><span class="line">            reader.close();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (IOException ex)&#123;</span><br><span class="line">            ex.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> SqlSession <span class="title">getSqlSession</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> sqlSessionFactory.openSession();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CacheTest</span> <span class="keyword">extends</span> <span class="title">BaseMapperTest</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testL1Cache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = getSqlSession();</span><br><span class="line">        SysUser user1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            UserMapper userMapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            user1 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">            System.out.println(user1);</span><br><span class="line">            <span class="comment">//对当前获取的对象重新赋值</span></span><br><span class="line">            user1.setUserName(<span class="string">"New Name"</span>);</span><br><span class="line">            <span class="comment">//再次获取相同id的用户</span></span><br><span class="line">            SysUser user2 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">            Assert.assertEquals(<span class="string">"New Name"</span>,user2.getUserName());</span><br><span class="line">            <span class="comment">//user1和user2是同一个实例</span></span><br><span class="line">            System.out.println(user1==user2);</span><br><span class="line">            Assert.assertEquals(user1,user2);</span><br><span class="line">            System.out.println(user1);</span><br><span class="line">            System.out.println(user2);</span><br><span class="line">            <span class="comment">//对user1的操作等同于对user2的操作</span></span><br><span class="line">            user1.setUserName(<span class="string">"Hello World"</span>);</span><br><span class="line">            Assert.assertEquals(<span class="string">"Hello World"</span>,user2.getUserName());</span><br><span class="line">            <span class="comment">//看日志，两次select，实际上只执行了一个数据库操作</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"开启新的sqlSession"</span>);</span><br><span class="line">        sqlSession = getSqlSession();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            UserMapper userMapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            SysUser user2 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">            Assert.assertEquals(<span class="string">"admin"</span>,user2.getUserName());</span><br><span class="line">            <span class="comment">//跟前一个session的查询结果不是同一个实例</span></span><br><span class="line">            Assert.assertNotEquals(user1,user2);</span><br><span class="line">            <span class="comment">//执行删除操作</span></span><br><span class="line">            userMapper.deleteById(<span class="number">2L</span>);</span><br><span class="line">            SysUser user3 = userMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">            <span class="comment">//不是同个实例</span></span><br><span class="line">            Assert.assertNotEquals(user2,user3);</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;执行结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [main] - Setting autocommit to <span class="keyword">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">3</span>d121db3]</span><br><span class="line">DEBUG [main] - ==&gt;  Preparing: select * from sys_user where id = ?; </span><br><span class="line">DEBUG [main] - ==&gt; Parameters: <span class="number">1</span>(Long)</span><br><span class="line">TRACE [main] - &lt;==    Columns: id, user_name, user_password, user_info, head_img, create_time</span><br><span class="line">TRACE [main] - &lt;==        Row: <span class="number">1</span>, admin, <span class="number">123456</span>, &lt;&lt;BLOB&gt;&gt;, &lt;&lt;BLOB&gt;&gt;, <span class="number">2019</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">37</span>:<span class="number">10</span></span><br><span class="line">DEBUG [main] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">SysUser&#123;id=<span class="number">1</span>, userName=<span class="string">'admin'</span>, userPassword=<span class="string">'123456'</span>, userInfo=<span class="string">'管理员'</span>, headImg=<span class="keyword">null</span>, createTime=<span class="number">2019</span>-<span class="number">10</span>-<span class="number">28</span>&#125;</span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">SysUser&#123;id=<span class="number">1</span>, userName=<span class="string">'New Name'</span>, userPassword=<span class="string">'123456'</span>, userInfo=<span class="string">'管理员'</span>, headImg=<span class="keyword">null</span>, createTime=<span class="number">2019</span>-<span class="number">10</span>-<span class="number">28</span>&#125;</span><br><span class="line">SysUser&#123;id=<span class="number">1</span>, userName=<span class="string">'New Name'</span>, userPassword=<span class="string">'123456'</span>, userInfo=<span class="string">'管理员'</span>, headImg=<span class="keyword">null</span>, createTime=<span class="number">2019</span>-<span class="number">10</span>-<span class="number">28</span>&#125;</span><br><span class="line">DEBUG [main] - Resetting autocommit to <span class="keyword">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">3</span>d121db3]</span><br><span class="line">DEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">3</span>d121db3]</span><br><span class="line">开启新的sqlSession</span><br><span class="line">DEBUG [main] - Opening JDBC Connection</span><br><span class="line">DEBUG [main] - Setting autocommit to <span class="keyword">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">7880</span>cdf3]</span><br><span class="line">DEBUG [main] - ==&gt;  Preparing: select * from sys_user where id = ?; </span><br><span class="line">DEBUG [main] - ==&gt; Parameters: <span class="number">1</span>(Long)</span><br><span class="line">TRACE [main] - &lt;==    Columns: id, user_name, user_password, user_info, head_img, create_time</span><br><span class="line">TRACE [main] - &lt;==        Row: <span class="number">1</span>, admin, <span class="number">123456</span>, &lt;&lt;BLOB&gt;&gt;, &lt;&lt;BLOB&gt;&gt;, <span class="number">2019</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">37</span>:<span class="number">10</span></span><br><span class="line">DEBUG [main] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">DEBUG [main] - ==&gt;  Preparing: delete from sys_user where id = ? </span><br><span class="line">DEBUG [main] - ==&gt; Parameters: <span class="number">2</span>(Long)</span><br><span class="line">DEBUG [main] - &lt;==    Updates: <span class="number">0</span></span><br><span class="line">DEBUG [main] - ==&gt;  Preparing: select * from sys_user where id = ?; </span><br><span class="line">DEBUG [main] - ==&gt; Parameters: <span class="number">1</span>(Long)</span><br><span class="line">TRACE [main] - &lt;==    Columns: id, user_name, user_password, user_info, head_img, create_time</span><br><span class="line">TRACE [main] - &lt;==        Row: <span class="number">1</span>, admin, <span class="number">123456</span>, &lt;&lt;BLOB&gt;&gt;, &lt;&lt;BLOB&gt;&gt;, <span class="number">2019</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">37</span>:<span class="number">10</span></span><br><span class="line">DEBUG [main] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">DEBUG [main] - Rolling back JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">7880</span>cdf3]</span><br><span class="line">DEBUG [main] - Resetting autocommit to <span class="keyword">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">7880</span>cdf3]</span><br><span class="line">DEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">7880</span>cdf3]</span><br></pre></td></tr></table></figure><br>&emsp;可以看到在第一个 sqlSession 里面执行了两次 select 操作，但是实际日志却只有一次数据库查询操作，说明第二次 select 是从缓存中获取的。另外，两次查询操作返回的是同一个实例，对 user1 的操作能够在 user2 上体现出来，同时也证明了 user1 和 user2 是对同一个实例的引用。</p><p>&emsp;在第二个 sqlsession 我们通过 user1 不等于 user2 证明了不同 session 的相同操作返回的是不同的实例。另外，user2 不等于 user3 说明在执行 delete 之后缓存被清除了，user3 得到的是新的实例。</p><p>&emsp;在同个 sqlsession 中反复使用相同参数执行同一个方法时， 总是返回同一个对象，因此就会出现上面测试代码中的情况。在使用 MyBatis 的过程中，要避免在使用如上代码中的 user2 时出现的错误。我们可能以为获取的user2 应该是数据库中的数据，却不知道 userl 的一个重新赋值会影响到 user2 。如果不想让 selectByid 方法使用一级缓存，可以设置 flushCache= “true”，这个属性配置为true 后， 会在查询数据前清空当前的一级缓存，因此该方法每次都会重新从数据库中查询数据，此时的 user2 和userl 就会成为两个不同的实例， 可以避免上面的问题。但是由于这个方法清空了一级缓存， 会影响当前SqlSession 中所有缓存的查询，因此在需要反复查询获取只读数据的情况下，会增加数据库的查询次数，所以要避免这么使用。</p><h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>&emsp;MyBatis的二级缓存是Application级别的缓存，它可以提高对数据库查询的效率，以提高应用的性能。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/mybatis/mybatis-cache-L2.png?raw=true" alt="L2"></p><p>&emsp;在一级缓存中，其最大的共享范围就是一个SqlSession内部，如果多个SqlSession之间需要共享缓存，则需要使用到二级缓存。开启二级缓存后，会使用CachingExecutor装饰Executor，进入一级缓存的查询流程前，先在CachingExecutor进行二级缓存的查询，具体的工作流程如下所示。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/mybatis/mybatis-cache-L2-class.png?raw=true" alt="mybatis-cache-L2-class"></p><p>&emsp;二级缓存开启后，同一个 namespace下的所有操作语句，都影响着同一个Cache，即二级缓存被多个 SqlSession 共享，是一个全局的变量。<br>&emsp;当开启缓存后，数据的查询执行的流程就是 二级缓存 -&gt; 一级缓存 -&gt; 数据库。</p><p>&emsp;首先需要在 mybatis-config.xml 中开启二级缓存<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">configuration</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Config 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-config.dtd"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">configuration</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">settings</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!--这个配置使全局的映射器(二级缓存)启用或禁用缓存--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">setting</span> <span class="attr">name</span>=<span class="string">"cacheEnabled"</span> <span class="attr">value</span>=<span class="string">"true"</span> /&gt;</span></span><br><span class="line">        .....</span><br><span class="line">    <span class="tag">&lt;/<span class="name">settings</span>&gt;</span></span><br><span class="line">    ....</span><br><span class="line"><span class="tag">&lt;/<span class="name">configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><br>&emsp;还需要在 mapper 映射文件中配置二级缓存：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">mapper</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">"-//mybatis.org//DTD Mapper 3.0//EN"</span></span></span><br><span class="line"><span class="meta">        <span class="meta-string">"http://mybatis.org/dtd/mybatis-3-mapper.dtd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>=<span class="string">"com.jp.mybatis.dao.StudentMapper"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">cache</span> <span class="attr">eviction</span>=<span class="string">"LRU"</span> <span class="attr">flushInterval</span>=<span class="string">"100000"</span> <span class="attr">readOnly</span>=<span class="string">"true"</span> <span class="attr">size</span>=<span class="string">"1024"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><br>&emsp;也可以在 Mapper 类使用注解配置：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CacheNamespace</span>(</span><br><span class="line">        eviction = FifoCache<span class="class">.<span class="keyword">class</span>,</span></span><br><span class="line"><span class="class">        <span class="title">flushInterval</span> </span>= <span class="number">60000</span>,</span><br><span class="line">        size = <span class="number">512</span>,</span><br><span class="line">        readWrite = <span class="keyword">true</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure></p><p>&emsp;默认的二级缓存会有如下效果：</p><ul><li>映射语句文件中的所有SELECT 语句将会被缓存。</li><li>映射语句文件中的所有时SERT 、UPDATE 、DELETE 语句会刷新缓存。</li><li>缓存会使用Least Rece ntly U sed ( LRU ，最近最少使用的）算法来收回。</li><li>根据时间表（如no Flush Int erv al ，没有刷新间隔），缓存不会以任何时间顺序来刷新。</li><li>缓存会存储集合或对象（无论查询方法返回什么类型的值）的102 4 个引用。</li><li>缓存会被视为read/write （可读／可写）的， 意味着对象检索不是共享的，而且可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><p>&emsp;下面介绍一些几个重要的参数：</p><ul><li>eviction （收回策略）<ul><li>LRU （最近最少使用的） ： 移除最长时间不被使用的对象，这是默认值。</li><li>FIFO （先进先出〉： 按对象进入缓存的顺序来移除它们。</li><li>SOFT （软引用） ： 移除基于垃圾回收器状态和软引用规则的对象。</li><li>WEAK （弱引用） ： 更积极地移除基于垃圾收集器状态和弱引用规则的对象。</li></ul></li><li>flushinterval （刷新间隔〉。可以被设置为任意的正整数， 而且它们代表一个合理的毫秒形式的时间段。默认情况不设置，即没有刷新间隔， 缓存仅仅在调用语句时刷新。</li><li>size （引用数目） 。可以被设置为任意正整数，要记住缓存的对象数目和运行环境的可用内存资源数目，默认值是1024。</li><li>readOnly （只读）。属性可以被设置为true 或false 。只读的缓存会给所有调用者返回缓存对象的相同实例，因此这些对象不能被修改， 这提供了很重要的性能优势。可读写的缓存会通过序列化返回缓存对象的拷贝， 这种方式会慢一些，但是安全，因此默认是false 。</li></ul><p>&emsp;如果配置的是可读写的缓存，而MyBatis使用SerializedCache (org.apache.ibatiS.cache.decorators.SerializedCache) 序列化缓存来实现可读写缓存类，井通过序列化和反序列化来保证通过缓存获取数据时，得到的是一个新的实例，此时缓存类需要实现 Serializable 接口。如果配置为只读缓存， MyBatis 就会使用 Map 来存储缓存值，这种情况下，从缓存中获取的对象就是同一个实例。</p><p>&emsp;下面看一个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testL2Cache</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SqlSession sqlSession = getSqlSession();</span><br><span class="line">        SysRole role1 = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//此时二级缓存没有数据，使用的是一级缓存</span></span><br><span class="line">            RoleMapper roleMapper = sqlSession.getMapper(RoleMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            role1 = roleMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">            <span class="comment">//读写是不安全的，会影响下面的role2</span></span><br><span class="line">            role1.setRoleName(<span class="string">"New Name"</span>);</span><br><span class="line"></span><br><span class="line">            SysRole role2 = roleMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">            <span class="comment">//虽然没有更新，但是名字和role1一样</span></span><br><span class="line">            Assert.assertEquals(<span class="string">"New Name"</span>,role2.getRoleName());</span><br><span class="line">            <span class="comment">//是同个实例</span></span><br><span class="line">            <span class="comment">///这里使用的是一级缓存，所以是同个实例</span></span><br><span class="line">            System.out.println(role1==role2);</span><br><span class="line">            Assert.assertEquals(role1,role2);</span><br><span class="line">            <span class="comment">//二级缓存中没有，所以两次查询名中率都是0</span></span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="comment">//close之后，sqlSession会保存查询数据到二级缓存中</span></span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"开启新的sqlSession"</span>);</span><br><span class="line">        sqlSession = getSqlSession();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            RoleMapper roleMapper = sqlSession.getMapper(RoleMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="comment">//第三次查询，日志没有输出数据库查询，二级缓存命中，命中率为0.333</span></span><br><span class="line">            SysRole role2 = roleMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">            Assert.assertNotEquals(role1,role2);</span><br><span class="line">            <span class="comment">//第四次查询，2次命中，命中率为0.5</span></span><br><span class="line">            SysRole role3 = roleMapper.selectById(<span class="number">1L</span>);</span><br><span class="line">            <span class="comment">//二级缓存设置为可读写缓存，role2和role3是反序列化得到的结果</span></span><br><span class="line">            <span class="comment">//所以是不同的实例</span></span><br><span class="line">            <span class="comment">//这两个实例是读写安全的，其属性不会相互影响</span></span><br><span class="line">            Assert.assertNotEquals(role2,role3);</span><br><span class="line">        &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">            sqlSession.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;输出结果为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">DEBUG [main] - Setting autocommit to <span class="keyword">false</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">65</span>d6b83b]</span><br><span class="line">DEBUG [main] - ==&gt;  Preparing: select id,role_name,enabled,create_by,create_time from sys_role where id = ? </span><br><span class="line">DEBUG [main] - ==&gt; Parameters: <span class="number">1</span>(Long)</span><br><span class="line">TRACE [main] - &lt;==    Columns: id, role_name, enabled, create_by, create_time</span><br><span class="line">TRACE [main] - &lt;==        Row: <span class="number">1</span>, 管理员, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2019</span>-<span class="number">10</span>-<span class="number">28</span> <span class="number">20</span>:<span class="number">38</span>:<span class="number">35</span></span><br><span class="line">DEBUG [main] - &lt;==      Total: <span class="number">1</span></span><br><span class="line">DEBUG [main] - Cache Hit Ratio [com.jp.mapper.RoleMapper]: <span class="number">0.0</span></span><br><span class="line"><span class="keyword">true</span></span><br><span class="line">DEBUG [main] - Resetting autocommit to <span class="keyword">true</span> on JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">65</span>d6b83b]</span><br><span class="line">DEBUG [main] - Closing JDBC Connection [com.mysql.cj.jdbc.ConnectionImpl@<span class="number">65</span>d6b83b]</span><br><span class="line">开启新的sqlSession</span><br><span class="line">DEBUG [main] - Cache Hit Ratio [com.jp.mapper.RoleMapper]: <span class="number">0.3333333333333333</span></span><br><span class="line">DEBUG [main] - Cache Hit Ratio [com.jp.mapper.RoleMapper]: <span class="number">0.5</span></span><br></pre></td></tr></table></figure><br>&emsp;可以看到，只有第一个 sqlSession 的第一次 select 操作会触发实际的数据库查询，第一个 sqlSession 的第二次查询返回的是和第一次 select 的同个实例，此时使用的是一级缓存。当调用close 方法关闭SqlSession 时， SqlSession 才会保存查询数据到二级缓存中。在这之后二级缓存才有了缓存数据。所以可以看到在第一部分的两次查询时，命中率都是0 。</p><p>&emsp;在第二部分测试代码中，再次获取 role2 时，日志中并没有输出数据库查询，而是输出了命中率，这时的命中率是 0.3333333333333333 。这是第 3 次查询，并且得到了缓存的值，因此该方法一共被请求了3 次，有l 次命中，所以命中率就是三分之一。后面再获取 role3 的时候，就是4 次请求，2 次命中，命中率为 0.5 。并且因为可读写缓存的缘故， role2 和 role3 都是反序列化得到的结果，所以它们不是相同的实例。在这一部分，这两个实例是读写安全的，其属性不会互相影响。</p><p>&emsp;在这个例子中并没有真正的读写安全，为什么？<br>&emsp;因为这个测试中加入了一段不该有的代码，即 rolel.setRoleName(“New Name”);,这里修改 role1 的属性位后，按照常理应该更新数据，更新后会清空一、二级缓存，这样在第二部分的代码中就不会出现查询结果的 roleName 都是 “New Name”，的情况了。所以想要安全使用，需要避免毫无意义的修改。这样就可以避免人为产生的脏数据，避免缓存和数据库的数据不一致。</p><h2 id="EhCache缓存-Redis缓存"><a href="#EhCache缓存-Redis缓存" class="headerlink" title="EhCache缓存/Redis缓存"></a>EhCache缓存/Redis缓存</h2><p>&emsp;Mybatis可以集成其它缓存机制，比如 EhCache 和 Redis。</p><ul><li>EhCache 是一个纯粹的 Java 进程内的缓存框架：<a href="https://github.com/mybatis/ehcache-cache" target="_blank" rel="noopener">https://github.com/mybatis/ehcache-cache</a></li><li>Redis 是一个高性能的 key-value 数据库：<a href="https://github.com/mybatis/redis-cache" target="_blank" rel="noopener">https://github.com/mybatis/redis-cache</a></li></ul><h2 id="脏数据的产生和避免"><a href="#脏数据的产生和避免" class="headerlink" title="脏数据的产生和避免"></a>脏数据的产生和避免</h2><p>&emsp;MyBatis 的二级缓存是和命名空间绑定的，所以通常情况下每一个 Mapper 映射文件都拥有自己的二级缓存，不同 Mapper 的二级缓存互不影响。在常见的数据库操作中，多表联合查询非常常见，由于关系型数据库的设计， 使得很多时候需要关联多个表才能获得想要的数据。在关联多表查询时肯定会将该查询放到某个命名空间下的映射文件中，这样一个多表的查询就会缓存在该命名空间的二级缓存中。涉及这些表的增、删、改操作通常不在一个映射文件中，它们的命名空间不同， 因此当有数据变化时，多表查询的缓存未必会被清空，这种情况下就会产生脏数据。<br>&emsp;这段话看起来可能不是很清晰，通过一个例子来解释下：<br>在 UserMapper 中创建了selectUserAndRoleByid 方法， 该方法的SQL 语句如下：<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    u.id,</span><br><span class="line">    u.user_name userName,</span><br><span class="line">    u.user_password userPassword,</span><br><span class="line">    u.user_email userEmail,</span><br><span class="line">    u.user_info userinfo,</span><br><span class="line">    u.head_img headimg,</span><br><span class="line">    u.create_time createTime,</span><br><span class="line">    r.id <span class="string">"role.id"</span>,</span><br><span class="line">    r.role_name <span class="string">"role.roleName"</span>,</span><br><span class="line">    r.enabled <span class="string">"role.enabled"</span>,</span><br><span class="line">    r.create_by <span class="string">"role.createBy"</span>,</span><br><span class="line">    r.create_time <span class="string">"role.createTime"</span></span><br><span class="line">    <span class="keyword">from</span> sys_user u</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> sys_user_role ur <span class="keyword">on</span> u.id = ur.user_id</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> sys_role r <span class="keyword">on</span> ur.role <span class="keyword">id</span> = r.id</span><br><span class="line">    <span class="keyword">where</span> u.id = <span class="comment">#&#123;id&#125;</span></span><br></pre></td></tr></table></figure><br>&emsp;这里涉及到三个表，sys_user、sys_role 和 sys_user_role，user 和 role 是一对多的关系，sys_user_role 表是 user 和 role 的关联表。<br>&emsp;这个 SQL 语句关联了两个表来查询用户对应的角色数据。给 UserMapper.xml 添加二级缓存配置，增加\<cache/>元素。<br>下面演示二级缓存产生的脏数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">testDirtyData</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//获取sqlSession</span></span><br><span class="line">    SqlSession sqlSession= getSqlSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//user 和 role 的数据会被缓存在 UserMapper 命名空间对应的二级缓存中</span></span><br><span class="line">        SysUser user= userMapper.selectUserAndRoleByid(<span class="number">1001L</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">"普通用户"</span>， user.getRole().getRoleName());  <span class="comment">//数据库里面原来的数据</span></span><br><span class="line">        System.out.println(<span class="string">"角色名:"</span> ＋ user.getRole().getRoleName());</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        sqlSession.close();</span><br><span class="line">        <span class="comment">//开始另一个新的session</span></span><br><span class="line">        sqlSession= getSqlSession();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        RoleMapper roleMapper = sqlSession.getMapper(RoleMapper<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">        <span class="comment">//id为2的role被缓存在 RoleMapper 命名空间对应的二级缓存中</span></span><br><span class="line">        SysRole role= roleMapper.selectByid (<span class="number">2L</span>);</span><br><span class="line">        <span class="comment">//修改角色信息</span></span><br><span class="line">        role.setRoleName(<span class="string">"新数据"</span>)；</span><br><span class="line">        roleMapper.updateByid(role);</span><br><span class="line">        <span class="comment">//提交修改</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        ／／关闭当前的sqlSession</span><br><span class="line">        sqlSession.close() ;</span><br><span class="line">        System.out.println(<span class="string">"开启新的sqlSession"</span>)；</span><br><span class="line">        <span class="comment">//开始另一个新的session</span></span><br><span class="line">        sql Session = getSqlSession() ;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        UserMapper userMapper = sqlSession.getMapper(UserMapper<span class="class">.<span class="keyword">class</span>) </span>;</span><br><span class="line">        RoleMapper roleMapper = sqlSession.getMapper (RoleMapper<span class="class">.<span class="keyword">class</span>) </span>;</span><br><span class="line">        SysUser user = userMapper.selectUserAndRoleByid(<span class="number">1001L</span>) ;</span><br><span class="line">        SysRole role = roleMapper.selectByid(<span class="number">2L</span>);</span><br><span class="line">        Assert.assertEquals(<span class="string">"普通用户"</span>，user.getRole().getRoleName()); <span class="comment">//UserMapper中缓存的数据</span></span><br><span class="line">        Assert.assertEquals(<span class="string">"新数据"</span>，role.getRoleName());</span><br><span class="line">        System.out.println(<span class="string">"角色名："</span>+ user.getRole().getRoleName());</span><br><span class="line">        <span class="comment">//还原数据</span></span><br><span class="line">        role.setRoleName(<span class="string">"普通用户"</span>)；</span><br><span class="line">        roleMapper.updateByid(role) ;</span><br><span class="line">        <span class="comment">//提交修改</span></span><br><span class="line">        sqlSession.commit();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="comment">//关闭sqlSession</span></span><br><span class="line">        sqlSession.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;在这个测试中，一共有 3 个不同的SqlSession。第一个 SqlSession 中获取了用户和关联的角色信息，第二个 SqlSession 中查询角色并修改了角色的信息，第三个 SqlSession 中查询用户和关联的角色信息,此时 user 获取到的 roleName 实际是缓存在二级缓存中的数据，而不是第二个在 SqlSession 里面写入的新数据，这就出现了脏数据，因为角色名称己经修改，但是这里读取到的角色名称仍然是修改前的名字，因此出现了 <strong>脏读</strong>。</p><p>&emsp;该如何避免脏数据的出现呢？这时就需要用到 <strong>参照缓存</strong>了。当某几个表可以作为一个业务整体时，通常是让几个会关联的 ER 表同时使用同一个二级缓存，这样就能解决脏数据问题。<br>在上面这个例子中，将 UserMapper.xml 中的缓存配置修改如下:<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">mapper</span> <span class="attr">namespace</span>= <span class="string">"com.jp.mybaits.mapper.UserMapper"</span> &gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">cache-ref</span> <span class="attr">namespace</span>= <span class="string">"com.jp.mybaits.mapper.RoleMapper"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 其他配置 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">mapper</span>&gt;</span></span><br></pre></td></tr></table></figure><br>&emsp;虽然这样可以解决脏数据的问题，但是并不是所有的关联查询都可以这么解决，如果有几十个表甚至所有表都以不同的关联关系存在于各自的映射文件中时，使用参照缓存显然没有意义。</p><h2 id="二级缓存适用的场景"><a href="#二级缓存适用的场景" class="headerlink" title="二级缓存适用的场景"></a>二级缓存适用的场景</h2><p>&emsp;二级缓存虽然好处很多，但并不是什么时候都可以使用。在以下场景中，推荐使用二级缓存：</p><ul><li>以查询为主的应用中，只有尽可能少的增、删、改操作。</li><li>绝大多数以单表操作存在时，由于很少存在互相关联的情况，因此不会出现脏数据。</li><li>可以按业务划分对表进行分组时， 如关联的表比较少，可以通过参照缓存进行配置。</li></ul><p>&emsp;除了推荐使用的情况，如果脏读对系统没有影响，也可以考虑使用。在无法保证数据不出现脏读的情况下， 建议在业务层使用可控制的缓存代替二级缓存。</p><p>&nbsp;</p><blockquote><p>参考：<br>《Mybatis从入门到精通》<br><a href="https://www.cnblogs.com/happyflyingpig/p/7739749.html" target="_blank" rel="noopener">https://www.cnblogs.com/happyflyingpig/p/7739749.html</a><br><a href="https://www.oschina.net/question/54100_2279823" target="_blank" rel="noopener">https://www.oschina.net/question/54100_2279823</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机 之 虚拟机类加载机制</title>
      <link href="/java/java-jvm-classLoader/"/>
      <url>/java/java-jvm-classLoader/</url>
      
        <content type="html"><![CDATA[<h1 id="虚拟机类加载机制"><a href="#虚拟机类加载机制" class="headerlink" title="虚拟机类加载机制"></a>虚拟机类加载机制</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;在Java语言里面，类型的加载、连接和初始化过程都是在程序运行期间完成的，这种策略虽然会另类加载时稍微增加一些性能开销，但是会为Java应用程序提供高度的灵活性，Java里天生可以动态扩展的语言特性就是依赖<strong>运行期动态加载</strong>和<strong>动态连接</strong>这个特点实现的。</p><h2 id="2-类加载的时机"><a href="#2-类加载的时机" class="headerlink" title="2. 类加载的时机"></a>2. 类加载的时机</h2><p>&emsp;JVM类加载机制流程大致分为以下七个步骤：</p><ul><li>1.加载 Loading</li><li>2.验证 Verification</li><li>3.准备 Preparation</li><li>4.解析 Resolution</li><li>5.初始化 Initialization</li><li>6.使用 Using</li><li>7.卸载 Unloading</li></ul><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/class-life.webp" alt="类的生命周期"></p><p>&emsp;其中，加载、验证、准备、初始化和卸载这5个阶段的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始，而解析阶段则不一定：在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定（动态绑定/晚期绑定）。</p><h2 id="3-类加载的过程"><a href="#3-类加载的过程" class="headerlink" title="3. 类加载的过程"></a>3. 类加载的过程</h2><h3 id="3-1-加载"><a href="#3-1-加载" class="headerlink" title="3.1 加载"></a>3.1 加载</h3><p>&emsp;“加载”是“类加载”（Class Loading）过程的一个阶段。在加载阶段，虚拟机需要完成以下3件事情：</p><ol><li>通过一个类的全限定名来获取定义此类的<strong>二进制字节流</strong>。</li><li>将这个字节流所代表的静态存储结构转化为<strong>方法区</strong>的运行时数据结构。</li><li>在内存中生成一个代表这个类的<strong>java.lang.Class</strong>对象，作为方法区这个类的各种数据的访问入口。</li></ol><p>&emsp;注意：这里不一定非得要从一个Class文件获取，也可以通过其它方式获得：</p><ul><li>从zip包中读取（比如从jar包和war包中读取）</li><li>运行时计算生成（动态代理），ProxyGenerator.generateProxyClass</li><li>由其它文件生成（比如将JSP文件转换成对应的CLass类）</li><li>数据库中读取，把程序安装到数据库中来完成程序代码在集群间的分发</li></ul><p>&emsp;相对于类加载过程的其他阶段，一个非数组类的加载阶段是开发人员可控性最强的，因为加载阶段既可以使用系统提供的引导类加载器来完成，也可以由用户自定义的类加载器去完成。<br>&emsp;对于数组类，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的，但是数组类的元素类型最终还是要靠类加载器去创建。</p><ul><li>如果数组的组件类型是引用类型，那么递归采用上述的加载过程去加载这个组件类型，该数组在加载该组建类型的类加载期器的类命名空间上被标识；</li><li>如果数组的组件类型不是引用类型，Java虚拟机会把数组标记为与引导类加载期关联；</li></ul><h3 id="3-2-验证"><a href="#3-2-验证" class="headerlink" title="3.2 验证"></a>3.2 验证</h3><p>&emsp;Class文件并不一定要求用Java源码编译而来，可以使用任何途径产生。虚拟机如果不检查输入的字节流，很可能会因为载入了有害的字节流而导致系统崩溃，因此验证阶段是非常重要的，它包含下面4个检验动作：</p><ul><li>文件格式验证</li><li>元数据验证</li><li>字节码验证</li><li>符号引用验证</li></ul><ol><li>文件格式验证<br>&emsp;验证字节流是否符合Class文件格式的规范，并且能被当前版本的虚拟机处理：</li></ol><ul><li>是否以魔数0xCAFEBABE开头</li><li>主次版本号是否在当前虚拟机处理范围之内</li><li>常量池中的常量是否有不被支持的常量类型</li><li>指向常量的各种索引值中是否有指向不存在的常量或不符合类型的常量</li><li>CONSTANTUtf8info型的常量中是否有不符合UTF8编码的数据</li><li>Class文件中各个部分及文件本身是否有被删除的或附加的其他信息</li><li>…</li></ul><p>&emsp;该阶段的主要目的是保证输入的字节流能正确地解析并储存与方法区之内，格式上符合一个Java类型信息的要求，后面的3个阶段都是基于方法区的储存结构进行，不会再直接操作字节流。</p><ol><li>元数据验证<br>&emsp;对字节码信息进行语义分析，保证其描述的信息符合Java语言规范的要求：</li></ol><ul><li>这个类是否有父类</li><li>这个类的父类是否继承了不准许被继承的类</li><li>如果这个类不是抽象类,是否实现了其父类或者接口之中要求实现的所有方法</li><li>类中的字段方法是否与父类产生矛盾</li></ul><p>主要目的是对类的元数据信息进行语义检验，保证不存在不符合Java语言规范的元数据信息。</p><ol><li>字节码验证<br>&emsp;主要目的是通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的。</li></ol><ul><li>保证任意时刻操作数栈的数据类型与指令代码序列都能配合工作</li><li>保证跳转指令不会跳转到方法体以外的字节码指令上</li><li>保证方法体中的类型转换是有效的</li><li>…</li></ul><p>&emsp;即使字节码验证之中进行了大量的检查，也不能保证一定是安全的。这涉及到离散数学一个很著名的问题”Halting Problem“：通过程序去检验程序逻辑是无法做到绝对准确的-不能通过程序准确检查出程序是否能在有限的时间之内结束运行。</p><p>&emsp;在文章<a href="http://zhoujiapeng.top/java/java-jvm-class-file-struct/#37">《深入理解Java虚拟机 之 类文件结构》</a>中有介绍到：在类加载的验证阶段，由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在JDK1.6之后的 Javac编译器和 Java 虚拟机中进行了一项优化，给方法体的 Code 属性的属性表中增加了一项名为”<strong>StackMapTable</strong>“的属性，这项属性描述了方法体中所有基本块(Basic Block，按照控制流拆分的代码块)开始时本地变量表和操作数栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需要检查 StackMapTable 属性中的记录是否合法即可，这样将字节码验证的类型推导转变为类型检查从而节省一些时间。</p><ol><li>符号引用验证<br>&emsp;这个阶段发生在虚拟机将符号引用转化为直接引用的时候-解析阶段发生。</li></ol><ul><li>符号引用中通过字符串描述的全限定名是否找到相应的类</li><li>在指定的类中是否存在符合方法的字段描述符以及简单名称说描述的方法和字段</li><li>符号引用中的类、字段、方法的访问性是否被当前类访问</li></ul><p>&emsp;符号引用验证的目的是确保解析动作正常执行。</p><h3 id="3-3-准备"><a href="#3-3-准备" class="headerlink" title="3.3 准备"></a>3.3 准备</h3><p>&emsp;准备阶段是正式为<strong>类变量</strong>分配内存并设置类变量的<strong>初始值</strong>阶段，即在方法区中分配这些变量所使用的内存空间。这里需要注意两个问题：</p><ul><li>这时候进行内存分配的仅包括类变量(static 修饰的变量),而不包括实例变量，实例变量将会在对象实例化时随着对象一起分配在java堆中</li><li>这里所说的初始值“通常情况”下是数据类型的零值，假设一个类变量定义为: public static int value = 12; 那么变量value在准备阶段过后的初始值为0而不是12，把value赋值为123的 putstatic 指令是程序被编译后，存放于类构造器\<clinit>()方法之中，所以把value赋值为12的动作将在初始化阶段才会被执行。</li></ul><p>&emsp;另外，如果类字段的字段属性表中存在 <strong>ConstantValue</strong> 属性(同时被final和static修饰)，那么在准备阶段就会被初始化为 ConstantValue 所指定的值:<br>&emsp;public static <strong>final</strong> int value = 123;<br>&emsp;那么在准备阶段value会被设置为123。</p><h3 id="3-4-解析"><a href="#3-4-解析" class="headerlink" title="3.4 解析"></a>3.4 解析</h3><p>&emsp;解析阶段是虚拟机常量池内的符号引用替换为直接引用的过程。 </p><ul><li>符号引用：符号引用是一组符号来描述所引用的目标对象，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标对象并不一定已经加载到内存中。 </li><li>直接引用：直接引用可以是直接指向目标对象的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机内存布局实现相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同，如果有了直接引用，那引用的目标必定已经在内存中存在。</li></ul><p>&emsp;虚拟机规范并没有规定解析阶段发生的具体时间，只要求了在执行anewarry、checkcast、getfield、instanceof、invokeinterface、invokespecial、invokestatic、invokevirtual、multianewarray、new、putfield和putstatic这13个用于操作符号引用的字节码指令之前，先对它们使用的符号引用进行解析，所以虚拟机实现会根据需要来判断，到底是在类被加载器加载时就对常量池中的符号引用进行解析，还是等到一个符号引用将要被使用前才去解析它。</p><p>&emsp;解析的动作主要针对类或接口、字段、类方法、接口方法四类符号引用进行。分别对应编译后常量池内的CONSTANT_Class_Info、CONSTANT_Fieldref_Info、CONSTANT_Methodef_Info、CONSTANT_InterfaceMethoder_Info四种常量类型。</p><p>1.类、接口的解析<br>2.字段解析<br>3.类方法解析<br>4.接口方法解析</p><h3 id="3-5-初始化"><a href="#3-5-初始化" class="headerlink" title="3.5 初始化"></a>3.5 初始化</h3><p>&emsp;类的初始化阶段是类加载过程的最后一步，在准备阶段，类变量已赋过一次系统要求的初始值，而在初始化阶段，则是根据程序员通过程序制定的主观计划去初始化类变量和其他资源，也就是执行类构造器\<clinit>()方法的过程。关于clinit方法有下面几点需要注意：</p><ul><li>类构造器&lt; clinit &gt;()方法是由编译器自动收集类中的所有<strong>类变量的赋值动作</strong>和<strong>静态语句块</strong>(static{}块)中的语句合并产生的。</li><li>类构造器&lt; clinit &gt;()方法与类的构造函数(实例构造函数&lt; init &gt;()方法)不同，它不需要显式调用父类构造，虚拟机会保证在子类&lt; clinit &gt;()方法执行之前，父类的&lt; clinit &gt;()方法已经执行完毕。因此在虚拟机中的第一个执行的&lt; clinit &gt;()方法的类肯定是java.lang.Object。</li><li>由于父类的&lt; clinit &gt;()方法先执行，也就意味着父类中定义的静态语句快要优先于子类的变量赋值操作。</li><li>&lt; clinit &gt;()方法对于类或接口来说并不是必须的，如果一个类中没有静态语句，也没有变量赋值的操作，那么编译器可以不为这个类生成&lt; clinit &gt;()方法。</li><li>接口中不能使用静态语句块，但接口与类不太能够的是，执行接口的&lt; clinit &gt;()方法不需要先执行父接口的&lt; clinit &gt;()方法。只有当父接口中定义的变量被使用时，父接口才会被初始化。另外，接口的实现类在初始化时也一样不会执行接口的&lt; clinit &gt;()方法。</li><li>虚拟机会保证一个类的&lt; clinit &gt;()方法在多线程环境中被正确加锁和同步，如果多个线程同时去初始化一个类，那么只会有一个线程执行这个类的&lt; clinit &gt;()方法，其他线程都需要阻塞等待，直到活动线程执行&lt; clinit &gt;()方法完毕。如果一个类的&lt; clinit &gt;()方法中有耗时很长的操作，那就可能造成多个进程阻塞。</li></ul><p>&emsp;虚拟机规范严格规定<strong>有且只有</strong>5种情况必须立即对类进行”初始化“：</p><ul><li>1.遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需先触发其初始化。生成这4条指令的最常见的java代码场景是：使用new关键字实例化对象、读取或设置一个类的静态字段(被final修饰、已在编译器把结果放入常量池的静态字段除外)的时候，以及调用类的静态方法的时候。</li><li>2.使用java.lang.reflect包的方法对类进行反射调用的时候。</li><li>3.当初始化一个类的时候，如果发现其父类还没有进行过初始化、则需要先出发其父类的初始化。</li><li>4.jvm启动时，用户指定一个执行的主类(包含main方法的那个类)，虚拟机会先初始化这个类。</li></ul><p>&emsp;这种场景称为对一个类进行<strong>主动引用</strong>,除此之外所有引用类的所有方式都不会触发初始化，称为<strong>被动引用</strong>：</p><ul><li>通过子类引用父类的静态字段(static)，不会导致子类初始化，对于静态字段，只有直接定义这个字段的类才会被初始化。</li><li>通过数组定义来引用类，不会触发此类的初始化，前面讲到，数组类本身不通过类加载器创建，它是由Java虚拟机直接创建的。</li><li>常量(static final)在编译阶段会存入<strong>调用类</strong>的常量池，本质上没有直接引用到定义常量的类。</li></ul><h2 id="4-类加载器"><a href="#4-类加载器" class="headerlink" title="4. 类加载器"></a>4. 类加载器</h2><p>&emsp;虚拟机设计团队把类加载阶段中的“<strong>通过一个类的全限定名来获取描述此类的二进制字节流</strong>”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类。实现这个动作的代码模块称为“类加载器”。</p><h3 id="4-1-类与类加载器"><a href="#4-1-类与类加载器" class="headerlink" title="4.1 类与类加载器"></a>4.1 类与类加载器</h3><p>&emsp;对于任意一个类，都需要由加载它的<strong>类加载器和这个类本身一同确立其在Java虚拟机中的唯一性</strong>。如果两个类来源于同一个Class文件，只要加载它们的类加载器不同，那么这两个类就必定不相等。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JVM7_8</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">        <span class="comment">//自定义类加载器</span></span><br><span class="line">        ClassLoader myLoader = <span class="keyword">new</span> ClassLoader() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="keyword">public</span> Class&lt;?&gt; loadClass(String name) <span class="keyword">throws</span> ClassNotFoundException &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    String fileName = name.substring(name.lastIndexOf(<span class="string">"."</span>) + <span class="number">1</span>) + <span class="string">".class"</span>;</span><br><span class="line">                    InputStream is = getClass().getResourceAsStream(fileName);</span><br><span class="line">                    <span class="keyword">if</span> (is == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">return</span> <span class="keyword">super</span>.loadClass(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">byte</span>[] b = <span class="keyword">new</span> <span class="keyword">byte</span>[is.available()];</span><br><span class="line">                    is.read(b);</span><br><span class="line">                    <span class="keyword">return</span> defineClass(name, b, <span class="number">0</span>, b.length);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ClassNotFoundException(name);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        Object obj = myLoader.loadClass(<span class="string">"com.jp.jvm.ch07.JVM7_8"</span>).newInstance();</span><br><span class="line">        System.out.println(obj.getClass());</span><br><span class="line">        <span class="comment">//不属于同一个类加载器，所以不一样</span></span><br><span class="line">        <span class="comment">//虚拟机中存在了两个ClassLoader</span></span><br><span class="line">        <span class="comment">//一个是由系统应用程序类加载器加载的</span></span><br><span class="line">        <span class="comment">//另一个是自定义的类加载器</span></span><br><span class="line">        System.out.println(obj <span class="keyword">instanceof</span> com.jp.jvm.ch07.JVM7_8);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class com.jp.jvm.ch07.JVM7_8</span><br><span class="line">false</span><br></pre></td></tr></table></figure></p><h3 id="4-2-双亲委派模型"><a href="#4-2-双亲委派模型" class="headerlink" title="4.2 双亲委派模型"></a>4.2 双亲委派模型</h3><p>&emsp;从虚拟机的角度来说，只存在两种不同的类加载器：一种是启动类加载器（Bootstrap ClassLoader），该类加载器使用C++语言实现，属于虚拟机自身的一部分。另外一种就是所有其它的类加载器，这些类加载器是由Java语言实现，独立于JVM外部，并且全部继承自抽象类java.lang.ClassLoader。<br>&emsp;从Java开发人员的角度来看，大部分Java程序一般会使用到以下三种系统提供的类加载器：</p><ol><li>启动类加载器（Bootstrap ClassLoader）：负责加载 JAVA_HOME\lib 目录中并且能被虚拟机识别的类库到JVM内存中，如果名称不符合的类库即使放在lib目录中也不会被加载。该类加载器无法被Java程序直接引用。</li><li>扩展类加载器（Extension ClassLoader）：该加载器主要是负责加载 JAVA_HOME\lib\ext 目录中，或者被 java.ext.dirs 系统变量所定义的路径中的所有类库，该加载器可以被开发者直接使用。</li><li>应用程序类加载器（Application ClassLoader）：该类加载器也称为系统类加载器，它负责加载用户类路径（Classpath）上所指定的类库，开发者可以直接使用该类加载器，如果应用程序中没有自定义过自己的类加载器，一般情况下这个就是程序中默认的类加载器。我们的应用程序都是由这三类加载器互相配合进行加载的，另外可以自己定义类加载器。 </li><li>自定义类加载器必须继承 ClassLoader。 </li></ol><p>&emsp;这些类加载器之间的关系如下图所示：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/Parents-Delegation-Model.webp" alt="双亲委派模型"></p><p>&emsp;加载器之间的这种层次关系，就称为类加载器的<strong>双亲委派模型</strong>（Parent Delegation Model）。该模型要求除了顶层的启动类加载器外，其余的类加载器都应当有自己的父类加载器。子类加载器和父类加载器不是以继承（Inheritance）的关系来实现，而是通过<strong>组合</strong>（Composition）关系来复用父加载器的代码。</p><p>&emsp;双亲委派模型的工作过程为：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的加载器都是如此，因此所有的类加载请求都会传给顶层的启动类加载器，只有当父加载器反馈自己无法完成该加载请求（该加载器的搜索范围中没有找到对应的类）时，子加载器才会尝试自己去加载。</p><p>&emsp;使用这种模型来组织类加载器之间的关系的好处是Java类随着它的类加载器一起具备了一种带有优先级的层次关系(<strong>各个类加载器的基础类统一问题</strong>)。例如java.lang.Object类，无论哪个类加载器去加载该类，最终都是由启动类加载器进行加载，因此Object类在程序的各种类加载器环境中都是同一个类。否则的话，如果不使用该模型的话，如果用户自定义一个java.lang.Object类且存放在classpath中，那么系统中将会出现多个Object类，应用程序也会变得很混乱。如果我们自定义一个rt.jar中已有类的同名Java类，会发现JVM可以正常编译，但该类永远无法被加载运行。</p><p>&emsp;下面是双亲委派模型的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ClassLoader.java</span></span><br><span class="line"><span class="keyword">protected</span> Class&lt;?&gt; loadClass(String name, <span class="keyword">boolean</span> resolve)</span><br><span class="line">        <span class="keyword">throws</span> ClassNotFoundException</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (getClassLoadingLock(name)) &#123;</span><br><span class="line">            <span class="comment">//首先检查请求的类是否已经被加载</span></span><br><span class="line">            Class&lt;?&gt; c = findLoadedClass(name);</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">long</span> t0 = System.nanoTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        c = parent.loadClass(name, <span class="keyword">false</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        c = findBootstrapClassOrNull(name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ClassNotFoundException e) &#123;</span><br><span class="line">                    <span class="comment">//如果父类加载器抛出 ClassNotFoundException</span></span><br><span class="line">                    <span class="comment">//说明父类加载器无法完成加载请求</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (c == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//在父类加载器无法加载的时候</span></span><br><span class="line">                    <span class="comment">//再调用本身的 findlClass 方法来进行加载</span></span><br><span class="line">                    <span class="keyword">long</span> t1 = System.nanoTime();</span><br><span class="line">                    c = findClass(name);</span><br><span class="line"></span><br><span class="line">                    <span class="comment">// this is the defining class loader; record the stats</span></span><br><span class="line">                    sun.misc.PerfCounter.getParentDelegationTime().addTime(t1 - t0);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClassTime().addElapsedTimeFrom(t1);</span><br><span class="line">                    sun.misc.PerfCounter.getFindClasses().increment();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (resolve) &#123;</span><br><span class="line">                resolveClass(c);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> c;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;</p><blockquote><p>参考：<br>《深入理解Java虚拟机》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机 之 字节码指令</title>
      <link href="/java/java-jvm-bytecode/"/>
      <url>/java/java-jvm-bytecode/</url>
      
        <content type="html"><![CDATA[<h1 id="字节码指令简介"><a href="#字节码指令简介" class="headerlink" title="字节码指令简介"></a>字节码指令简介</h1><p>&emsp;Java虚拟机指令由一个字节长度、代表某种特定操作含义的数字(操作码Opcode)，以及跟随在其后的零至多个代表此操作所需的参数(操作数Operands)构成的。由于<strong>Java虚拟机是面向操作数栈而不是寄存器的架构</strong>，所以大多数指令都只有操作码，而没有操作数。</p><p>&emsp;字节码指令集是一种具有鲜明特点、优劣势都很突出的指令集架构：</p><ol><li>由于限定了Java虚拟机操作码的长度为1个字节，指令集的操作码不能超过256条。</li><li>Class文件格式放弃了编译后代码中操作数长度对齐，这就意味者虚拟机处理那些超过一个字节数据的时候，不得不在运行的时候从字节码中重建出具体数据的结构。</li></ol><p>&emsp;这种操作在一定程度上会降低一些性能，但这样做的优势也非常的明显：</p><ol><li>放弃了操作数长度对齐，就意味着可以省略很多填充和间隔符号。</li><li>用一个字节来表示操作码，也是为了获取短小精悍的代码。</li></ol><p>&emsp;这种追求尽可能小数据量，高传输效率的设计是由Java语言之初面向网络、智能家电技术背景决定的。<br>&emsp;Java虚拟机解释器执行简单模型如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">计算PC寄存器的值+<span class="number">1</span>;</span><br><span class="line">根据PC寄存器只是位置，从字节码流中取出操作码;</span><br><span class="line"><span class="keyword">if</span>(存在操作数) 从字节码中取出操作数;</span><br><span class="line">执行操作码定义的操作;</span><br><span class="line">&#125;<span class="keyword">while</span>(字节码长度&gt;<span class="number">0</span>);</span><br></pre></td></tr></table></figure></p><h2 id="1-字节码与数据类型"><a href="#1-字节码与数据类型" class="headerlink" title="1. 字节码与数据类型"></a>1. 字节码与数据类型</h2><p>&emsp;在Java虚拟机的指令集中，大多数的指令都包含了其操作所对应的数据类型信息。例如：iload指令用于从局部变量表中加载int型的数据到操作数栈中，而fload指令加载的则是float类型的数据。这两条指令的操作在虚拟机内部可能会是由同一段代码来实现的，但在Class文件中它们必须拥有各自独立的操作码。</p><p>&emsp;对于大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务：i代表对int类型的数据操作，ｌ代表long，s代表short，b代表byte，c代表char，f代表float，d代表double，a代表reference。注意并不是所有的字节码指令都有数据类型相关，比goto无条件跳转指令就与数据类型无关。这里需要注意的是，并非每种数据类型和每一种操作都有对应的指令。这是因为Java虚拟机的操作码长度只有一个字节，如果每一种与数据类型相关的指令都支持Java虚拟机所有运行时数据类型的话，那指令的数量就会超出一个字节所能表示的数量范围，所以Java虚拟机的指令集对于特定的操作只提供了有限的类型相关指令去支持它。</p><p>&emsp;大部分的指令都没有支持整数类型byte、char和short，甚至没有任何指令支持boolean类型。编译器会在编译期或运行期将byte和short类型的数据带符号扩展为相应的int类型数据。与之类似，在处理boolean、byte、short和char类型的数组时，也会转换为使用对应的int类型的字节码指令来处理。因此，大多数对于boolean、byte、short和char类型数据的操作，实际上都是使用相应的int类型作为运算类型。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/bytecode1" alt="Java虚拟机所支持的数据类型1"><br><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/bytecode2" alt="Java虚拟机所支持的数据类型2"></p><h2 id="2-加载和储存指令"><a href="#2-加载和储存指令" class="headerlink" title="2. 加载和储存指令"></a>2. 加载和储存指令</h2><p>&emsp;加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈(见第2章关于内存区域的介绍)之间来回传输,这类指令包括如下内容:</p><ul><li>将一个局部变量加载到操作栈:iload、iload<em>\<n>、lload、lload</em>\<n>、fload、fload<em>\<n>、dload、dload</em>\<n>、aload、aload_\<n> 。</li><li>将一个数值从操作数栈存储到局部变量表 :istore、istore<em>\<n>、lstore、lstore</em>\<n>、fstore、fstore<em>\<n> 、dstore、dstore</em>\<n> 、astore、astore_\<n> 。</li><li>将一个常量加载到操作数栈:bipush、sipush、ldc、 ldc<em>w、ldc2_w、 aconst_null、iconst_ml、iconst</em>、lconst<em>\<l>、fconst</em>\<f>、dconst_\<d>。</li><li>扩充局部变量表的访问索引的指令 : wide。</li></ul><p>&emsp;存储数据的操作数栈和局部变量表主要就是由加载和存储指令进行操作,除此之外,还有少量指令,如访问对象的字段或数组元素的指令也会向操作数栈传输数据。</p><h2 id="3-运算指令"><a href="#3-运算指令" class="headerlink" title="3. 运算指令"></a>3. 运算指令</h2><p>&emsp;运算或算术指令用于对两个操作数栈上的值进行某种特定运算,并把结果重新存入到操作栈顶。大体上算术指令可以分为两种:对整型数据进行运算的指令与对浮点型数据进行运算的指令,无论是哪种算术指令,都使用Java虚拟机的数据类型,由于没有直接支持byte、 short、char和boolean类型的算术指令,对于这类数据的运算,应使用操作int类型的指令代替。整数与浮点数的算术指令在溢出和被零除的时候也有各自不同的行为表现,所有的算术指令如下:</p><ul><li>加法指令:iadd、ladd、fadd、dadd。</li><li>减法指令:isub、lsub、fsub、dsub。</li><li>乘法指令:imul、lmul、fmul、dmul。</li><li>除法指令:idiv、ldiv、fdiv、ddiv。</li><li>求余指令:irem、lrem、frem、drem。</li><li>取反指令 : ineg、lneg、fneg、dneg。</li><li>位移指令:ishl、ishr、iushr、lshl、lshr、lushr。</li><li>按位或指令:ior、lor。</li><li>按位与指令:iand、land。</li><li>按位异或指令:ixor、lxor。</li><li>局部变量自增指令:iinc。</li><li>比较指令:dcmpg、dcmpl、fcmpg、fcmpl、lcmp。</li></ul><p>&emsp;Java虚拟机规范没有明确定义过整型数据溢出的具体运算结果，仅规定了在处理整型数据时，只有除法指令（idv和ldv）以及求余指令（irem和lrem）中当出现除数为0时会导致虚拟机抛出 ArithmeticExcption 异常，其余任何整型数运算场景都不应该抛出运行时异常。</p><p>&emsp;Java虚拟机规范要求虚拟机实现在处理浮点数时,必须严格遵循<strong>IEEE 754</strong>规范中所规定的行为和限制。也就是说,Java虚拟机必须完全支持IEEE 754中定义的非正规浮点数值 ( Denormalized Floating-Point Numbers ) 和逐级下溢( Gradual Underflow ) 的运算规则。这些特征将会使某些数值算法处理起来变得相对容易一些。</p><p>&emsp;Java虚拟机要求在进行浮点数运算时,所有的运算结果都必须舍入到适当的精度,非精确的结果必须被舍入为可被表示的最接近的精确值,如果有两种可表示的形式与该值一样接近,将优先选择最低有效位为零的。这种舍入模式也是IEEE 754规范中的默认舍入模式,称为向<strong>最接近数舍入模式</strong>。</p><p>&emsp;在把浮点数转换为整数时,Java虚拟机使用正EE 754标准中的<strong>向零舍入模式</strong>,这种模式的舍入结果会导致数字被截断,所有小数部分的有效字节都会被丢弃掉。向零舍入模式将在目标数值类型中选择一个最接近但是不大于原值的数字来作为最精确的舍入结果。</p><p>&emsp;另外 ,Java虚拟机在处理浮点数运算时,不会拋出任何运行时异常(这里所讲的是Java 语言中的异常,请读者勿与正EE 754规范中的浮点异常互相混淆, IEEE 754的浮点异常是一种运算信号),当一个操作产生溢出时,将会使用有符号的无穷大来表示,如果某个操作结果没有明确的数学定义的话,将会使用NaN值来表示。所有使用NaN值作为操作数的算术操作 ,结果都会返回NaN。</p><p>&emsp;在对long类型数值进行比较时,虚拟机采用带符号的比较方式,而对浮点数值进行比较时 (dcmpg、dcmpl、fcmpg、 fcmpl ) ,虚拟机会采用IEEE 754规范所定义的无信号比较( Nonsignaling Comparisons ) 方式。</p><h2 id="4-类型转换指令"><a href="#4-类型转换指令" class="headerlink" title="4. 类型转换指令"></a>4. 类型转换指令</h2><p>&emsp;类型转换指令可以将两种不同的数值类型进行相互转换,这些转换操作一般用于实现用户代码中的显式类型转换操作,或者用来处理本节开篇所提到的字节码指令集中数据类型相关指令无法与数据类型一一对应的问题。<br>Java 虚拟机直接支持(即转换时无需显式的转换指令)以下数值类型的<strong>宽化类型转换</strong> ( WideningNumeric Conversions , 即小范围类型向大范围类型的安全转换):</p><ul><li>int类型到long、float或者double类型。</li><li>long类型到float、double类型。</li><li>float类型到double类型。</li></ul><p>&emsp;相对的,处理<strong>窄化类型转换</strong>( Narrowing Numeric Conversions ) 时 ,必须显式地使用转换指令来完成,这些转换指令包括:i2b、i2c、i2s、l2i、f2i、f2l、d2i、d2l和d2f。窄化类型转换可能会导致转换结果产生不同的正负号、不同的数量级的情况,转换过程很可能会导致数值的精度丢失。</p><p>&emsp;在将int或long类型窄化转换为整数类型T的时候,转换过程仅仅是简单地丢弃除最低位N个字节以外的内容(v丢弃高位),N是类型T的数据类型长度,这将可能导致转换结果与输入值有不同的正负号。</p><p>&emsp;在将一个浮点值窄化转换为整数类型T ( T限于int或long类型之一 ) 的时候,将遵循以下转换规则:</p><ul><li>如果浮点值是NaN ,那转换结果就是int或long类型的0。</li><li>如果浮点值不是无穷大的话,浮点值使用IEEE 754的向零舍入模式取整,获得整数值v , 如果v在目标类型T ( int或long ) 的表示范围之内,那转换结果就是v。</li><li>否则,将根据v的符号,转换为T所能表示的最大或者最小正数。</li></ul><h2 id="5-对象创建与访问指令"><a href="#5-对象创建与访问指令" class="headerlink" title="5. 对象创建与访问指令"></a>5. 对象创建与访问指令</h2><ul><li>创建类实例的指令:new。</li><li>创建数组的指令 : newarray、anewarray、multianewarray。</li><li>访问类字段(static字段 ,或者称为类变量)和实例字段(非static字段 ,或者称为实例变量 )的指令:getfield、putfield、getstatic、putstatic。</li><li>把一个数组元素加载到操作数栈的指令:baload、caload、saload、iaload、laload、faloads daload、aaload。</li><li>将一个操作数栈的值存储到数组元素中的指令:bastore、castore、sastore、iastore、fastore、dastore、aastore。</li><li>检查类实例类型的指令:instanceof、checkcast。</li></ul><h2 id="6-操作数栈管理指令"><a href="#6-操作数栈管理指令" class="headerlink" title="6. 操作数栈管理指令"></a>6. 操作数栈管理指令</h2><ul><li>将操作数栈的栈顶一个或两个元素出栈:pop、pop2。</li><li>复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶:dup、dup2、 dup_x1、dup2_x1、dup_x2、dup2_x2。</li><li>将栈最顶端的两个数值互换 : swap。</li></ul><h2 id="7-控制转移指令"><a href="#7-控制转移指令" class="headerlink" title="7. 控制转移指令"></a>7. 控制转移指令</h2><ul><li>条件分支:ifeq、iflt、ifle、ifne、ifgt、ifge、ifnull、ifnonnull、if_icmpeq、if_icmpne、if_icmplt、 if_icmpgt、if_icmple、if_icmpge、if_acmpeq和if_acmpne。</li><li>复合条件分支:tableswitch、 lookupswitch。</li><li>无条件分支:goto、goto_w、jsr、jsr_w、ret。</li></ul><p>&emsp;在Java虚拟机中有专门的指令集用来处理int和reference类型的条件分支比较操作,为了可以无须明显标识一个实体值是否null,也有专门的指令用来检测null值。</p><p>&emsp;与前面算术运算时的规则一致,对于boolean类型、byte类型、char类型和short类型的条件分支比较操作,都是使用int类型的比较指令来完成,而对于long类型、float类型和double类型的条件分支比较操作,则会先执行相应类型的比较运算指令(dcmpg、dcmpl、fcmpg、 fcmpl、lcmp,见6.4.3节),运算指令会返回一个整型值到操作数栈中,随后再执行int类型的条件分支比较操作来完成整个分支跳转。由于<strong>各种类型的比较最终都会转化为int类型的比较操作</strong> ,int类型比较是否方便完善就显得尤为重要,所以Java虚拟机提供的int类型的条件分支指令是最为丰富和强大的。</p><h2 id="8-方法调用和返回指令"><a href="#8-方法调用和返回指令" class="headerlink" title="8. 方法调用和返回指令"></a>8. 方法调用和返回指令</h2><ul><li>invokevirtual 指令用于调用对象的实例方法,根据对象的实际类型进行分派(虚方法分派),这也是Java语言中最常见的方法分派方式。</li><li>invokeinterface 指令用于调用接口方法,它会在运行时搜索一个实现了这个接口方法的对象 ,找出适合的方法进行调用。</li><li>invokespecial 指令用于调用一些需要特殊处理的实例方法,包括实例初始化方法、私有方法和父类方法。</li><li>invokestatic 指令用于调用类方法(static方法)。</li><li>invokedynamic 指令用于在运行时动态解析出调用点限定符所引用的方法,并执行该方法 ,前面4条调用指令的分派逻辑都固化在Java虚拟机内部,而invokedynamic指令的分派逻辑是由用户所设定的引导方法决定的。</li></ul><h2 id="9-异常处理指令"><a href="#9-异常处理指令" class="headerlink" title="9. 异常处理指令"></a>9. 异常处理指令</h2><p>&emsp;在Java程序中显式拋出异常的操作(<strong>throw</strong>语句)都由<strong>athrow</strong>指令来实现,除了用throw语句显式拋出异常情况之外,Java虛拟机规范还规定了许多运行时异常会在其他Java虚拟机指令检测到异常状况时自动拋出。例如 ,在前面介绍的整数运算中,当除数为零时,虚拟机会在idiv或ldiv指令中拋出ArithmeticException异常。</p><p>&emsp;而在Java虚拟机中,处理异常(catch语句)不是由字节码指令来实现的(很久之前曾经使用jsr和ret指令来实现,现在已经不用了),而是使用<strong>异常表</strong>来完成的。</p><h2 id="10-同步指令"><a href="#10-同步指令" class="headerlink" title="10. 同步指令"></a>10. 同步指令</h2><p>&emsp;Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步,这两种同步结构都是使用<strong>管程(Monitor)</strong>来支持的。</p><p>&emsp;方法级的同步是隐式的,即无须通过字节码指令来控制,它实现在方法调用和返回操作之中。虛拟机可以从方法常量池的方法表结构中的<strong>ACC_SYNCHRONIZED</strong>访问标志得知一个方法是否声明为同步方法。当方法调用时,调用指令将会检查方法的ACC_SYNCHRONIZED 访问标志是否被设置,如果设置了,执行线程就要求先成功持有管程,然后才能执行方法, 最后当方法完成(无论是正常完成还是非正常完成)时释放管程。在方法执行期间,执行线程持有了管程,其他任何线程都无法再获取到同一个管程。如果一个同步方法执行期间拋出了异常,并且在方法内部无法处理此异常,那么这个同步方法所持有的管程将在异常拋到同步方法之外时<strong>自动释放</strong>。</p><p>&emsp;同步一段指令集序列通常是由Java语言中的synchronized语句块来表示的,Java虚拟机的指令集中有<strong>monitorenter</strong>和<strong>monitorexit</strong>两条指令来支持synchronized关键字的语义,正确实现synchronized关键字需要Javac编译器与Java虚拟机两者共同协作支持。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onlyMe</span><span class="params">(Foo f)</span></span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (f)&#123;</span><br><span class="line">        doSomething();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;编译之后生成的字节码序列：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">public void onlyMe(com.jp.jvm.ch06.TestClass$Foo);</span><br><span class="line">        descriptor: (Lcom&#x2F;jp&#x2F;jvm&#x2F;ch06&#x2F;TestClass$Foo;)V</span><br><span class="line">        flags: ACC_PUBLIC</span><br><span class="line">        Code:</span><br><span class="line">        stack&#x3D;2, locals&#x3D;4, args_size&#x3D;2</span><br><span class="line">        0: aload_1                       &#x2F;&#x2F;将对象f入栈</span><br><span class="line">        1: dup                           &#x2F;&#x2F;复制栈顶元素（即f的引用）</span><br><span class="line">        2: astore_2                      &#x2F;&#x2F;将栈顶元素储存到局部变量表Slot2中</span><br><span class="line">        3: monitorenter                  &#x2F;&#x2F;已栈顶元素(f)作为锁，开始同步</span><br><span class="line">        4: aload_0                       &#x2F;&#x2F;将局部变量Slot0（即this指针）的元素入栈</span><br><span class="line">        5: invokevirtual #3              &#x2F;&#x2F;调用this.doSomething方法</span><br><span class="line">        8: aload_2                       &#x2F;&#x2F;将局部变量Slot2（即f）入栈</span><br><span class="line">        9: monitorexit                   &#x2F;&#x2F;释放f的监视器锁，退出同步</span><br><span class="line">        10: goto          18             &#x2F;&#x2F;方法正常结束，跳转到18返回  </span><br><span class="line">        13: astore_3                     &#x2F;&#x2F;从这步开始是异常路径，，见下面异常表Taget13</span><br><span class="line">        14: aload_2                      &#x2F;&#x2F;将局部变量Slot2（即f）入栈</span><br><span class="line">        15: monitorexit                  &#x2F;&#x2F;退出同步</span><br><span class="line">        16: aload_3                      &#x2F;&#x2F;将局部变量Slot3的元素（即异常对象）入栈</span><br><span class="line">        17: athrow                       &#x2F;&#x2F;把异常抛出</span><br><span class="line">        18: return                       &#x2F;&#x2F;方法正常返回</span><br><span class="line">        Exception table:                 &#x2F;&#x2F;异常表</span><br><span class="line">        from    to  target type</span><br><span class="line">        4    10    13   any</span><br><span class="line">        13    16    13   any</span><br></pre></td></tr></table></figure><br>&emsp;编译器必须确保无论方法通过何种方式完成,方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令 ,而无论这个方法是正常结束还是异常结束。</p><p>&emsp;从上面字节码序列中可以看到,为了保证在方法异常完成时momtorenter和monitorexit指令依然可以正确配对执行,编译器会自动产生一个异常处理器,这个异常处理器声明可处理所有的异常,它的目的就是用来执行momtorexit指令。</p><p>&nbsp;</p><blockquote><p>参考：<br>《深入理解Java虚拟机》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机 之 类文件结构</title>
      <link href="/java/java-jvm-class-file-struct/"/>
      <url>/java/java-jvm-class-file-struct/</url>
      
        <content type="html"><![CDATA[<h1 id="类文件结构"><a href="#类文件结构" class="headerlink" title="类文件结构"></a>类文件结构</h1><p>&emsp;代码编译的结果从本地机器码转变为字节码，是存储格式发展的一小步，却是编程语言发展的一大步。<br>&emsp;在JDK的bin目录中，Oracle公司已经为我们准备好一个专门用于分析Class文件字节码的工具：javap，使用javap工具的-verbose参数可以输出输出 class 文件字节码内容。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac TestClass.java</span><br><span class="line">javap -verbose TestClass.class</span><br></pre></td></tr></table></figure></p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;近10年来虚拟机以及大量建立在虚拟机之上的程序语言如雨后春笋般出现并蓬勃发展，将我们编写的程序编译成二进制本地机器码（Native Code）已不再是唯一的选择，越来越多的程序语言选择了与操作系统和机器指令集无关的、平台中立的格式作为程序编译后的存储格式。</p><h2 id="2-无关性的基石"><a href="#2-无关性的基石" class="headerlink" title="2. 无关性的基石"></a>2. 无关性的基石</h2><p>&emsp;Java在刚刚诞生之时曾经提出过一个非常著名的宣传口号：“一次编写，到处运行（Write Once,Run Anywhere）”，这句话充分表达了软件开发人员对冲破平台界限的渴求。在无时无刻不充满竞争的IT领域，不可能只有Wintel存在，我们也不希望只有Wintel存在，各种不同的硬件体系结构和不同的操作系统肯定会长期并存发展。“与平台无关”的理想最终实现在操作系统的应用层上：Sun公司以及其他虚拟机提供商发布了许多可以运行在各种不同平台上的虚拟机，这些虚拟机都可以载入和执行同一种平台无关的字节码，从而实现了程序的“一次编写，到处运行”。</p><p>&emsp;各种不同平台的虚拟机与所有平台都统一使用的程序存储格式——<strong>字节码（ByteCode）是构成平台无关性的基石</strong>。到目前为止，或许大部分程序员都还认为Java虚拟机执行Java程序是一件理所当然和天经地义的事情。但在Java发展之初，设计者就曾经考虑过并实现了让其他语言运行在Java虚拟机之上的可能性，他们在发布规范文档的时候，也刻意把Java的规范拆分成了Java语言规范《The Java Language Specification》及Java虚拟机规范《The Java Virtual Machine Specification》。并且在1997年发布的第一版Java虚拟机规范中就曾经承诺过：“In the future,we will consider bounded extensions to the Java virtual machine to provide better support for other languages”（在未来，我们会对Java虚拟机进行适当的扩展，以便更好地支持其他语言运行于JVM之上），当Java虚拟机发展到JDK 1.7～1.8的时候，JVM设计者通过JSR-292基本兑现了这个承诺。</p><p>&emsp;<strong>实现语言无关性的基础仍然是虚拟机和字节码存储格式</strong>。Java虚拟机不和包括Java在内的任何语言绑定，它<strong>只与“Class文件”这种特定的二进制文件格式所关联</strong>，Class文件中包含了Java虚拟机指令集和符号表以及若干其他辅助信息。基于安全方面的考虑，Java虚拟机规范要求在Class文件中使用许多强制性的语法和结构化约束，但任一门功能性语言都可以表示为一个能被Java虚拟机所接受的有效的Class文件。作为一个通用的、机器无关的执行平台，任何其他语言的实现者都可以将Java虚拟机作为语言的产品交付媒介。例如，使用Java编译器可以把Java代码编译为存储字节码的Class文件，使用JRuby等其他语言的编译器一样可以把程序代码编译成Class文件，虚拟机并不关心Class的来源是何种语言，如图6所示。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/language-independence" alt="language independent"></p><p>&emsp;Java语言中的各种变量、关键字和运算符号的语义最终都是由多条字节码命令组合而成的，因此字节码命令所能提供的语义描述能力肯定会比Java语言本身更加强大。因此，有一些Java语言本身无法有效支持的语言特性不代表字节码本身无法有效支持，这也为其他语言实现一些有别于Java的语言特性提供了基础。</p><h2 id="3-Class类文件的结构"><a href="#3-Class类文件的结构" class="headerlink" title="3. Class类文件的结构"></a>3. Class类文件的结构</h2><p>&emsp;本文关于Class文件结构的讲解中，我们将以《Java虚拟机规范（第2版）》（1999年发布，对应于JDK 1.4时代的Java虚拟机）中的定义为主线，这部分内容虽然古老，但它所包含的指令、属性是Class文件中最重要和最基础的。</p><p>&emsp;注意: <strong>任何一个Class文件都对应着唯一一个类或接口的定义信息，但反过来说，类或接口并不一定都得定义在文件里</strong>（譬如类或接口也可以通过类加载器直接生成）。本章中，笔者只是通俗地将任意一个有效的类或接口所应当满足的格式称为“Class文件格式”，实际上它并不一定以磁盘文件的形式存在。</p><p>&emsp;Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部是程序运行的必要数据，没有空隙存在。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前的方式分割成若干个8位字节进行存储。</p><p>&emsp;根据Java虚拟机规范的规定，Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构中只有两种数据类型：<strong>无符号数和表</strong>，后面的解析都要以这两种数据类型为基础，所以这里要先介绍这两个概念。</p><p>&emsp;<strong>无符号数</strong>属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值。</p><p>&emsp;<strong>表</strong>是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以“_info”结尾。表用于描述有层次关系的复合结构的数据，整个Class文件本质上就是一张表，它由表6-1所示的数据项构成。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/class-file-struct" alt="Class文件格式"></p><p>&emsp;无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个<strong>前置的容量计数器</strong>加若干个连续的数据项的形式，这时称这一系列连续的某一类型的数据为某一类型的集合。图中的数据项，无论是顺序还是数量，甚至于数据存储的字节序（Byte Ordering,Class文件中字节序为Big-Endian）这样的细节，都是被严格限定的，哪个字节代表什么含义，长度是多少，先后顺序如何，都不允许改变。</p><h3 id="3-1-魔数与Class文件的版本"><a href="#3-1-魔数与Class文件的版本" class="headerlink" title="3.1 魔数与Class文件的版本"></a>3.1 魔数与Class文件的版本</h3><p>&emsp;每个Class文件的头4个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，Class文件的魔数的获得很有“浪漫气息”，值为：0xCAFEBABE（咖啡宝贝？）</p><p>&emsp;紧接着魔数的4个字节存储的是Class文件的版本号：第5和第6个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。Java的版本号是从45开始的，JDK 1.1之后的每个JDK大版本发布主版本号向上加1（JDK 1.0～1.1使用了45.0～45.3的版本号），高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class文件，即使文件格式并未发生任何变化，虚拟机也必须拒绝执行超过其版本号的Class文件。</p><p>&emsp;例如，JDK 1.1能支持版本号为45.0～45.65535的Class文件，无法执行版本号为46.0以上的Class文件，而JDK 1.2则能支持45.0～46.65535的Class文件。现在，最新的JDK版本为1.7，可生成的Class文件主版本号最大值为51.0。</p><p>&emsp;下表列出了从JDK 1.1到JDK 1.7，主流JDK版本编译器输出的默认和可支持的Class文件版本号。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/class-file-version" alt="Class文件版本号"></p><h3 id="3-2-常量池"><a href="#3-2-常量池" class="headerlink" title="3.2 常量池"></a>3.2 常量池</h3><p>&emsp;紧接着主次版本号之后的是常量池入口，常量池可以理解为Class文件之中的资源仓库，它是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时它还是在Class文件中第一个出现的表类型数据项目。</p><p>&emsp;由于常量池中常量的数量是不固定的，所以在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值（constant_pool_count）。与Java中语言习惯不一样的是，这个<strong>容量计数是从1而不是0开始的</strong>，设计者将第0项常量空出来是有特殊考虑的，这样做的目的在于满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况就可以把索引值置为0来表示。Class文件结构中只有常量池的容量计数是从1开始，对于其他集合类型，包括接口索引集合、字段表集合、方法表集合等的容量计数都与一般习惯相同，是从0开始的。 </p><p>&emsp;常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。字面量比较接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。而符号引用则属于编译原理方面的概念，包括了下面三类常量：</p><ul><li>类和接口的全限定名（Fully Qualified Name）</li><li>字段的名称和描述符（Descriptor）</li><li>方法的名称和描述符</li></ul><p>&emsp;Java代码在进行Javac编译的时候，并不像C和C++那样有“连接”这一步骤，而是<strong>在虚拟机加载Class文件的时候进行动态连接</strong>。也就是说，在Class文件中不会保存各个方法、字段的最终内存布局信息，因此这些字段、方法的符号引用不经过运行期转换的话无法得到真正的内存入口地址，也就无法直接被虚拟机使用。当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中。</p><p>&emsp;常量池中每一项常量都是一个表,表都有一个共同的特点，就是表开始的第一位是一个u1类型的标志位（tag，取值见表6-3中标志列），代表当前这个常量属于哪种常量类型。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/constant-pool" alt="常量池的项目类型"></p><p>&emsp;每种常量类型各自均有自己的结构。我们需要根据表的第一位确定常量类型之后才能知道这个表的具体大小。比如常量池的某项常量，它的标志位（偏移地址：0x0000000A）是0x07，查表的标志列发现这个常量属于CONSTANT_Class_info类型，此类型的常量代表一个类或者接口的符号引用。CONSTANT_Class_info的结构比较简单：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/CONSTANT_Class_info" alt="CONSTANT_Class_info"></p><p>&emsp;tag是标志位，上面已经讲过了，它用于区分常量类型；name_index是一个索引值，它指向常量池中一个CONSTANT_Utf8_info类型常量，此常量代表了这个类（或者接口）的全限定名，这里name_index值（偏移地址：0x0000000B）为0x0002，也即是指向了常量池中的第二项常量。继续从图6-3中查找第二项常量，它的标志位（地址：0x0000000D）是0x01，查表6-3可知确实是一个CONSTANT_Utf8_info类型的常量。CONSTANT_Utf8_info类型的结构见表6-5。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/CONSTANT_Utf8_info" alt="CONSTANT_Utf8_info"></p><p>&emsp;length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。UTF-8缩略编码与普通UTF-8编码的区别是：从’\u0001’到’\u007f’之间的字符（相当于1～127的ASCII码）的缩略编码使用一个字节表示，从’\u0080’到’\u07ff’之间的所有字符的缩略编码用两个字节表示，从’\u0800’到’\uffff’之间的所有字符的缩略编码就按照普通UTF-8编码规则使用三个字节表示。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/constant-pool-table" alt="常量池中14种常量项的结构总表"></p><h3 id="3-3-访问标志"><a href="#3-3-访问标志" class="headerlink" title="3.3 访问标志"></a>3.3 访问标志</h3><p>&emsp;访问标志（access_flags），这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口；是否定义为public类型；是否定义为abstract类型；如果是类的话，是否被声明为final等。具体的标志位以及标志的含义见表6-7。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/access-flag.png" alt="访问标志"></p><h3 id="3-4-类索引、父类索引与接口索引集合"><a href="#3-4-类索引、父类索引与接口索引集合" class="headerlink" title="3.4 类索引、父类索引与接口索引集合"></a>3.4 类索引、父类索引与接口索引集合</h3><p>&emsp;类索引、父类索引和接口索引集合都按顺序排列在访问标志之后。<br>&emsp;类索引（this_class）和父类索引（super_class）都是一个u2类型的数据，而接口索引集合（interfaces）是一组u2类型的数据的集合，Class文件中由这三项数据来确定这个类的继承关系。类索引用于确定这个类的全限定名，父类索引用于确定这个类的父类的全限定名，接口索引集合就用来描述这个类实现了哪些接口，这些被实现的接口将按implements语句（如果这个类本身是一个接口，则应当是extends语句）后的接口顺序从左到右排列在接口索引集合中。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/class-search-name.png" alt="类索引查找全限定名过程"></p><h3 id="3-5-字段表集合"><a href="#3-5-字段表集合" class="headerlink" title="3.5 字段表集合"></a>3.5 字段表集合</h3><p>&emsp;字段表（field_info）用于描述接口或者类中声明的<strong>变量</strong>。字段（field）包括类级变量以及实例级变量，但不包括在方法内部声明的局部变量。字段叫什么名字、字段被定义为什么数据类型，这些都是无法固定的，只能引用常量池中的常量来描述。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/field_info.png" alt="字段表结构"></p><p>&emsp;字段修饰符放在access_flags项目中，它与类中的access_flags项目是非常类似的，都是一个u2的数据类型，其中可以设置的标志位和含义见表6-9。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/field_info-access-flag.png" alt="字段访问标志"></p><p>&emsp;name_index和descriptor_index。它们都是对常量池的引用，分别代表着字段的简单名称以及字段和方法的描述符。现在需要解释一下“简单名称”、“描述符”以及前面出现过多次的“全限定名”这三种特殊字符串的概念:</p><ul><li>全限定名：org/fenixsoft/clazz/TestClass</li><li>简单名称：inc</li><li>描述符：描述字段的数据类型、方法的参数列表（包括数量、类型以及顺序）和返回值。</li></ul><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/descriptor.png" alt="描述符标识字符含义"><br>&emsp;对于数组类型，每一维度将使用一个前置的“[”字符来描述，如一个定义为“java.lang.String[][]”类型的二维数组，将被记录为：“[[Ljava/lang/String；”，一个整型数组“int[]”将被记录为“[I”。</p><p>&emsp;用描述符来描述方法时，按照先参数列表，后返回值的顺序描述，参数列表按照参数的严格顺序放在一组小括号“（）”之内。如方法void inc（）的描述符为“（）V”，方法java.lang.String toString（）的描述符为“（）Ljava/lang/String；”，方法int indexOf（char[]source,int sourceOffset,int sourceCount,char[]target,int targetOffset,int targetCount,int fromIndex）的描述符为“（[CII[CIII）I”。</p><p>&emsp;字段表都包含的固定数据项目到descriptor_index为止就结束了，不过在descriptor_index之后跟随着一个属性表集合用于存储一些额外的信息，字段都可以在属性表中描述零至多项的额外信息。对于本例中的字段m，它的属性表计数器为0，也就是没有需要额外描述的信息，但是，如果将字段m的声明改为“final static int m=123；”，那就可能会存在一项名称为ConstantValue的属性，其值指向常量123。关于attribute_info的其他内容，将在6.3.7节介绍属性表的数据项目时再进一步讲解。 </p><p>&emsp;字段表集合中不会列出从超类或者父接口中继承而来的字段，但有可能列出原本Java代码之中不存在的字段，譬如在内部类中为了保持对外部类的访问性，会自动添加指向外部类实例的字段。另外，<strong>在Java语言中字段是无法重载的，两个字段的数据类型、修饰符不管是否相同，都必须使用不一样的名称，但是对于字节码来讲，如果两个字段的描述符不一致，那字段重名就是合法的</strong>。</p><h3 id="3-6-方法表集合"><a href="#3-6-方法表集合" class="headerlink" title="3.6 方法表集合"></a>3.6 方法表集合</h3><p>&emsp;Class文件存储格式中对方法的描述与对字段的描述几乎采用了完全一致的方式，方法表的结构如同字段表一样，依次包括了访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes）几项。这些数据项目的含义也非常类似，仅在访问标志和属性表集合的可选项中有所区别。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/method-table.png" alt="方法表结构"></p><p>&emsp;因为volatile关键字和transient关键字不能修饰方法，所以方法表的访问标志中没有了ACC_VOLATILE标志和ACC_TRANSIENT标志。与之相对的，synchronized、native、strictfp和abstract关键字可以修饰方法，所以方法表的访问标志中增加了ACC_SYNCHRONIZED、ACC_NATIVE、ACC_STRICTFP和ACC_ABSTRACT标志。对于方法表，所有标志位及其取值可参见表<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/method-access-flag.png" alt="方法表访问标志"></p><p>&emsp;方法里的Java代码，经过编译器编译成字节码指令后，存放在方法属性表集合中一个名为“Code”的属性里面，属性表是Class文件格式中最具扩展性的一种数据项目。</p><p>&emsp;在Java语言中，要重载（Overload）一个方法，除了要与原方法具有相同的简单名称之外，还要求必须拥有一个与原方法不同的特征签名，<strong>特征签名就是一个方法中各个参数在常量池中的字段符号引用的集合，也就是因为返回值不会包含在特征签名中，因此Java语言里面是无法仅仅依靠返回值的不同来对一个已有方法进行重载的</strong>。但是在Class文件格式中，特征签名的范围更大一些，只要描述符不是完全一致的两个方法也可以共存。也就是说，<strong>如果两个方法有相同的名称和特征签名，但返回值不同，那么也是可以合法共存于同一个Class文件中的</strong>。（<strong>Java代码的方法特征签名只包括了方法名称、参数顺序及参数类型，而字节码的特征签名还包括方法返回值以及受查异常表</strong>）。</p><h3 id="3-7-属性表集合"><a href="#3-7-属性表集合" class="headerlink" title="3.7 属性表集合"></a>3.7 属性表集合</h3><p>&emsp;在Class文件、字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息。<br>&emsp;与Class文件中其他的数据项目要求严格的顺序、长度和内容不同，属性表集合的限制稍微宽松了一些，不再要求各个属性表具有严格顺序，并且只要不与已有属性名重复，任何人实现的编译器都可以向属性表中写入自己定义的属性信息，Java虚拟机运行时会忽略掉它不认识的属性。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/attribute_info" alt="虚拟机规范预定义的属性"></p><p>&emsp;对于每个属性，它的名称需要从常量池中引用一个CONSTANT_Utf8_info类型的常量来表示，而属性值的结构则是完全自定义的，只需要通过一个u4的长度属性去说明属性值所占用的位数即可。一个符合规则的属性表应该满足表6-14中所定义的结构。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/attribute_info-struct.png" alt="属性表结构"></p><ol><li>Code属性</li></ol><p>&emsp;Java程序方法体中的代码经过Javac编译器处理后，最终变为<strong>字节码指令</strong>存储在Code属性内。Code属性出现在方法表的属性集合之中，但并非所有的方法表都必须存在这个属性，譬如接口或者抽象类中的方法就不存在Code属性，如果方法表有Code属性存在，那么它的结构将如下：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/Code.png" alt="Code属性表结构"></p><ul><li>attribute_name_index：指向CONSTANT_Utf8_info型常量的索引，常量值固定为“Code”，它代表了该属性的属性名称。</li><li>attribute_length：指示了属性值的长度，由于属性名称索引与属性长度一共为6字节，所以属性值的长度固定为整个属性表长度减去6个字节。</li><li>max_stack：操作数栈（Operand Stacks）深度的最大值。</li><li>max_locals：局部变量表所需的存储空间，单位是Slot,Slot是虚拟机为局部变量分配内存所使用的最小单位。对于byte、char、float、int、short、boolean和returnAddress等长度不超过32位的数据类型，每个局部变量占用1个Slot，而double和long这两种64位的数据类型则需要两个Slot来存放。方法参数（包括实例方法中的隐藏参数“this”）、显式异常处理器的参数（Exception Handler Parameter，就是try-catch语句中catch块所定义的异常）、方法体中定义的局部变量都需要使用局部变量表来存放。</li><li>code_length：字节码长度。为 u4 类型，理论上最大值可以达到2（32次方）-1，但是虚拟机规范中明确限制了一个方法不允许超过65535条字节码指令，即它实际只使用了u2的长度，如果超过这个限制，Javac编译器也会拒绝编译，一般一个方法很难超过这个长度，某些特殊情况，例如在编译一个很复杂的JSP文件时，某些JSP编译器会把JSP内容和页面输出的信息归并于一个方法之中，就可能因为方法生成字节码超长的原因而导致编译失败。</li><li>code：存储字节码指令的一系列字节流。为 u1 类型，最多可以表达256条指令，目前，Java虚拟机规范已经定义了其中约200条编码值对应的指令含义。</li></ul><ol><li>Exceptions属性</li></ol><p>&emsp;Exceptions属性并不是异常表，Exceptions属性的作用是<strong>列举出方法中可能抛出的受查异常</strong>（Checked Excepitons），也就是方法描述时在throws关键字后面列举的异常。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/Exceptions.png" alt="Exceptions属性表结构"></p><ol><li>LineNumberTable属性</li></ol><p>&emsp;LineNumberTable属性用于描述<strong>Java源码行号与字节码行号</strong>（字节码的偏移量）之间的对应关系。它并不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g：none或-g：lines选项来取消或要求生成这项信息。如果选择不生成LineNumberTable属性，对程序运行产生的最主要的影响就是当抛出异常时，堆栈中将不会显示出错的行号，并且在调试程序的时候，也无法按照源码行来设置断点。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/LineNumberTable.png" alt="LineNumberTable属性表结构"></p><p>示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">LineNumberTable:</span><br><span class="line">line 3: 0</span><br></pre></td></tr></table></figure><br>前者是字节码行号，后者是Java源码行号。</p><ol><li>LocalVariableTable属性</li></ol><p>&emsp;LocalVariableTable属性用于描述<strong>栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系</strong>，它也不是运行时必需的属性，但默认会生成到Class文件之中，可以在Javac中分别使用-g：none或-g：vars选项来取消或要求生成这项信息。如果没有生成这项属性，最大的影响就是当其他人引用这个方法时，所有的参数名称都将会丢失，IDE将会使用诸如arg0、arg1之类的占位符代替原有的参数名，这对程序运行没有影响，但是会对代码编写带来较大不便，而且在调试期间无法根据参数名称从上下文中获得参数值。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/LocalVariableTable.png" alt="LocalVariableTable属性表结构"></p><ol><li>SourceFile属性</li></ol><p>&emsp;SourceFile属性用于记录生成这个<strong>Class文件的源码文件名称</strong>。这个属性也是可选的，可以分别使用Javac的-g：none或-g：source选项来关闭或要求生成这项信息。在Java中，对于大多数的类来说，类名和文件名是一致的，但是有一些特殊情况（如内部类）例外。如果不生成这项属性，当抛出异常时，堆栈中将不会显示出错代码所属的文件名。这个属性是一个定长的属性。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/LocalVariableTable.png" alt="SourceFile属性表结构"></p><ol><li>ConstantValue属性</li></ol><p>&emsp;ConstantValue属性的作用是<strong>通知虚拟机自动为静态变量赋值</strong>。只有被<strong>static</strong>关键字修饰的变量（类变量）才可以使用这项属性。类似“int x=123”和“static int x=123”这样的变量定义在Java程序中是非常常见的事情，但虚拟机对这两种变量赋值的方式和时刻都有所不同。对于非static类型的变量（也就是实例变量）的赋值是在实例构造器＜init＞方法中进行的；而对于类变量，则有两种方式可以选择：在类构造器＜clinit＞方法中或者使用ConstantValue属性。目前Sun Javac编译器的选择是：如果同时使用<strong>final和static</strong>来修饰一个变量（按照习惯，这里称“常量”更贴切），并且这个变量的数据类型是基本类型或者java.lang.String的话，就生成ConstantValue属性来进行初始化，如果这个变量没有被<strong>final</strong>修饰，或者并非基本类型及字符串，则将会选择在＜clinit＞方法中进行初始化。</p><p>&emsp;虽然有<strong>final</strong>关键字才更符合“ConstantValue”的语义，但虚拟机规范中并没有强制要求字段必须设置了ACC_FINAL标志，只要求了有ConstantValue属性的字段必须设置ACC_STATIC标志而已，对final关键字的要求是Javac编译器自己加入的限制。而对ConstantValue的属性值只能限于基本类型和String。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/ConstantValue.png" alt="ConstantValue属性表结构"></p><ol><li>InnerClasses属性</li></ol><p>&emsp;InnerClasses属性用于记录<strong>内部类与宿主类之间的关联</strong>。如果一个类中定义了内部类，那编译器将会为它以及它所包含的内部类生成InnerClasses属性。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/InnerClasses.png" alt="InnerClasses属性表结构"><br>数据项number_of_classes代表需要记录多少个内部类信息，每一个内部类的信息都由一个inner_classes_info表进行描述。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/inner_classes_info.png" alt="inner_classes_info表结构"></p><ol><li>Deprecated及Synthetic属性</li></ol><p>&emsp;Deprecated和Synthetic两个属性都属于标志类型的布尔属性，只存在有和没有的区别，没有属性值的概念。<br>&emsp;Deprecated属性用于表示某个类、字段或者方法，已经被程序作者定为<strong>不再推荐使用</strong>，它可以通过在代码中使用@deprecated注释进行设置。</p><p>&emsp;Synthetic属性代表此<strong>字段或者方法并不是由Java源码直接产生的</strong>，而是由编译器自行添加的，在JDK 1.5之后，标识一个类、字段或者方法是编译器自动产生的，也可以设置它们访问标志中的ACC_SYNTHETIC标志位，其中最典型的例子就是Bridge Method。所有由非用户代码产生的类、方法及字段都应当至少设置Synthetic属性和ACC_SYNTHETIC标志位中的一项，唯一的例外是实例构造器“＜init＞”方法和类构造器“＜clinit＞”方法。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/Deprecated-Synthetic.png" alt="Deprecated及Synthetic属性表结构"></p><ol><li>StackMapTable属性</li></ol><p>&emsp;这个属性会在虚拟机类加载的字节码验证阶段被新类型检查验证器（Type Checker）使用（见7.3.2节），目的在于代替以前比较消耗性能的基于数据流分析的类型推导验证器。<br>&emsp;具体来说，在类加载的验证阶段，由于数据流验证的高复杂性，虚拟机设计团队为了避免过多的时间消耗在字节码验证阶段，在JDK1.6之后的 Javac编译器和 Java 虚拟机中进行了一项优化，给方法体的 Code 属性的属性表中增加了一项名为”StackMapTable”的属性，这项属性描述了方法体中所有基本块(Basic Block，按照控制流拆分的代码块)开始时本地变量表和操作数栈应有的状态，在字节码验证期间，就不需要根据程序推导这些状态的合法性，只需要检查 StackMapTable 属性中的记录是否合法即可，这样将字节码验证的类型推导转变为类型检查从而节省一些时间。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/StackMapTable.png" alt="StackMapTable属性表结构"></p><ol><li>Signature属性</li></ol><p>&emsp;Signature是一个可选的定长属性，可以出现于类、属性表和方法表结构的属性表中。任何类、接口、初始化方法或成员的泛型签名如果包含了类型变量（Type Variables）或参数化类型（Parameterized Types），则Signature属性会为它记录泛型签名信息。之所以要专门使用这样一个属性去 <strong>记录泛型类型</strong>，是因为Java语言的泛型采用的是 <strong>擦除法实现的伪泛型</strong>，在字节码（Code属性）中，泛型信息编译（类型变量、参数化类型）之后都通通被擦除掉。使用擦除法的好处是实现简单（主要修改Javac编译器，虚拟机内部只做了很少的改动）、非常容易实现Backport，运行期也能够节省一些类型所占的内存空间。但坏处是运行期就无法像C#等有真泛型支持的语言那样，将泛型类型与用户定义的普通类型同等对待，例如<strong>运行期做反射时无法获得到泛型信息。Signature属性就是为了弥补这个缺陷而增设的，现在Java的反射API能够获取泛型类型，最终的数据来源也就是这个属性</strong>。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/Signature.png" alt="Signature属性表结构"></p><ol><li>BootstrapMethods属性</li></ol><p>&emsp;BootstrapMethods是一个复杂的变长属性，位于类文件的属性表中。这个属性用于保存invokedynamic指令引用的引导方法限定符。《Java虚拟机规范（Java SE 7版）》规定，如果某个类文件结构的常量池中曾经出现过CONSTANT_InvokeDynamic_info类型的常量，那么这个类文件的属性表中必须存在一个明确的BootstrapMethods属性，另外，即使CONSTANT_InvokeDynamic_info类型的常量在常量池中出现过多次，类文件的属性表中最多也只能有一个BootstrapMethods属性。<br>BootstrapMethods属性与JSR-292中的InvokeDynamic指令和java.lang.Invoke包关系非常密切，要介绍这个属性的作用，必须先弄清楚 <strong>InovkeDynamic</strong>指令的运作原理。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/class/BootstrapMethods.png" alt="BootstrapMethods属性表结构"></p><p>&nbsp;</p><blockquote><p>参考：<br>《深入理解Java虚拟机》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机 之 内存分配与回收策略</title>
      <link href="/java/java-jvm-memory-allocate-and-collection-policy/"/>
      <url>/java/java-jvm-memory-allocate-and-collection-policy/</url>
      
        <content type="html"><![CDATA[<h1 id="内存分配与回收策略"><a href="#内存分配与回收策略" class="headerlink" title="内存分配与回收策略"></a>内存分配与回收策略</h1><p>&emsp;Java技术体系中所提倡的自动内存管理最终可以归结于为了自动化的解决两个问题：<strong>给对象分配内存</strong>和<strong>回收分配给对象的内存</strong>。<br>对象的内存分配，往大的方向上讲，就是在堆上分配(但也可能经过JIT编译后被拆散为标量类型并间接地在栈上分配)，对象主要分配在新生代的Eden区上，如果启动了本地线程分配缓冲，将按线程优先在TLAB上分配。少数情况下也可能会直接分配在老年代中，分配的规则并不是百分之百固定的，其细节决定于当前使用的是哪种垃圾收集器组合，当然还有虚拟机中与内存相关的参数。<br>&emsp;本文介绍几条最普遍的内存分配规则。</p><h2 id="1-对象优先在Eden分配"><a href="#1-对象优先在Eden分配" class="headerlink" title="1. 对象优先在Eden分配"></a>1. 对象优先在Eden分配</h2><p>&emsp;大多数情况下，对象在新生代Eden区中分配。当Eden区没有足够的空间进行分配时，虚拟机将发起一次Minor GC。<br>&emsp;注意区分一下以下两种GC：</p><ul><li>新生代GC（Minor GC）：指发生在新生代的垃圾收集动作，因为Java对象大多具备朝生夕灭的特性，所以 Minor GC 非常频繁，一般回收速度也比较快。</li><li>老年代GC（Major GC/Full GC）：指发生在老年代的 GC，出现了 Major GC，经常会伴随至少一次 Minor GC（不绝对，Parallel Scavenge收集器的收集策略就有直接进行 Major GC 的策略选择过程）。Major GC 的速度一般会比 Minor GC 慢 10 倍以上。</li></ul><h2 id="2-大对象直接进入老年代"><a href="#2-大对象直接进入老年代" class="headerlink" title="2. 大对象直接进入老年代"></a>2. 大对象直接进入老年代</h2><p>&emsp;所谓的大对象是指，需要大量连续内存空间的Java对象，最典型的大对象就是那种很长的字符串及数组。<strong>大对象对虚拟机的内存分配来说就是一个坏消息（比遇到一个大对象更加坏的消息就是遇到一群”朝生夕灭“的”短命的大对象“)</strong>，所以写程序时应避免在频繁调用的方法中创建大对象），经常出现大对象容易导致内存还有不少空间时就提前出发垃圾回收以获取足够的连续空间来“安置”它们。<br>&emsp;虚拟机提供一个 -XX:PretenureSizeThreshold 参数，大于这个设置的对象会直接在老年代分配。这样做的目的是为了避免在Eden区和两个Survivor区之间发生大量的内存复制(新生代采用复制算法收集内存)。<br>&emsp;虚拟机参数配置示例：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">“-XX:+PrintGCDetails -Xms20M -Xmx20M -Xmn10M -XX:SurvivorRatio&#x3D;8 -XX:PretenureSizeThreshold&#x3D;3145728”</span><br></pre></td></tr></table></figure></p><ul><li>-XX:+PrintGCDetails：打印内存回收日志</li><li>-Xms：Java堆大小</li><li>-Xmx: Java堆最大可扩展大小</li><li>-Xmn：给新生代分配的堆内存，剩下的分配给老年代</li><li>-XX:SurvivorRatio：决定新生代 Survivor 区和 Eden 区的比例，8 表示Eden：Survivor为8：1</li><li>-XX:PretenureSizeThreshold：大小超过这个阈值的对象直接在老年代分配</li></ul><h2 id="3-长期存活的对象将进入老年代"><a href="#3-长期存活的对象将进入老年代" class="headerlink" title="3. 长期存活的对象将进入老年代"></a>3. 长期存活的对象将进入老年代</h2><p>&emsp;既然虚拟机采用了分代收集的思想来管理内存，那内存回收时就必须能识别哪些对象应放入新生代，那些应放入老年代中。为了做到这一点，虚拟机为每个对象定义了一个年龄（Age）计数器。如果对象在 Eden 出生并经过了一次 Minor GC 后仍然存活，并且能被 Survivor区域容纳，将被移动至Survivor空间中，并且age设置为1，对象在 Survivor 区中每“熬过”一次 Minor GC 后，age都会加1，当年龄达到一定程度（默认是15）时，就会晋升到老年代中。对象晋升到老年代的年龄阈值，可以通过参数  -XX:MaxTenuringThreshold 设置。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-Xms20M -Xmx20M -Xmn10M </span><br><span class="line">-XX:SurvivorRatio&#x3D;8 </span><br><span class="line">XX:+PrintGCDetails</span><br><span class="line">-XX:+UseSerialGC</span><br><span class="line">-XX:MaxTenuringThreshold&#x3D;1</span><br><span class="line">-XX:+PrintTenuringDistribution</span><br></pre></td></tr></table></figure></p><h2 id="4-动态对象年龄判定"><a href="#4-动态对象年龄判定" class="headerlink" title="4. 动态对象年龄判定"></a>4. 动态对象年龄判定</h2><p>&emsp;为了能更好的适应不同程序的内存状况，虚拟机并不总是要求对象必须达到一定年龄才能晋升老年代，如果Survivor空间中相同年龄的对象大小超过Survivor空间的一半，年龄大于或者等于改年龄的对象就可以直接进入老年代中，无需等到特定要求的年龄。</p><h2 id="5-空间分配担保"><a href="#5-空间分配担保" class="headerlink" title="5. 空间分配担保"></a>5. 空间分配担保</h2><p>&emsp;在发生Minor GC时，虚拟机会检测之前每次晋升到老年代的平均大小是否大于老年代中的剩余空间大小，如果大于，则改为直接进行一次Full GC。如果小于，则查看设置是否允许担保失败：如果允许，那先尝试进行一次 Minor GC，尽管这次 Minor GC 是有风险的；如果不允许，则要改为进行一次Full GC。<br>&emsp;新生代使用复制收集算法，但为了内存利用率，只使用其中一个Survivor空间来作为轮换备份，因此当出现大量对象在Minor GC后仍然存活的情况（最极端的就是内存回收后新生代中的所有对象都存活），Survivor空间无法容纳所有的存活对象，就需要老年代进行分配担保，把Survivor无法容纳的对象直接进入老年代。<br>&emsp;取平均值进行比较其实仍然是一种动态概率的手段，也就是说，如果某次Minor GC存活后的对象突增，远远高于平均值的话，依然会导致担保失败（Handle Promotion Failure），如果出现了担保失败，那就只好再失败后重新发起一次Full GC。虽然担保失败失败绕的圈子是最大的，但大部分情况下都还是会把 -XX:+HandlePromotionFailure 开关打开，避免 Full GC 过于频繁。<br>&emsp;需要注意的是，在 JDK6 Update 24 之后规则变为<strong>只要老年代的连续空间大于新生代对象总大小或者历次晋升的平均大小就会进行 Minor GC，否则将进行 Full GC</strong>。虽然源码中还定义了 HandlePromotionFailure 参数，但是在代码中已经不会再使用它了。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Annotation</title>
      <link href="/java/java-annotation/"/>
      <url>/java/java-annotation/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-Annotation"><a href="#Java-Annotation" class="headerlink" title="Java Annotation"></a>Java Annotation</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;Java 注解（Annotation）又称 Java 标注，是 JDK5.0 引入的一种注释机制。<br>&emsp;Java 语言中的类、方法、变量、参数和包等都可以被标注。和 Javadoc 不同，Java 标注可以通过反射获取标注内容。在编译器生成类文件时，标注可以被嵌入到字节码中。Java 虚拟机可以保留标注内容，在运行时可以获取到标注内容 。 当然它也支持自定义 Java 标注。</p><p>&emsp;Java 内置定义了一套注解，共有 7 个，3 个在 java.lang 中，剩下 4 个在 java.lang.annotation 中。</p><p>&emsp;作用在代码的注解是：</p><ul><li>@Override - 检查该方法是否是重载方法。如果发现其父类，或者是引用的接口中并没有该方法时，会报编译错误。</li><li>@Deprecated - 标记过时方法。如果使用该方法，会报编译警告。</li><li>@SuppressWarnings - 指示编译器去忽略注解中声明的警告。</li></ul><p>&emsp;作用在其他注解的注解(或者说 元注解)是:</p><ul><li>@Retention - 标识这个注解怎么保存，是只在代码中，还是编入class文件中，或者是在运行时可以通过反射访问。</li><li>@Documented - 标记这些注解是否包含在用户文档中。</li><li>@Target - 标记这个注解应该是哪种 Java 成员。</li><li>@Inherited - 标记这个注解是继承于哪个注解类(默认 注解并没有继承于任何子类)</li></ul><p>&emsp;从 Java 7 开始，额外添加了 3 个注解:</p><ul><li>@SafeVarargs - Java 7 开始支持，忽略任何使用参数为泛型变量的方法或构造函数调用产生的警告。</li><li>@FunctionalInterface - Java 8 开始支持，标识一个匿名函数或函数式接口。</li><li>@Repeatable - Java 8 开始支持，标识某注解可以在同一个声明上使用多次</li></ul><h2 id="2-Annotation-架构"><a href="#2-Annotation-架构" class="headerlink" title="2. Annotation 架构"></a>2. Annotation 架构</h2><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/annotation.jpg" alt="Annotation架构"></p><p>&emsp;从中，我们可以看出：</p><ul><li>1 个 Annotation 和 1 个 RetentionPolicy 关联。<br>可以理解为：每1个Annotation对象，都会有唯一的RetentionPolicy属性。</li><li>1 个 Annotation 和 1~n 个 ElementType 关联。<br>可以理解为：对于每 1 个 Annotation 对象，可以有若干个 ElementType 属性。</li><li>Annotation 有许多实现类，包括：Deprecated, Documented, Inherited, Override 等等。</li></ul><p>&emsp;Annotation 的每一个实现类，都 “和 1 个 RetentionPolicy 关联” 并且 “ 和 1~n 个 ElementType 关联”。<br>&emsp;图的左半部分是 Annotation 的组成部分，右半部分是 Annotation 的实现类。</p><h2 id="3-Annotation-组成部分"><a href="#3-Annotation-组成部分" class="headerlink" title="3. Annotation 组成部分"></a>3. Annotation 组成部分</h2><p>&emsp;Java Annotation 的组成中，有 3 个非常重要的主干类。它们分别是：</p><h3 id="3-1-Annotation-java"><a href="#3-1-Annotation-java" class="headerlink" title="3.1 Annotation.java"></a>3.1 Annotation.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Annotation</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hashCode</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">String <span class="title">toString</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    Class&lt;? extends Annotation&gt; annotationType();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;Annotation 就是个接口。<br>&emsp;”每 1 个 Annotation” 都与 “1 个 RetentionPolicy” 关联，并且与 “1～n 个 ElementType” 关联。可以通俗的理解为：每 1 个 Annotation 对象，都会有唯一的 RetentionPolicy 属性；至于 ElementType 属性，则有 1~n 个。</p><h3 id="3-2-ElementType-java"><a href="#3-2-ElementType-java" class="headerlink" title="3.2 ElementType.java"></a>3.2 ElementType.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> ElementType &#123;</span><br><span class="line">    TYPE,               <span class="comment">/* 类、接口（包括注释类型）或枚举声明  */</span></span><br><span class="line"></span><br><span class="line">    FIELD,              <span class="comment">/* 字段声明（包括枚举常量）  */</span></span><br><span class="line"></span><br><span class="line">    METHOD,             <span class="comment">/* 方法声明  */</span></span><br><span class="line"></span><br><span class="line">    PARAMETER,          <span class="comment">/* 参数声明  */</span></span><br><span class="line"></span><br><span class="line">    CONSTRUCTOR,        <span class="comment">/* 构造方法声明  */</span></span><br><span class="line"></span><br><span class="line">    LOCAL_VARIABLE,     <span class="comment">/* 局部变量声明  */</span></span><br><span class="line"></span><br><span class="line">    ANNOTATION_TYPE,    <span class="comment">/* 注释类型声明  */</span></span><br><span class="line"></span><br><span class="line">    PACKAGE             <span class="comment">/* 包声明  */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;ElementType 是 Enum 枚举类型，它用来指定 Annotation 的类型，表示该注解可以用来修饰什么，如类、方法、属性等。<br>&emsp;”每 1 个 Annotation” 都与 “1～n 个 ElementType” 关联。当 Annotation 与某个 ElementType 关联时，就意味着：Annotation有了某种用途。例如，若一个 Annotation 对象是 METHOD 类型，则该 Annotation 只能用来修饰方法。</p><h3 id="3-3-RetentionPolicy-java"><a href="#3-3-RetentionPolicy-java" class="headerlink" title="3.3 RetentionPolicy.java"></a>3.3 RetentionPolicy.java</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> java.lang.annotation;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">enum</span> RetentionPolicy &#123;</span><br><span class="line">    SOURCE,            <span class="comment">/* Annotation信息仅存在于编译器处理期间，编译器处理完之后就没有该Annotation信息了  */</span></span><br><span class="line"></span><br><span class="line">    CLASS,             <span class="comment">/* 编译器将Annotation存储于类对应的.class文件中。默认行为  */</span></span><br><span class="line"></span><br><span class="line">    RUNTIME            <span class="comment">/* 编译器将Annotation存储于class文件中，并且可由JVM读入 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;RetentionPolicy 是 Enum 枚举类型，它用来指定 Annotation 的策略。通俗点说，就是不同 RetentionPolicy 类型的 Annotation 的作用域不同。<br>“每 1 个 Annotation” 都与 “1 个 RetentionPolicy” 关联。</p><ul><li>a) 若 Annotation 的类型为 SOURCE，则意味着：Annotation 仅存在于编译器处理期间，编译器处理完之后，该 Annotation 就没用了。 例如，” @Override” 标志就是一个 Annotation。当它修饰一个方法的时候，就意味着该方法覆盖父类的方法；并且在编译期间会进行语法检查！编译器处理完后，”@Override” 就没有任何作用了。</li><li>b) 若 Annotation 的类型为 CLASS，则意味着：编译器将 Annotation 存储于类对应的 .class 文件中，它是 Annotation 的默认行为。</li><li>c) 若 Annotation 的类型为 RUNTIME，则意味着：编译器将 Annotation 存储于 class 文件中，并且可由JVM读入，会在运行时起作用。</li></ul><h2 id="4-Annotation-实现类"><a href="#4-Annotation-实现类" class="headerlink" title="4. Annotation 实现类"></a>4. Annotation 实现类</h2><p>&emsp;&emsp;理解了上面的3个类的作用之后，我们接下来可以讲解Annotation实现类的语法定义了。</p><h3 id="4-1-Annotation-通用定义"><a href="#4-1-Annotation-通用定义" class="headerlink" title="4.1 Annotation 通用定义"></a>4.1 Annotation 通用定义</h3><p>我们可以这样定义一个注解：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> "Hello"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;上面的作用是定义一个 Annotation，它的名字是 MyAnnotation1。定义了 MyAnnotation1 之后，我们可以在代码中通过 “@MyAnnotation1” 来使用它。 其它的，@Documented, @Target, @Retention, @interface 都是来修饰 MyAnnotation1 的。下面分别说说它们的含义：</p><ol><li>@interface</li></ol><p>&emsp;使用 @interface 定义注解时，意味着它实现了 java.lang.annotation.Annotation 接口，即该注解就是一个Annotation。<br>定义 Annotation 时，@interface 是必须的。<br>注意：它和我们通常的 implemented 实现接口的方法不同。Annotation 接口的实现细节都由编译器完成。通过 @interface 定义注解后，该注解不能继承其他的注解或接口。</p><ol><li>@Documented</li></ol><p>&emsp;类和方法的注释在缺省情况下是不出现在 javadoc 中的。如果使用 @Documented 修饰该 Annotation，则表示它可以出现在 javadoc 中。<br>定义 Annotation 时，@Documented 可有可无；若没有定义，则 注释不会出现在 javadoc 中。</p><ol><li>@Target(ElementType.TYPE)</li></ol><p>&emsp;前面我们说过，ElementType 是 Annotation 的类型属性。而 @Target 的作用，就是来指定 Annotation 的类型属性。<br>@Target(ElementType.TYPE) 的意思就是指定该 Annotation 的类型是 ElementType.TYPE。这就意味着，MyAnnotation1 是来修饰”类、接口（包括注释类型）或枚举声明”的注解。<br>定义 Annotation 时，@Target 可有可无。若有 @Target，则该 Annotation 只能用于它所指定的地方；若没有 @Target，则该 Annotation 可以用于任何地方。</p><ol><li>@Retention(RetentionPolicy.RUNTIME)</li></ol><p>&emsp;前面我们说过，RetentionPolicy 是 Annotation 的策略属性，而 @Retention 的作用，就是指定 Annotation 的策略属性。<br>@Retention(RetentionPolicy.RUNTIME) 的意思就是指定该 Annotation 的策略是 RetentionPolicy.RUNTIME。这就意味着，编译器会将该 Annotation 信息保留在 .class 文件中，并且能被虚拟机读取。<br>定义 Annotation 时，@Retention 可有可无。若没有 @Retention，则默认是 RetentionPolicy.CLASS。</p><h3 id="4-2-Java-自带的-Annotation"><a href="#4-2-Java-自带的-Annotation" class="headerlink" title="4.2 Java 自带的 Annotation"></a>4.2 Java 自带的 Annotation</h3><p>&emsp;通过上面的示例，我们能理解：@interface 用来声明 Annotation，@Documented 用来表示该 Annotation 是否会出现在 javadoc 中， @Target 用来指定 Annotation 的类型，@Retention 用来指定 Annotation 的策略。</p><p>&emsp;java 常用的 Annotation：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">@Deprecated  -- @Deprecated 所标注内容，不再被建议使用。</span><br><span class="line">@Override    -- @Override 只能标注方法，表示该方法覆盖父类中的方法。</span><br><span class="line">@Documented  -- @Documented 所标注内容，可以出现在javadoc中。</span><br><span class="line">@Inherited   -- @Inherited只能被用来标注“Annotation类型”，它所标注的Annotation具有继承性，父类的Annotation可以被子类继承。</span><br><span class="line">@Retention   -- @Retention只能被用来标注“Annotation类型”，而且它被用来指定Annotation的RetentionPolicy属性。</span><br><span class="line">@Target      -- @Target只能被用来标注“Annotation类型”，而且它被用来指定Annotation的ElementType属性。</span><br><span class="line">@SuppressWarnings -- @SuppressWarnings 所标注内容产生的警告，编译器会对这些警告保持静默。</span><br></pre></td></tr></table></figure></p><ol><li>@Deprecated<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(value=&#123;CONSTRUCTOR, FIELD, LOCAL_VARIABLE, METHOD, PACKAGE, PARAMETER, TYPE&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Deprecated &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&emsp;若某个方法被 @Deprecated 标注，则该方法不再被建议使用。如果有开发人员试图使用或重写被 @Deprecated 标示的方法，编译器会给相应的提示信息。示例如下:<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/annotation-Deprecated.jpg" alt=""></li></ol><ol><li><p>@Inherited</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Target</span>(ElementType.ANNOTATION_TYPE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Inherited &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;假设，我们定义了某个 Annotaion，它的名称是 MyAnnotation，并且 MyAnnotation 被标注为 @Inherited。现在，某个类 Base 使用了MyAnnotation，则 Base 具有了”具有了注解 MyAnnotation”；现在，Sub 继承了 Base，由于 MyAnnotation 是 @Inherited的(具有继承性)，所以，Sub 也 “具有了注解 MyAnnotation”。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 自定义的Annotation。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@Inherited</span></span><br><span class="line"><span class="meta">@interface</span> Inheritable</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Inheritable</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">InheritableFather</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InheritableFather</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// InheritableBase是否具有 Inheritable Annotation</span></span><br><span class="line">        System.out.println(<span class="string">"InheritableFather:"</span>+InheritableFather<span class="class">.<span class="keyword">class</span>.<span class="title">isAnnotationPresent</span>(<span class="title">Inheritable</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * InheritableSon 类只是继承于 InheritableFather，</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableSon</span> <span class="keyword">extends</span> <span class="title">InheritableFather</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">InheritableSon</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>();    <span class="comment">// 调用父类的构造函数</span></span><br><span class="line">        <span class="comment">// InheritableSon类是否具有 Inheritable Annotation</span></span><br><span class="line">        System.out.println(<span class="string">"InheritableSon:"</span>+InheritableSon<span class="class">.<span class="keyword">class</span>.<span class="title">isAnnotationPresent</span>(<span class="title">Inheritable</span>.<span class="title">class</span>))</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        InheritableSon is = <span class="keyword">new</span> InheritableSon();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;运行结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">InheritableFather:<span class="keyword">true</span></span><br><span class="line">InheritableSon:<span class="keyword">true</span>  <span class="comment">//如果去掉Inheritable的@Inherited，则为false</span></span><br></pre></td></tr></table></figure></li><li><p>@SuppressWarnings</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(&#123;TYPE, FIELD, METHOD, PARAMETER, CONSTRUCTOR, LOCAL_VARIABLE&#125;)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> SuppressWarnings &#123;</span><br><span class="line">    String[] value();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;SuppressWarnings 的作用是，让编译器对”它所标注的内容”的某些警告保持静默。例如，”@SuppressWarnings(value={“deprecation”, “unchecked”})” 表示对”它所标注的内容”中的 “SuppressWarnings 不再建议使用警告”和”未检查的转换时的警告”保持沉默。示例如下：</p></li></ol><p><img src="https://gitee.com/JP6907/Pic/raw/master/javaannotation-SuppressWarnings1.jpg" alt=""><br><img src="https://gitee.com/JP6907/Pic/raw/master/java/annotation-SuppressWarnings2.jpg" alt=""></p><p>&emsp;如果没有使用 @SuppressWarnings(value={“deprecation”}) , 而 Date 属于 java 不再建议使用的类。因此，调用 Date 的 API 时，会产生警告。如果使用了 @SuppressWarnings(value={“deprecation”})。编译器对”调用 Date 的 API 产生的警告”保持沉默。</p><p>&emsp;SuppressWarnings 常用的关键字的表格：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">deprecation  -- 使用了不赞成使用的类或方法时的警告</span><br><span class="line">unchecked    -- 执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型。</span><br><span class="line">fallthrough  -- 当 Switch 程序块直接通往下一种情况而没有 Break 时的警告。</span><br><span class="line">path         -- 在类路径、源文件路径等中有不存在的路径时的警告。</span><br><span class="line">serial       -- 当在可序列化的类上缺少 serialVersionUID 定义时的警告。</span><br><span class="line">finally      -- 任何 finally 子句不能正常完成时的警告。</span><br><span class="line">all          -- 关于以上所有情况的警告。</span><br></pre></td></tr></table></figure></p><ol><li>@Override<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Target</span>(ElementType.METHOD)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.SOURCE)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> Override &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&emsp;若某个方法被 @Override 的标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被 @Override 标示，但父类中却没有”被 @Override 标注”的同名方法，则编译器会报错。</li></ol><h2 id="4-Annotation-的作用"><a href="#4-Annotation-的作用" class="headerlink" title="4. Annotation 的作用"></a>4. Annotation 的作用</h2><p>&emsp;Annotation 是一个辅助类，它在 Junit、Struts、Spring 等工具框架中被广泛使用。<br>&emsp;我们在编程中经常会使用到的 Annotation 作用有：</p><h3 id="4-1-编译检查"><a href="#4-1-编译检查" class="headerlink" title="4.1 编译检查"></a>4.1 编译检查</h3><p>&emsp;Annotation 具有”让编译器进行编译检查的作用”。<br>例如，@SuppressWarnings, @Deprecated 和 @Override 都具有编译检查作用。</p><ol><li>关于 @SuppressWarnings 和 @Deprecated，已经在”第3部分”中详细介绍过了。这里就不再举例说明了。</li><li>若某个方法被 @Override 的标注，则意味着该方法会覆盖父类中的同名方法。如果有方法被 @Override 标示，但父类中却没有”被 @Override 标注”的同名方法，则编译器会报错。</li></ol><h3 id="4-2-在反射中使用-Annotation"><a href="#4-2-在反射中使用-Annotation" class="headerlink" title="4.2 在反射中使用 Annotation"></a>4.2 在反射中使用 Annotation</h3><p>&emsp;在反射的 Class, Method, Field 等函数中，有许多于 Annotation 相关的接口。</p><p>&emsp;这也意味着，我们可以在反射中解析并使用 Annotation。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.lang.annotation.Annotation;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Target;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.ElementType;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Retention;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.RetentionPolicy;</span><br><span class="line"><span class="keyword">import</span> java.lang.annotation.Inherited;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Annotation在反射函数中的使用示例</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="meta">@interface</span> MyAnnotation &#123;</span><br><span class="line">    String[] value() <span class="keyword">default</span> <span class="string">"unknown"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Person类。它会使用MyAnnotation注解。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * empty()方法同时被 "<span class="doctag">@Deprecated</span>" 和 "<span class="doctag">@MyAnnotation</span>(value=&#123;"a","b"&#125;)"所标注 </span></span><br><span class="line"><span class="comment">     * (01) <span class="doctag">@Deprecated</span>，意味着empty()方法，不再被建议使用</span></span><br><span class="line"><span class="comment">     * (02) <span class="doctag">@MyAnnotation</span>, 意味着empty() 方法对应的MyAnnotation的value值是默认值"unknown"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span></span><br><span class="line">    <span class="meta">@Deprecated</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">empty</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\nempty"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * sombody() 被 <span class="doctag">@MyAnnotation</span>(value=&#123;"girl","boy"&#125;) 所标注，</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@MyAnnotation</span>(value=&#123;"girl","boy"&#125;), 意味着MyAnnotation的value值是&#123;"girl","boy"&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@MyAnnotation</span>(value=&#123;<span class="string">"girl"</span>,<span class="string">"boy"</span>&#125;)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">somebody</span><span class="params">(String name, <span class="keyword">int</span> age)</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"\nsomebody: "</span>+name+<span class="string">", "</span>+age);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AnnotationTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 新建Person</span></span><br><span class="line">        Person person = <span class="keyword">new</span> Person();</span><br><span class="line">        <span class="comment">// 获取Person的Class实例</span></span><br><span class="line">        Class&lt;Person&gt; c = Person<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        Method mSomebody = c.getMethod(<span class="string">"somebody"</span>, <span class="keyword">new</span> Class[]&#123;String<span class="class">.<span class="keyword">class</span>, <span class="title">int</span>.<span class="title">class</span>&#125;)</span>;</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mSomebody.invoke(person, <span class="keyword">new</span> Object[]&#123;<span class="string">"lily"</span>, <span class="number">18</span>&#125;);</span><br><span class="line">        iteratorAnnotations(mSomebody);</span><br><span class="line">        </span><br><span class="line"></span><br><span class="line">        <span class="comment">// 获取 somebody() 方法的Method实例</span></span><br><span class="line">        Method mEmpty = c.getMethod(<span class="string">"empty"</span>, <span class="keyword">new</span> Class[]&#123;&#125;);</span><br><span class="line">        <span class="comment">// 执行该方法</span></span><br><span class="line">        mEmpty.invoke(person, <span class="keyword">new</span> Object[]&#123;&#125;);        </span><br><span class="line">        iteratorAnnotations(mEmpty);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">iteratorAnnotations</span><span class="params">(Method method)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 判断 somebody() 方法是否包含MyAnnotation注解</span></span><br><span class="line">        <span class="keyword">if</span>(method.isAnnotationPresent(MyAnnotation<span class="class">.<span class="keyword">class</span>))</span>&#123;</span><br><span class="line">            <span class="comment">// 获取该方法的MyAnnotation注解实例</span></span><br><span class="line">            MyAnnotation myAnnotation = method.getAnnotation(MyAnnotation<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            <span class="comment">// 获取 myAnnotation的值，并打印出来</span></span><br><span class="line">            String[] values = myAnnotation.value();</span><br><span class="line">            <span class="keyword">for</span> (String str:values)</span><br><span class="line">                System.out.printf(str+<span class="string">", "</span>);</span><br><span class="line">            System.out.println();</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 获取方法上的所有注解，并打印出来</span></span><br><span class="line">        Annotation[] annotations = method.getAnnotations();</span><br><span class="line">        <span class="keyword">for</span>(Annotation annotation : annotations)&#123;</span><br><span class="line">            System.out.println(annotation);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">somebody: lily, 18</span><br><span class="line">girl, boy, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value&#x3D;[girl, boy])</span><br><span class="line"></span><br><span class="line">empty</span><br><span class="line">unknown, </span><br><span class="line">@com.skywang.annotation.MyAnnotation(value&#x3D;[unknown])</span><br><span class="line">@java.lang.Deprecated()</span><br></pre></td></tr></table></figure></p><h3 id="4-3-根据-Annotation-生成帮助文档"><a href="#4-3-根据-Annotation-生成帮助文档" class="headerlink" title="4.3 根据 Annotation 生成帮助文档"></a>4.3 根据 Annotation 生成帮助文档</h3><p>&emsp;通过给 Annotation 注解加上 @Documented 标签，能使该 Annotation 标签出现在 javadoc 中。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Documented</span></span><br><span class="line"><span class="meta">@Target</span>(ElementType.TYPE)</span><br><span class="line"><span class="meta">@Retention</span>(RetentionPolicy.RUNTIME)</span><br><span class="line"><span class="keyword">public</span> <span class="meta">@interface</span> MyAnnotation1 &#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">key</span><span class="params">()</span> <span class="keyword">default</span> "Hello"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 本方法是覆写Object的toString方法</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">@MyAnnotation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hello"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>加入文档注释后，会在doc文档中出现(使用javadoc文档生成)。</p><h3 id="4-4-能够帮忙查看查看代码"><a href="#4-4-能够帮忙查看查看代码" class="headerlink" title="4.4 能够帮忙查看查看代码"></a>4.4 能够帮忙查看查看代码</h3><p>&emsp;通过 @Override, @Deprecated 等，我们能很方便的了解程序的大致结构。<br>&emsp;另外，我们也可以通过自定义 Annotation 来实现一些功能。</p><p>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.runoob.com/w3cnote/java-annotation.html" target="_blank" rel="noopener">https://www.runoob.com/w3cnote/java-annotation.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机 之 垃圾收集算法</title>
      <link href="/java/java-jvm-GC-alogrithm/"/>
      <url>/java/java-jvm-GC-alogrithm/</url>
      
        <content type="html"><![CDATA[<h1 id="Garbage-Collection"><a href="#Garbage-Collection" class="headerlink" title="Garbage Collection"></a>Garbage Collection</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;GC 需要完成的3件事为：</p><ul><li>哪些内存需要回收？</li><li>什么时候回收？</li><li>如何回收？</li></ul><p>&emsp;Java 内存运行时区域的各个部分，其中程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭。而Java堆和方法区则不一样，一个接口的多个实现类需要的内存可能不一样，一个方法的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收都是动态的，垃圾收集器所关注的就是这部分内存。</p><h2 id="2-对象已死吗"><a href="#2-对象已死吗" class="headerlink" title="2. 对象已死吗"></a>2. 对象已死吗</h2><p>&emsp;在堆里存放着Java中几乎所有的对象实例，垃圾收集器在对堆进行回收前，第一件事就是要确认哪些对象还“存活”着，哪些已经“死去”（不可能再被使用）。</p><h3 id="2-1-引用计数算法"><a href="#2-1-引用计数算法" class="headerlink" title="2.1 引用计数算法"></a>2.1 引用计数算法</h3><p>&emsp;引用计数算法（Reference Counting）：给对象添加一个引用计数器，每当有一个地方引用它，计数器就+1，引用失效，计数器-1：任何时刻计数器为0的对象就是不能再被使用的。<br>这种算法实现简单，判定效率也很高，但它难以解决对象之间相互循环引用的问题，如果两个对象中存在互相引用，就无法通知GC收集器回收它们。Java虚拟机并不是通过引用计数算法来判断对象是否存活的。</p><h3 id="2-2-可达性分析算法"><a href="#2-2-可达性分析算法" class="headerlink" title="2.2 可达性分析算法"></a>2.2 可达性分析算法</h3><p>&emsp;在主流商用程序语言（Java、C#）的<strong>主流</strong>实现中，都是通过可达性分析（Reachability Analysis）来判定对象是否存活的。基本思路是通过一系列的称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，则证明此对象是不可用的。<br>Java中，可作为GC Roots的对象包括以下几种：</p><ul><li>虚拟机栈(栈帧中的本地变量表)中引用的对象。</li><li>方法区中类静态属性引用的对象。</li><li>方法区中常量引用的对象。</li><li>本地方法栈中Native方法引用的对象。</li></ul><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/ReachabilityAnalysis.png" alt="ReachabilityAnalysis"></p><h3 id="2-3-再谈引用"><a href="#2-3-再谈引用" class="headerlink" title="2.3 再谈引用"></a>2.3 再谈引用</h3><p>&emsp;Java将引用分为强引用(Strong Reference)、软引用(Soft Reference)、弱引用(weak Reference)、虚引用(Phantom Reference)。</p><ul><li>强引用是指类似 “Object obj=new Object()” 这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象</li><li>软引用是用来描述一些还有用但并非必需的对象。对于软引用关联着的对象    ，在系统将要发生内存溢出异常之前，将会把这些对象列进回收范围之中进行第二次回收。如果这次回收还没有足够的内存，才会抛出内存溢出异常。在JDK1.2之后，提供了SoftReference类来实现软引用。</li><li>弱引用也是用来描述非必需对象的，但是它的强度要比软引用更弱一些，被弱引用关联的对象只能生存到下一次垃圾收集发生之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象。在JDK1.2之后，提供了WeakReference类来实现弱引用。</li><li>虚引用是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知。在JDK1.2之后，提供了PhantomReference类来实现虚引用。</li></ul><h3 id="2-4-生存还是死亡"><a href="#2-4-生存还是死亡" class="headerlink" title="2.4 生存还是死亡"></a>2.4 生存还是死亡</h3><p>&emsp;即使在可达性分析算法中不可达的对象，也并非是“非死不可”，这时候它们暂时处于“缓刑”阶段，要真正宣告一个对象的死亡，至少要经历两次标记过程：如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它将会被第一次标记并且进行一次筛选，筛选条件是此对象是否有必要执行finalize()方法。当对象没有覆盖finalize()方法，或者finalize()方法已经被jvm调用过，虚拟机将这两种情况都视为“没有必要执行”。</p><p>​&emsp;如果这个对象被判定为有必要执行finalize方法，那么这个对象会放置在F-Queue队列中，并在稍后由一个由虚拟机自动建立的、低优先级的Finalizer线程去执行它（调用finalize方法）。执行是指触发这个方法，但不承诺会等待它运行结束，因为如果一个对象在F-Queue中执行缓慢，或者发生了死循环，很可能导致其他对象永久处于等待状态，甚至整个内存回收系统崩溃。稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象要再finalize()中拯救自己——只需要重新与引用链上任意一个对象建立关联，譬如把自己（this）赋值给某个类变量或者对象的成员变量，那在第二次标记时它将被移出“即将回收”的集合；如果对象这时候还没有逃脱，那基本上它就真的被回收了。</p><p>&emsp;上面的过程可以简单总结如下：</p><ul><li>可达性分析<ul><li>1.可达，不回收</li><li>2.不可达，标记为“即将回收”，判断该对象有 finalize 方法并且还未被 JVM 调用过？<ul><li>2.1 是，将对象放入 F-Queue 队列，等待执行 finalize 方法<ul><li>如果执行 finalize 方法中将自己和引用链上任意一个对象建立关联，则该对象会被移出“即将回收”的集合</li></ul></li><li>2.2 否，即没有 finalize 方法或者 finalize 方法已经被调用过，回收该对象</li></ul></li></ul></li></ul><p>&emsp;两次标记过程为：</p><ul><li><ol><li>可达性分析判断对象不可达，标记为“即将回收”，将对象放入 F-Queue 队列</li></ol></li><li><ol><li>对 F-Queue 队列中对象，执行 finalize 方法，如果在该方法中对象没有“拯救自己“，则标记为”回收“</li></ol></li></ul><p>&emsp;对于对象在 finalize 方法中”拯救自己“，可以看一下下面这个例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FinalizeEscapeGC</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> FinalizeEscapeGC SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">isAlive</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"yes,i am still alive"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">finalize</span><span class="params">()</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.finalize();</span><br><span class="line">        System.out.println(<span class="string">"finalize method executed!"</span>);</span><br><span class="line">        FinalizeEscapeGC.SAVE_HOOK = <span class="keyword">this</span>;     <span class="comment">//自我拯救，使当前对象被引用</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        SAVE_HOOK = <span class="keyword">new</span> FinalizeEscapeGC();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//对象第一次成功拯救自己</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        <span class="comment">//因为finalize方法优先级很低，所以暂停0.5秒等待它</span></span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;   <span class="comment">//不会被回收，仍然存活</span></span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"no,i am dead!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//第二次自救，自救失败，代码跟上面完全一样</span></span><br><span class="line">        SAVE_HOOK = <span class="keyword">null</span>;</span><br><span class="line">        System.gc();</span><br><span class="line">        Thread.sleep(<span class="number">500</span>);</span><br><span class="line">        <span class="keyword">if</span>(SAVE_HOOK != <span class="keyword">null</span>)&#123;</span><br><span class="line">            SAVE_HOOK.isAlive();</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"no,i am dead!"</span>);  <span class="comment">//自救失败，被回收</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">finalize method executed!</span><br><span class="line">yes,i am still alive</span><br><span class="line">no,i am dead!</span><br></pre></td></tr></table></figure><br>&emsp;需要注意的是，<strong>任何一个对象的 finalize() 方法都只会被系统自动调用一次</strong>，因此也只能”拯救“自己一次。<br>并不建议使用这种方式来拯救对象，它的运行代价高昂，不确定性大，无法保证各个对象的调用顺序，finalize 能做的，使用 try-finally 或者其它方式都可以做的更好、更及时，完全可以忘记这个方法的存在。</p><h2 id="3-垃圾收集算法"><a href="#3-垃圾收集算法" class="headerlink" title="3. 垃圾收集算法"></a>3. 垃圾收集算法</h2><h3 id="3-1-标记-清除算法-Mark-Sweep"><a href="#3-1-标记-清除算法-Mark-Sweep" class="headerlink" title="3.1 标记-清除算法 Mark-Sweep"></a>3.1 标记-清除算法 Mark-Sweep</h3><p>&emsp;算法分为“标记”和”清除”(Mark-Sweep)两个阶段,首先标记出需要回收的对象,在标记完成后统一回收。后续的收集算法都基于这种思路并对其不足进行改进。<br>它的不足有两个：</p><ul><li>一是效率问题，标记和清除两个阶段的效率都不高；</li><li>另一个是空间问题，标记清楚后会产生大量不连续的内存碎片，空间碎片太多可能导致以后在程序运行过程中需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集。</li></ul><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/MarkSweep.png" alt="MarkSweep"></p><h3 id="3-2-复制算法-Copying"><a href="#3-2-复制算法-Copying" class="headerlink" title="3.2 复制算法 Copying"></a>3.2 复制算法 Copying</h3><p>&emsp;算法将可用内存按容量划分为大小相等的两块,每次只使用其中的一块。当这块内存用完了,就将还存活着的对象复制到另外一块上面,然后把已使用过的内存空间一次清理掉。这样使得每次都是对整个半区进行内存回收，也不会出现内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单、高效。但代价是将内存缩小为了原来的一半，代价比较大。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/Copying.png" alt="Copying"></p><p>&emsp;商业虚拟机都采用这种收集算法来回收<strong>新生代</strong>。IBM研究表明，新生代中98%的对象都是“朝生夕死”，所以不需要1:1的比例来划分内存，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中和存活的对象一次性复制到另外一块Survivor上，最后清理Eden和用过的Survivor空间。HotSpot默认Eden和Survivor大小比例为8:1。也就是新生代中可用空间为整个新生代的90%，只有10%会被“浪费”。如果另一块Survivor空间不够用时，需要依赖其他内存（老年代）进行<strong>分配担保</strong>。</p><h3 id="3-3-标记-整理算法-Mark-Compact"><a href="#3-3-标记-整理算法-Mark-Compact" class="headerlink" title="3.3 标记-整理算法 Mark-Compact"></a>3.3 标记-整理算法 Mark-Compact</h3><p>​&emsp;复制收集算法在对象存活率较高时要进行较多的复制操作，效率将会降低，更关键的在于如果不想浪费一半的内存空间，就需要有额外空间进行分配担保，以应对被使用的内存中所有对象都是100%存活的极端情况，所以在老年代一般不能直接使用这种算法。</p><p>​&emsp;根据<strong>老年代</strong>的特点，有人提出了另外一种“标记-整理”（Mark-Compact）算法，标记过程与“标记-清除”一样，但后续步骤不是进行清理，而是让所有存活的对象都向一端移动，然后清理掉端边界以外的内存。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/MarkCompact.png" alt="MarkCompact"></p><h3 id="3-4-分代收集算法-Generational-Collection"><a href="#3-4-分代收集算法-Generational-Collection" class="headerlink" title="3.4 分代收集算法 Generational Collection"></a>3.4 分代收集算法 Generational Collection</h3><p>&emsp;<strong>当前商业虚拟机的垃圾收集都采用“分代收集”（Generational Collection）算法</strong>，这种算法根据对象存活周期的不同，将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法，在新生代，每次垃圾收集都有大量的对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代因为对象存活率高，没有额外空间进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法进行回收。</p><h2 id="4-HotSpot-的算法实现"><a href="#4-HotSpot-的算法实现" class="headerlink" title="4. HotSpot 的算法实现"></a>4. HotSpot 的算法实现</h2><h3 id="4-1-枚举根节点"><a href="#4-1-枚举根节点" class="headerlink" title="4.1 枚举根节点"></a>4.1 枚举根节点</h3><p>&emsp;可达行分析存在两个问题：</p><ul><li><p>一. 从可达性分析中从GC Roots节点找引用链这个操作为例，可作为GC Roots的节点主要在全局性的引用（例如常量或类静态属性）与执行上下文（例如栈帧中的本地变量表）中，现在很多应用仅仅方法区就有数百兆，如果要逐个检查这里面的引用，那么必然会消耗很多时间。</p></li><li><p>二. 可达性分析对执行时间的敏感还体现在GC停顿上，因为这项分析工作必须在一个能确保一致性的快照中进行——这里“一致性”的意思是指在整个分析期间整个执行系统看起来就像被冻结在某个时间点上，不可以出现分析过程中对象引用关系还在不断变化的情况，该点不满足的话分析结果准确性就无法得到保证。这点是导致GC进行时必须停顿所有Java执行线程（Sun将这件事情称为“Stop The World”）的其中一个重要原因，即使是在号称几乎不会发生停顿的CMS收集器中，枚举根节点时也是必须要停顿的。</p></li></ul><p>&emsp;由于目前的主流Java虚拟机使用的都是<strong>准确式GC</strong>（虚拟机可以知道内存中某个位置的数据具体是什么类型），所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，是使用一组称为<strong>OopMap</strong>的数据结构来达到这个目的的，在类加载完成的时候，HotSpot就把对象内什么偏移量上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用，GC在扫描时就可以直接得知这些信息了。</p><p>&emsp;简单总结一下，可达性分析存在的问题以及 HotSpot 的解决方案为：</p><ul><li>GC Roots 引用链查找时间问题 - OopMap 记录引用信息</li><li>GC 停顿 - 安全点/安全区域</li></ul><h3 id="4-2-安全点-Safepoint"><a href="#4-2-安全点-Safepoint" class="headerlink" title="4.2 安全点 Safepoint"></a>4.2 安全点 Safepoint</h3><p>&emsp;HotSpot 没有为每条指令都生成OopMap，只是在特定的位置记录了这些信息，这些位置称为<strong>安全点</strong>，即程序执行时并非在所有地方都能停顿下来开始GC，<strong>只有在到达安全点时才能暂停</strong>。安全点的选定基本上是以程序”<strong>是否具有让程序长时间执行的特征</strong>“为标准进行选定的——因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，长时间执行的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint。</p><p>&emsp;对于Safepoint，另一个需要考虑的问题是如何在GC发生时让所有线程都跑到最近的安全点上再停顿下来。有两种方法：抢先式中断和主动式中断。</p><p>&emsp;抢先式中断：抢先式中断不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。现在几乎没有虚拟机实现采用抢先式中断来暂停线程从而响应GC事件。</p><p>&emsp;主动式中断：主动式中断的思想是当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起，轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。</p><h3 id="4-3-安全区域-Safe-Region"><a href="#4-3-安全区域-Safe-Region" class="headerlink" title="4.3 安全区域 Safe Region"></a>4.3 安全区域 Safe Region</h3><p>&emsp;Safepoint 机制保证了程序执行时，在不太长的时间内就会遇到可进入 GC 的 Safepoint，但线程处于Sleep状态或者Blocked状态，这时候线程无法响应JVM的中断请求,”走”到安全的地方去中断挂起，JVM也不太可能等待线程被重新分配CPU时间，这种情况就需要安全区域来解决。</p><p>&emsp;安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的，可以把 Safe Region 看做是被扩展了的 Safepoint。</p><p>&emsp;在线程执行到 Safe Region 中的代码时，首先标识自己已经进入了 Safe Region，那样，当在这段时间里JVM要发起GC时，就不用管标识自己为 Safe Region 状态的线程了。在线程要离开 Safe Region 时，它要检查系统是否已经完成了根节点枚举（或者整个GC过程），如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开 Safe Region 的信号为止。</p><p>&nbsp;</p><blockquote><p>参考：<br>《深入理解Java虚拟机》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解 HashMap(二)</title>
      <link href="/java/java-HashMap2/"/>
      <url>/java/java-HashMap2/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解-HashMap-二"><a href="#深入理解-HashMap-二" class="headerlink" title="深入理解 HashMap(二)"></a>深入理解 HashMap(二)</h1><p>&emsp;接着上一篇文章<a href="http://zhoujiapeng.top/java/java-HashMap">《深入理解 HashMap(一)》</a>，我们继续分析 HashMap。</p><p>&emsp;本文首先介绍 HashMap 中的 hash 算法和索引计算方法，它们都经过了一定的优化，在 get 和 put 函数中均会用到。接着会详细介绍 get 和 put 的过程，理解了这两个过程，就基本上掌握了 HashMap 的整体流程。</p><h2 id="1-Hash-算法"><a href="#1-Hash-算法" class="headerlink" title="1. Hash 算法"></a>1. Hash 算法</h2><p>&emsp;普通的 Hash 表可能会使用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key.hashCode()</span><br></pre></td></tr></table></figure><br>&emsp;来计算key的hash，但是 HashMap 有自己的散列算法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">hash</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">return</span> (key == <span class="keyword">null</span>) ? <span class="number">0</span> : (h = key.hashCode()) ^ (h &gt;&gt;&gt; <span class="number">16</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;我们知道, int类型是32位的, h ^ h &gt;&gt;&gt; 16 其实就是将hashCode的高16位和低16位进行异或, 这充分利用了高半位和低半位的信息, 对低位进行了扰动, 目的是为了使该hashCode映射成数组下标时可以更均匀, 详细的解释可以参考<a href="https://www.zhihu.com/question/20733617/answer/111577937" target="_blank" rel="noopener">这里</a>。</p><p>&emsp;另外, 从这个函数中, 我们还可以得到一个意外收获: HashMap中key值可以为null, 且null值一定存储在数组的第一个位置。</p><h2 id="2-优化的索引计算"><a href="#2-优化的索引计算" class="headerlink" title="2. 优化的索引计算"></a>2. 优化的索引计算</h2><p>&emsp;对于一般的 Hash 表，可能会这样来将 key 映射成 index：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h % n</span><br></pre></td></tr></table></figure><br>&emsp;但是在 HashMap 中会通过这样的方式来计算索引：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure><br>&emsp;这个位运算，实际上是对取余运算的优化。由于hash桶数组的大小一定是2的幂次方，因此能够这样优化，即：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">h % n = (n - <span class="number">1</span>) &amp; hash</span><br></pre></td></tr></table></figure></p><p>思路是这样的，bi是b二进制第i位的值：<br>b % 2<sup>i</sup> = (2<sup>N</sup>b<sub>N</sub> + 2<sup>N-1</sup>b<sub>N-1</sub>+ … + 2<sup>i</sup>b<sub>i</sub> + … 2<sup>0</sup>b<sub>0</sub>) % 2<sup>i</sup><br>设x &gt;= i，则一定有 2<sup>x</sup>b<sub>x</sub> % 2i = 0<br>所以，上面的式子展开后就是：<br>b % 2<sup>i</sup> = 2<sup>i-1</sup>b<sub>i-1</sub> + 2<sup>i-2</sup>b<sub>i-1</sub> + … 2<sup>0</sup>b<sub>0</sub><br>结果就是只保留低于第i位的所有数据。</p><p>反映到二进制上来说，以8位二进制举个例子：<br>对于 h % n：<br>显然2的幂次方N的二进制位是只有一个1的。8的二进制为000001000，1在第3位。<br>任何一个数B对N求余，反映二进制上，就是高于等于第3位的置0，低于的保留。如10111010 % 00001000 = 00000010<br>对于 n-1：<br>00001000 - 1 = 00000111，这样减一之后，需要保留的对应位为全是1，需要置0的对应位全都是0。把它与B作与运算，就是只保留低于第3位的数据，就能得到结果。</p><p>&emsp;<strong>由于取模运算是十分耗时的，而索引计算在 HashMap 中是非常常见的操作，将取模操作转化成&amp;运算能够很大程度上提高效率</strong>。</p><h2 id="3-get函数"><a href="#3-get函数" class="headerlink" title="3. get函数"></a>3. get函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">get</span><span class="params">(Object key)</span> </span>&#123;</span><br><span class="line">    Node&lt;K,V&gt; e;</span><br><span class="line">    <span class="keyword">return</span> (e = getNode(hash(key), key)) == <span class="keyword">null</span> ? <span class="keyword">null</span> : e.value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;get 函数先是调用 hash 对 key 做一次 hash 运算之后再调用 getNode 函数。<br>&emsp;hash 运算在上面已经分析过了，我们看一下 getNode 函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> Node&lt;K,V&gt; <span class="title">getNode</span><span class="params">(<span class="keyword">int</span> hash, Object key)</span> </span>&#123;</span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; <span class="keyword">int</span> n; K k;</span><br><span class="line">        <span class="comment">//如果table不为空，且对应索引上存在数据</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) != <span class="keyword">null</span> &amp;&amp; (n = tab.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">            (first = tab[(n - <span class="number">1</span>) &amp; hash]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//key相等，在该索引位置上的第一个节点就是要找的节点</span></span><br><span class="line">            <span class="keyword">if</span> (first.hash == hash &amp;&amp; <span class="comment">// always check first node</span></span><br><span class="line">                ((k = first.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                <span class="keyword">return</span> first;</span><br><span class="line">            <span class="comment">//需要往后找</span></span><br><span class="line">            <span class="keyword">if</span> ((e = first.next) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//如果是红黑树</span></span><br><span class="line">                <span class="keyword">if</span> (first <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                    <span class="comment">//在红黑树上查找</span></span><br><span class="line">                    <span class="keyword">return</span> ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);</span><br><span class="line">                <span class="keyword">do</span> &#123;<span class="comment">//链表</span></span><br><span class="line">                    <span class="comment">//遍历链表</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">return</span> e;</span><br><span class="line">                &#125; <span class="keyword">while</span> ((e = e.next) != <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;getNode 的思路为：</p><ul><li>table 非空且 key 在 table 中对应位置上存在数据<ul><li>否：返回 null</li><li>是：<ul><li>在该索引位置上的第一个节点就是要找的节点，即 key 相等，直接返回第一个节点</li><li>否则，判断该位置上的结构<ul><li>红黑树：在红黑树上查找</li><li>链表：遍历链表查找</li></ul></li></ul></li></ul></li></ul><h2 id="4-put函数"><a href="#4-put函数" class="headerlink" title="4. put函数"></a>4. put函数</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//提前计算好key的hash</span></span><br><span class="line">        <span class="keyword">return</span> putVal(hash(key), key, value, <span class="keyword">false</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//onlyIfAbsent含义是如果那个位置已经有值了，是否替换</span></span><br><span class="line">        <span class="comment">//evict</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="comment">//1.如果table为空</span></span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//resize的作用为扩容或初始化这里为初始化</span></span><br><span class="line">            n = (tab = resize()).length;</span><br><span class="line">        <span class="comment">//2.i = (n - 1) &amp; hash]计算索引，判断该位置上是否有数据</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//2.1 如果没有则直接添加新节点</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;<span class="comment">//2.2 该位置上已经有数据</span></span><br><span class="line">            <span class="comment">//e会储存新插入的节点，或者如果key已经存在，则储存已经存在的节点</span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="comment">//此时p为table表中该索引位置上的第一个数据</span></span><br><span class="line">            <span class="comment">//2.2.1 判断第一个位置上的key是否相同</span></span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p;</span><br><span class="line">            <span class="comment">//2.2.2 如果当前链是红黑树</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123;<span class="comment">//2.2.3 链表</span></span><br><span class="line">                <span class="comment">//遍历链表，binCount用来统计链表长度</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123;</span><br><span class="line">                    <span class="comment">//这里已经将p.next赋值给了e，后面使用e和p来遍历链表</span></span><br><span class="line">                    <span class="comment">//情况1：最后一个节点</span></span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//插入新的节点</span></span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//如果链表长度大于8，则转化为红黑树</span></span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// -1 for 1st</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//情况2：不是最后一个节点，存在key相同的节点</span></span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    <span class="comment">//链表的下一个节点，前面已经将p.next赋值给了e</span></span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//情况2的处理，情况1时e==null</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="comment">//如果允许覆盖</span></span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)</span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e);</span><br><span class="line">                <span class="keyword">return</span> oldValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;</span><br><span class="line">        <span class="comment">//储存的数据快要达到饱和时扩容</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            <span class="comment">//扩容</span></span><br><span class="line">            resize();</span><br><span class="line">        <span class="comment">//作为插入之后的回调函数，目前这个函数的空的</span></span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;putVal 的思路为：</p><ul><li>1.判断table是否分配，如果没有就先分配空间，和前面提到的“延时分配”对应起来。</li><li>2.同样，根据hash值定位hash桶数组的位置。然后：<ul><li>2.1 该位置为null。直接创建一个节点插入。</li><li>2.2 该位置不为null<ul><li>2.2.1 该位置为平衡树。调用 putTreeVal 将节点插入红黑树。</li><li>2.2.2 该位置为链表。遍历链表，进行插入。会出现两种情况：<ul><li>遍历到链表尾，说明这个key不存在，应该直接在链表尾插入。但是这导致链表增长，需要触发链表重构成红黑树的判断逻辑。</li><li>在链表上找到一个key相同的节点，根据 onlyIfAbsent 参数决定是否要使用新数据覆盖旧数据</li></ul></li></ul></li></ul></li><li><ol><li>判断插入数据后 size 是否会超过阈值，如果超过，执行扩容操作。</li></ol></li></ul><p>&nbsp;</p><blockquote><p>参考：<br><a href="https://segmentfault.com/a/1190000015631344" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015631344</a><br><a href="https://segmentfault.com/a/1190000015798586" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015798586</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解 HashMap(一)</title>
      <link href="/java/java-HashMap/"/>
      <url>/java/java-HashMap/</url>
      
        <content type="html"><![CDATA[<h1 id="深入理解-HashMap-一"><a href="#深入理解-HashMap-一" class="headerlink" title="深入理解 HashMap(一)"></a>深入理解 HashMap(一)</h1><blockquote><p>本文介绍的 HashMap 基于 JDK1.8</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;HashMap能够存储给定的键值对，并且对于给定key的查询和插入都达到平均时间复杂度为O(1)。<br>&emsp;实现hash表的关键在于：</p><ol><li>对于给定的key，如何将其对应到内存中的一个对应位置，这通过hash算法做到。</li><li>通过hash算法 hash(K) % N 来将关键字key映射数组对应hash表的位置上。</li><li>hash算法存在hash冲突，也即多个不同的K被映射到数组的同一个位置上。如何解决hash冲突？有三种方法。</li></ol><ul><li>分离链表法。即用链表来保存冲突的K。</li><li>开放定址法。当位置被占用时，通过一定的算法来试选其它位置。hash(i) = (hash(key) + d(i)) % N，i代表第i次试选。常用的有平方探测法，d(i) = i^2。</li><li>再散列。如果冲突，就再用hash函数再嵌套算一次，直到没有冲突。</li></ul><p>&emsp;本文介绍的 JDK1.8 里面的 HashMap 采用方法类似于分离链表法。</p><h2 id="2-HashMap-in-JDK1-8"><a href="#2-HashMap-in-JDK1-8" class="headerlink" title="2. HashMap in JDK1.8"></a>2. HashMap in JDK1.8</h2><h3 id="2-1-储存结构"><a href="#2-1-储存结构" class="headerlink" title="2.1 储存结构"></a>2.1 储存结构</h3><p>&emsp;HashMap采用数组形式来存储key-value对象, 以利用其优良的查找性能, 数组之所以查找迅速, 是因为可以根据索引(数组下标)直接定位到对应的存储桶(数组所存储对象的位置)，时间复杂度为O(1)。如果有多个元素被映射到同一个桶，则优先采用链表来组织具有相同key的元素。</p><p>&emsp;我们知道, 链表查找只能通过顺序查找来实现, 因此, 时间复杂度为o(n), 如果很不巧, 我们的key值被Hash算法映射到一个存储桶上, 将会导致存储桶上的链表长度越来越长, 此时, 数组查找退化成链表查找, 则时间复杂度由原来的o(1) 退化成 o(n)。</p><p>&emsp;为了解决这一问题, 在java8中,当链表长度超过 8 之后,将会自动将链表转换成红黑树,以实现 o(log n) 的时间复杂度, 从而提升查找性能。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/HashMap.jpg" alt="HashMap"><br>(图片来源网络)</p><h3 id="2-2-扩容问题"><a href="#2-2-扩容问题" class="headerlink" title="2.2 扩容问题"></a>2.2 扩容问题</h3><p>&emsp;需要注意的是，采用链表本质上只是为了解决hash冲突问题，而不是为了增大容量，红黑树只是为了解决链表查询效率较低的问题。HashMap采用数组形式来存储key-value对象，最理想的情况是每一个桶只储存一个元素。另外。数组的大小是有限的, 在新建的时候就要指定, 如果加入的节点已经到了数组容量的上限, 已经没有位置能够存储key-value键值对了, 此时就需要扩容。<br>扩容不是等到数组全部满了再进行扩容，而是有一个阈值，这个阈值和负载因子有关，默认是0.75，官方的解释是：</p><blockquote><p>the default load factor (.75) offers a good tradeoff between time and space costs.</p></blockquote><p>&emsp;确定了扩容的时机后，接下来的问题是每次扩容需要增加多少空间。<br>&emsp;我们知道, 数组的扩容是一个很耗费CPU资源的动作, 需要将原数组的内容复制到新数组中去, 因此频繁的扩容必然会导致性能降低, 所以不可能数组满了之后, 每多加一个node, 我们就扩容一次。但是, 一次扩容太大, 导致大量的存储空间用不完, 势必又造成很大的浪费, 因此, 必须根据实际情况设定一个合理的扩容大小。<br>&emsp;在HashMap的实现中, 每次扩容我们都会将新数组的大小设为原数组大小的两倍。</p><h2 id="3-源码分析"><a href="#3-源码分析" class="headerlink" title="3. 源码分析"></a>3. 源码分析</h2><p>&emsp;接下来我们从源码的角度来分析HashMap。</p><h3 id="3-1-Node"><a href="#3-1-Node" class="headerlink" title="3.1 Node"></a>3.1 Node</h3><p>&emsp;table是Hash表数组，数组的元素类型是Node，Node里面包含了一个next字段，这表明HashMap采用的是分离链表的方法实现。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//hash表数组</span></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">    <span class="keyword">final</span> K key;</span><br><span class="line">    V value;</span><br><span class="line">    Node&lt;K,V&gt; next;</span><br><span class="line"></span><br><span class="line">    Node(<span class="keyword">int</span> hash, K key, V value, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">        <span class="keyword">this</span>.hash = hash;</span><br><span class="line">        <span class="keyword">this</span>.key = key;</span><br><span class="line">        <span class="keyword">this</span>.value = value;</span><br><span class="line">        <span class="keyword">this</span>.next = next;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;Node 不仅储存了key、value，还有一个hash字段，为key的hash，既然已经储存了key，为何还要多此一举储存key的hash？<br>仔细一想不难明白，HashMap能够存储任意对象，对象的hash值是由hashCode方法得到，这个方法由所属对象自己定义，里面可能有费时的操作，而hash值在Hash表内部实现会多次用到，因此这里将它保存起来，是一种优化的手段。</p><h3 id="3-2-TreeNode"><a href="#3-2-TreeNode" class="headerlink" title="3.2 TreeNode"></a>3.2 TreeNode</h3><p>&emsp;TreeNode是红黑树节点，里面有一个red属性。HashMap会在链表过长的时候，将其重构成红黑树。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">TreeNode</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">extends</span> <span class="title">LinkedHashMap</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        TreeNode&lt;K,V&gt; parent;  <span class="comment">// red-black tree links</span></span><br><span class="line">        TreeNode&lt;K,V&gt; left;</span><br><span class="line">        TreeNode&lt;K,V&gt; right;</span><br><span class="line">        TreeNode&lt;K,V&gt; prev;    <span class="comment">// needed to unlink next upon deletion</span></span><br><span class="line">        <span class="keyword">boolean</span> red;</span><br><span class="line">        TreeNode(<span class="keyword">int</span> hash, K key, V val, Node&lt;K,V&gt; next) &#123;</span><br><span class="line">            <span class="keyword">super</span>(hash, key, val, next);</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="3-3-属性字段"><a href="#3-3-属性字段" class="headerlink" title="3.3 属性字段"></a>3.3 属性字段</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//初始默认大小16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_INITIAL_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">4</span>; <span class="comment">// aka 16</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAXIMUM_CAPACITY = <span class="number">1</span> &lt;&lt; <span class="number">30</span>;</span><br><span class="line"><span class="comment">// 默认负载因子 0.75</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">float</span> DEFAULT_LOAD_FACTOR = <span class="number">0.75f</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TREEIFY_THRESHOLD = <span class="number">8</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> UNTREEIFY_THRESHOLD = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MIN_TREEIFY_CAPACITY = <span class="number">64</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">transient</span> Node&lt;K,V&gt;[] table;</span><br><span class="line"><span class="keyword">transient</span> Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> size;</span><br><span class="line"><span class="keyword">transient</span> <span class="keyword">int</span> modCount;</span><br><span class="line"><span class="keyword">int</span> threshold;</span><br><span class="line"><span class="keyword">final</span> <span class="keyword">float</span> loadFactor;</span><br></pre></td></tr></table></figure><p>&emsp;最重要的是table、size、loadFactor这三个字段：</p><ol><li>table可以看出是个节点数组，也即hash表中用于映射key的数组。由于链表是递归数据结构，这里数组保存的是链表的头节点。</li><li>size，hash表中元素个数。</li><li>loadFactor，装填因子，控制HashMap扩容的时机。</li></ol><p>&emsp;对于 threshold 字段：</p><ol><li>如果table还没有被分配，threshold 为<strong>初始的空间大小</strong>。如果是0，则是默认大小，DEFAULT_INITIAL_CAPACITY。</li><li>如果table已经分配了，这个值为<strong>扩容阈值</strong>，也就是table.length * loadFactor。</li></ol><h3 id="3-4-构造函数"><a href="#3-4-构造函数" class="headerlink" title="3.4 构造函数"></a>3.4 构造函数</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 指定初始大小和负载因子</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity, <span class="keyword">float</span> loadFactor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal initial capacity: "</span> +</span><br><span class="line">                                               initialCapacity);</span><br><span class="line">    <span class="keyword">if</span> (initialCapacity &gt; MAXIMUM_CAPACITY)</span><br><span class="line">        initialCapacity = MAXIMUM_CAPACITY;</span><br><span class="line">    <span class="keyword">if</span> (loadFactor &lt;= <span class="number">0</span> || Float.isNaN(loadFactor))</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Illegal load factor: "</span> +</span><br><span class="line">                                           loadFactor);</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = loadFactor;</span><br><span class="line">    <span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(<span class="keyword">int</span> initialCapacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>(initialCapacity, DEFAULT_LOAD_FACTOR);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 没有指定时, 使用默认值</span></span><br><span class="line"><span class="comment">// 即默认初始大小16, 默认负载因子 0.75</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR; <span class="comment">// all other fields defaulted</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 利用已经存在的map创建HashMap</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">HashMap</span><span class="params">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.loadFactor = DEFAULT_LOAD_FACTOR;</span><br><span class="line">    putMapEntries(m, <span class="keyword">false</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果我们在构造函数指定了 initialCapacity，即初始容量，则会调用 tableSizeFor 函数来设置阈值：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.threshold = tableSizeFor(initialCapacity);</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Returns a power of two size for the given target capacity.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tableSizeFor</span><span class="params">(<span class="keyword">int</span> cap)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n = cap - <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">2</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">4</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">8</span>;</span><br><span class="line">    n |= n &gt;&gt;&gt; <span class="number">16</span>;</span><br><span class="line">    <span class="keyword">return</span> (n &lt; <span class="number">0</span>) ? <span class="number">1</span> : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;通过注释我们可以知道 tableSizeFor 函数是将给定的数对齐到2的幂，也就是找到大于等于initialCapacity的最小的2的幂。关于这个算法的具体介绍可以参看<a href="https://blog.csdn.net/fan2012huan/article/details/51097331" target="_blank" rel="noopener">这一篇博客</a>。<br>&emsp;由此可以知道，hash桶数组的初始大小一定是2的幂，后面扩容的时候总是将将容量扩大到原来的两倍，因此hash桶数组大小总是为2的幂。   </p><p>&emsp;另外，这里也用到了类似前面ArrayList的“<strong>延迟分配</strong>”的思路，一开始table是null，只有在第一次插入数据时才会真正分配空间。这样，由于实际场景中会出现大量空表，而且很可能一直都不添加元素，这样“延迟分配”的优化技巧能够节约内存空间。这里就体现出threshold的含义了，hash桶数组的空间未分配时它保存的是table初始的大小。</p><h3 id="3-5-resize-扩容"><a href="#3-5-resize-扩容" class="headerlink" title="3.5 resize 扩容"></a>3.5 resize 扩容</h3><p>&emsp;上面我们说到，构造函数中并不会初始化 table 变量, table 变量是在 resize 过程中初始化的。<br>&emsp;resize 函数的作用有两个：</p><ul><li>初始化 table</li><li>在table大小超过threshold之后进行扩容</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Node&lt;K,V&gt;[] resize() &#123;</span><br><span class="line">        <span class="comment">//一：确定新table的容量和阈值</span></span><br><span class="line">        Node&lt;K,V&gt;[] oldTab = table;</span><br><span class="line">        <span class="keyword">int</span> oldCap = (oldTab == <span class="keyword">null</span>) ? <span class="number">0</span> : oldTab.length;</span><br><span class="line">        <span class="keyword">int</span> oldThr = threshold;</span><br><span class="line">        <span class="keyword">int</span> newCap, newThr = <span class="number">0</span>;</span><br><span class="line">        <span class="comment">//原table已经有值</span></span><br><span class="line">        <span class="keyword">if</span> (oldCap &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="comment">//如果超出最大容量，则不再扩容，这里是2的30次方</span></span><br><span class="line">            <span class="keyword">if</span> (oldCap &gt;= MAXIMUM_CAPACITY) &#123;</span><br><span class="line">                threshold = Integer.MAX_VALUE;</span><br><span class="line">                <span class="keyword">return</span> oldTab;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//容量大于16小于最大值时容量扩大2倍</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> ((newCap = oldCap &lt;&lt; <span class="number">1</span>) &lt; MAXIMUM_CAPACITY &amp;&amp;</span><br><span class="line">                     oldCap &gt;= DEFAULT_INITIAL_CAPACITY)</span><br><span class="line">                newThr = oldThr &lt;&lt; <span class="number">1</span>; <span class="comment">// double threshold</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (oldThr &gt; <span class="number">0</span>) <span class="comment">// initial capacity was placed in threshold</span></span><br><span class="line">            newCap = oldThr;</span><br><span class="line">        <span class="keyword">else</span> &#123;               <span class="comment">// zero initial threshold signifies using defaults</span></span><br><span class="line">            newCap = DEFAULT_INITIAL_CAPACITY;</span><br><span class="line">            newThr = (<span class="keyword">int</span>)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (newThr == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">float</span> ft = (<span class="keyword">float</span>)newCap * loadFactor;</span><br><span class="line">            newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (<span class="keyword">float</span>)MAXIMUM_CAPACITY ?</span><br><span class="line">                      (<span class="keyword">int</span>)ft : Integer.MAX_VALUE);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//到此，newCap是新的hash桶数组大小，newThr是新的扩容阈值</span></span><br><span class="line">        threshold = newThr;</span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(&#123;<span class="string">"rawtypes"</span>,<span class="string">"unchecked"</span>&#125;)</span><br><span class="line">        <span class="comment">//二：将旧table的数据拷贝到新table</span></span><br><span class="line">        <span class="comment">//分配新的table</span></span><br><span class="line">        Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])<span class="keyword">new</span> Node[newCap];</span><br><span class="line">        table = newTab;</span><br><span class="line">        <span class="comment">//下面把oldTab的数据迁移到新的table来</span></span><br><span class="line">        <span class="keyword">if</span> (oldTab != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="comment">//遍历旧table的每个元素</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; oldCap; ++j) &#123;</span><br><span class="line">                <span class="comment">//e代表该位置上的第一个元素</span></span><br><span class="line">                Node&lt;K,V&gt; e;</span><br><span class="line">                <span class="comment">//如果该位置上存在数据</span></span><br><span class="line">                <span class="keyword">if</span> ((e = oldTab[j]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//清除引用</span></span><br><span class="line">                    oldTab[j] = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="comment">//说明只有一个元素，直接拷贝过来就好</span></span><br><span class="line">                    <span class="keyword">if</span> (e.next == <span class="keyword">null</span>)</span><br><span class="line">                        newTab[e.hash &amp; (newCap - <span class="number">1</span>)] = e;</span><br><span class="line">                    <span class="comment">//红黑树的情况</span></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (e <span class="keyword">instanceof</span> TreeNode)</span><br><span class="line">                        <span class="comment">//将e为根节点的红黑数切分两条子树，重新分配到newTab中</span></span><br><span class="line">                        <span class="comment">//如果拆分出来的子树太小了，就会重新将其重构回链表。</span></span><br><span class="line">                        ((TreeNode&lt;K,V&gt;)e).split(<span class="keyword">this</span>, newTab, j, oldCap);</span><br><span class="line">                    <span class="comment">//链表的情况</span></span><br><span class="line">                    <span class="keyword">else</span> &#123; <span class="comment">// preserve order</span></span><br><span class="line">                        <span class="comment">//将原链表拆分成两条子链表</span></span><br><span class="line">                        <span class="comment">//下面的大致逻辑为：</span></span><br><span class="line">                        <span class="comment">//构建两条链表 loHead 和 hiHead</span></span><br><span class="line">                        <span class="comment">//以此取原链表上的每个节点 e</span></span><br><span class="line">                        <span class="comment">//判断 (e.hash &amp; oldCap)</span></span><br><span class="line">                        <span class="comment">//   如果为 0，将e插到 loHead</span></span><br><span class="line">                        <span class="comment">//   如果为 1，将e插到 hiHead</span></span><br><span class="line">                        <span class="comment">//最后将 loHead 放到 newTab[j]</span></span><br><span class="line">                        <span class="comment">//   将 hiHead 放到 newTab[j + oldCap]</span></span><br><span class="line">                        Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">                        Node&lt;K,V&gt; next;</span><br><span class="line">                        <span class="keyword">do</span> &#123;<span class="comment">//遍历链表</span></span><br><span class="line">                            next = e.next;</span><br><span class="line">                            <span class="comment">//插入到loHead</span></span><br><span class="line">                            <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">                                <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">                                    loHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    loTail.next = e;</span><br><span class="line">                                loTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="comment">//插入到hiHead</span></span><br><span class="line">                            <span class="keyword">else</span> &#123;</span><br><span class="line">                                <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">                                    hiHead = e;</span><br><span class="line">                                <span class="keyword">else</span></span><br><span class="line">                                    hiTail.next = e;</span><br><span class="line">                                hiTail = e;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line">                        <span class="comment">//将 loHead 放到 newTab[j]</span></span><br><span class="line">                        <span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            loTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j] = loHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//将 hiHead 放到 newTab[j + oldCap]</span></span><br><span class="line">                        <span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">                            newTab[j + oldCap] = hiHead;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> newTab;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;resize 函数有点长，主要分为两个步骤：</p><ol><li>确定新table的容量和阈值</li><li>将旧table的数据拷贝到新table</li></ol><p>&emsp;第一部分比较简单，我们主要看一下第二部分，第二部分的思路为：<br>遍历旧table的每个元素e:</p><ul><li>该位置只有一个元素，直接拷贝该元素到新table相同位置</li><li>该位置上是红黑树<ul><li>将e为根节点的红黑数切分两条子树，重新分配到newTab中，如果拆分出来的子树太小了，就会重新将其重构回链表。</li></ul></li><li>该位置上是链表<ul><li>将原链表拆分成两条子链表</li></ul></li></ul><p>&emsp;下面主要看一下链表拆分的情况：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br><span class="line">Node&lt;K,V&gt; next;</span><br><span class="line"><span class="keyword">do</span> &#123;<span class="comment">//遍历链表</span></span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">//插入到loHead</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入到hiHead</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br><span class="line"><span class="comment">//将 loHead 放到 newTab[j]</span></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//将 hiHead 放到 newTab[j + oldCap]</span></span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;这段代码设计得很是精妙，我们一段一段来看：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Node&lt;K,V&gt; loHead = <span class="keyword">null</span>, loTail = <span class="keyword">null</span>;</span><br><span class="line">Node&lt;K,V&gt; hiHead = <span class="keyword">null</span>, hiTail = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><br>&emsp;这一段定义了4个Node，从变量命名上看，我们初步猜测，这里定义了两条链表 lo链表 和 hi链表, loHead 和 loTail 分别指向 lo链表的头节点和尾节点, hiHead 和 hiTail 分别指向 hi链表的头节点和尾节点。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;<span class="comment">//遍历链表</span></span><br><span class="line">    next = e.next;</span><br><span class="line">    <span class="comment">//插入到loHead</span></span><br><span class="line">    <span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入到hiHead</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (hiTail == <span class="keyword">null</span>)</span><br><span class="line">            hiHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hiTail.next = e;</span><br><span class="line">        hiTail = e;</span><br><span class="line">    &#125;</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><br>&emsp;这一段的主要框架为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    next = e.next;</span><br><span class="line">    ...</span><br><span class="line">&#125; <span class="keyword">while</span> ((e = next) != <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure><br>&emsp;就是遍历链表上的节点，对于每个节点，有两种情况，如果 (e.hash &amp; oldCap) == 0，则执行：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> ((e.hash &amp; oldCap) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (loTail == <span class="keyword">null</span>)</span><br><span class="line">            loHead = e;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            loTail.next = e;</span><br><span class="line">        loTail = e;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里其实就是使用尾插法将e节点插入到 lo 链表中，如果上面的条件不成立，则将e节点插入到 hi 链表。<br>我们再看一下最后一段：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//将 loHead 放到 newTab[j]</span></span><br><span class="line"><span class="keyword">if</span> (loTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">        loTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j] = loHead;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="comment">//将 hiHead 放到 newTab[j + oldCap]</span></span><br><span class="line"><span class="keyword">if</span> (hiTail != <span class="keyword">null</span>) &#123;</span><br><span class="line">    hiTail.next = <span class="keyword">null</span>;</span><br><span class="line">    newTab[j + oldCap] = hiHead;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;这一段做的事就是：</p><ul><li>如果lo链表非空, 我们就把整个lo链表放到新table的j位置上 </li><li>如果hi链表非空, 我们就把整个hi链表放到新table的j+oldCap位置上</li></ul><p>&emsp;综上我们知道, 这段代码的意义就是将原来的链表拆分成两个链表, 并将这两个链表分别放到新的table的 j 位置和 j+oldCap 上, j位置就是原链表在原table中的位置, 拆分的标准就是:<br>(e.hash &amp; oldCap) == 0</p><p>&emsp;整个过程用一个图表示：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/HashMap-resize-LinkedList.png" alt="HashMap-resize-LinkedList"><br>(图片来源网络)</p><p>&emsp;接下来我们再看一下 (e.hash &amp; oldCap) == 0 这个条件<br>&emsp;首先我们要明确三点:</p><ul><li>oldCap 一定是2的整数次幂, 这里假设是 2^m；</li><li>newCap 是 oldCap 的两倍, 则会是 2^(m+1)；</li><li>hash 对数组大小取模 (n - 1) &amp; hash 其实就是取 hash 的低 m 位；</li></ul><p>例如:<br>我们假设 oldCap = 16, 即 2^4,<br>16 - 1 = 15, 二进制表示为 0000 0000 0000 0000 0000 0000 0000 1111<br>可见除了低4位, 其他位置都是0（简洁起见，高位的0后面就不写了）, 则 (16-1) &amp; hash 自然就是取hash值的低4位,我们假设它为 abcd.</p><p>以此类推, 当我们将oldCap扩大两倍后, 新的index的位置就变成了 (32-1) &amp; hash, 其实就是取 hash值的低5位. 那么对于同一个Node, 低5位的值无外乎下面两种情况:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">0abcd</span><br><span class="line">1abcd</span><br></pre></td></tr></table></figure><br>其中, 0abcd与原来的index值一致, 而1abcd = 0abcd + 10000 = 0abcd + oldCap</p><p>故虽然数组大小扩大了一倍，但是同一个key在新旧table中对应的index却存在一定联系： 要么一致，要么相差一个 oldCap。</p><p>而新旧index是否一致就体现在hash值的第4位(我们把最低为称作第0位), 怎么拿到这一位的值呢, 只要:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash &amp; 0000 0000 0000 0000 0000 0000 0001 0000</span><br></pre></td></tr></table></figure><br>即<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hash &amp; oldCap</span><br></pre></td></tr></table></figure><br>故得出结论:</p><ul><li>如果 (e.hash &amp; oldCap) == 0 则该节点在新表的下标位置与旧表一致都为 j </li><li>如果 (e.hash &amp; oldCap) == 1 则该节点在新表的下标位置 j + oldCap</li></ul><p>根据这个条件, 我们将原位置的链表拆分成两个链表, 然后一次性将整个链表放到新的Table对应的位置上。</p><p>&emsp;总结一下 resize：</p><ol><li>resize发生在table初始化, 或者table中的节点数超过threshold值的时候, threshold的值一般为负载因子乘以容量大小.</li><li>每次扩容都会新建一个table, 新建的table的大小为原大小的2倍.</li><li>扩容时,会将原table中的节点re-hash到新的table中, 但节点在新旧table中的位置存在一定联系: 要么下标相同, 要么相差一个oldCap(原table的大小).</li></ol><h2 id="4-未完"><a href="#4-未完" class="headerlink" title="4. 未完"></a>4. 未完</h2><blockquote><p>由于篇幅原因，更多 HashMap 的分析请阅读下一篇文章<a href="http://zhoujiapeng.top/java/java-HashMap2">《深入理解 HashMap(二)》</a>。</p></blockquote><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>&emsp;这里先做一个总结.<br>&emsp;我们设计HashMap的初心是什么呢, 是找到一种方法, 可以存储一组键值对的集合, 并实现快速的查找：<br>==&gt; 为了实现快速查找, 我们选择了数组而不是链表. 以利用数组的索引实现o(1)复杂度的查找效率.<br>==&gt; 为了利用索引查找, 我们引入Hash算法, 将 key 映射成数组下标: key -&gt; Index<br>==&gt; 引入Hash算法又导致了Hash冲突<br>==&gt; 为了解决Hash冲突, 我们采用链地址法, 在冲突位置转为使用链表存储.<br>==&gt; 链表存储过多的节点又导致了在链表上节点的查找性能的恶化<br>==&gt; 为了优化查找性能, 我们在链表长度超过8之后转而将链表转变成红黑树, 以将 o(n)复杂度的查找效率提升至o(log n)</p><p>&emsp;可见, 每一次结构的调整, 都是始终围绕我们的初心:<strong>实现快速的查找</strong>。</p><p>&nbsp;</p><blockquote><p>参考：<br><a href="https://segmentfault.com/a/1190000015796727" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015796727</a><br><a href="https://segmentfault.com/a/1190000015631344" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015631344</a><br><a href="https://segmentfault.com/a/1190000015806050" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015806050</a><br><a href="https://segmentfault.com/a/1190000015812438" target="_blank" rel="noopener">https://segmentfault.com/a/1190000015812438</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jdk </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机 之 OutOfMemoryError 异常实战</title>
      <link href="/java/java-oom-test/"/>
      <url>/java/java-oom-test/</url>
      
        <content type="html"><![CDATA[<h1 id="OutOfMemoryError-异常实战"><a href="#OutOfMemoryError-异常实战" class="headerlink" title="OutOfMemoryError 异常实战"></a>OutOfMemoryError 异常实战</h1><p>&emsp;本节内容的目的有两个:</p><ul><li>第一 ,通过代码验证Java虚拟机规范中描述的各个运行时区域存储的内容;</li><li>第二 ,希望读者在工作中遇到实际的内存溢出异常时 ,能根据异 常的信息快速判断是哪个区域的内存溢出,知道什么样的代码可能会导致这些区域内存溢出,以及出现这些异常后该如何处理。</li></ul><h2 id="1-Java-堆溢出"><a href="#1-Java-堆溢出" class="headerlink" title="1. Java 堆溢出"></a>1. Java 堆溢出</h2><p>&emsp;Java堆用于存储对象实例,只要不断地创建对象,并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象,那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。</p><p>&emsp;下面代码中限制Java堆的大小为20MB,不可扩展(将堆的最小值-Xms参数与最大值-Xmx参数设置为一样即可避免堆自动扩展),通过参数-XX:+HeapDumpOnOutOfMemoryError可以让虚拟机在出现内存溢出异常时Dump出当前的内存堆转储快照以便事后进行分析。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xms20m -Xmx20m -XX:+HeapDumpOnOutOfMemoryError</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeapOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        List&lt;OOMObject&gt; list = <span class="keyword">new</span> ArrayList&lt;OOMObject&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(<span class="keyword">new</span> OOMObject());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">java.lang.OutOfMemoryError :Java heap space</span><br><span class="line">Dumping heap to java_pid3404.hprof.</span><br><span class="line">Heap dump file created[22045981 bytes in 0.663 secs]</span><br></pre></td></tr></table></figure><br>&emsp;Java堆内存的OOM异常是实际应用中常见的内存溢出异常情况。当出现Java堆内存溢出时 ,异常堆栈信息“java.lang.OutOfMemoryError”会跟着进一步提示“Java heap space”。</p><p>&emsp;要解决这个区域的异常,一般的手段是先通过内存映像分析工具(如Eclipse Memory Analyzer)对Dump出来的堆转储快照进行分析,重点是确认内存中的对象是否是必要的,也就是要先分清楚到底是出现了内存泄漏(Memory Leak)还是内存溢出(Memory Overflow)。<br>&emsp;如果是内存泄露,可进一步通过工具查看泄露对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致垃圾收集器无法自动回收它们的。掌握了泄露对象的类型信息及GC Roots引用链的信息,就可以比较准确地定位出泄露代码的位置。</p><p>&emsp;如果不存在泄露,换句话说,就是内存中的对象确实都还必须存活着,那就应当检查虛拟机的堆参数(-Xmx与-Xms ) ,与机器物理内存对比看是否还可以调大,从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况,尝试减少程序运行期的内存消耗。</p><h2 id="2-虚拟机栈和本地方法栈溢出"><a href="#2-虚拟机栈和本地方法栈溢出" class="headerlink" title="2. 虚拟机栈和本地方法栈溢出"></a>2. 虚拟机栈和本地方法栈溢出</h2><p>&emsp;HotSpot虚拟机中并不区分虚拟机栈和本地方法栈,因此 ,对于HotSpot来 说 ,虽然-Xoss参数 (设置本地方法栈大小)存在 ,但实际上是无效的,栈容量只由-Xss参数设定。 关于虚拟机栈和本地方法栈,在Java虚拟机规范中描述了两种异常:</p><ul><li>如果线程请求的栈深度大于虚拟机所允许的最大深度,将拋出StackOverflowError异常。</li><li>如果虚拟机在扩展栈时无法申请到足够的内存空间,则拋出OutOMemoryError异常。</li></ul><p>&emsp;这里把异常分成两种情况,看似更加严谨,但却存在着一些互相重叠的地方:当栈空间无法继续分配时,到底是内存太小,还是已使用的栈空间太大,其本质上只是对同一件事情的两种描述而已。</p><ul><li>使用-Xss参数减少栈内存容量。结果 :拋出StackOverflowError异常 ,异常出现时输出的堆栈深度相应缩小。</li><li>定义了大量的本地变量,增大此方法帧中本地变量表的长度。结果 :拋出 StackOverflowError异常时输出的堆栈深度相应缩小。</li></ul><p>StackOverflowError异常:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss128k</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackSOF</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> stackLength = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeak</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        stackLength++;</span><br><span class="line">        stackLeak();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        JavaVMStackSOF oom = <span class="keyword">new</span> JavaVMStackSOF();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            oom.stackLeak();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"stack length:"</span> + oom.stackLength);</span><br><span class="line">            <span class="keyword">throw</span> e;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">stack length :2402</span><br><span class="line">Exception in thread&quot;main&quot;java.lang.StackOverflowError</span><br><span class="line">at org.fenixsoft.oom.VMStackSOF.leak (WIStackSOF.java :20) </span><br><span class="line">at org.fenixsoft.oom.VMStackSOF.leak (WIStackSOF.java :21) </span><br><span class="line">at org.fenixsoft.oom.VMStackSOF.leak (WIStackSOF.iava :21) </span><br><span class="line">.....后续异常堆栈信息省略</span><br></pre></td></tr></table></figure><br>&emsp;实验结果表明:在单个线程下,无论是由于栈帧（一个方法中包含的本地变量数）太大还是虚拟机栈容量（-Xss参数减少每个线程栈内存容量）太小,当内存无法分配的时候,虚拟机拋出的都是StackOverflowError异常。</p><p>OutOMemoryError异常：<br>&emsp;通过不断地建立线程的方式倒是可以产生内存溢出异常，但是这样产生的内存溢出异常与栈空间是否足够大并不存在任何联系,或者准确地说，在这种情况下，为每个线程的栈分配的内存越大，反而越容易产生内存溢出异常。</p><p>&emsp;其实原因不难理解,操作系统分配给每个进程的内存是有限制的,譬如32位的Windows 限制为2GB。虚拟机提供了参数来控制Java堆和方法区的这两部分内存的最大值。剩余的内存为2GB ( 操作系统限制)减去Xmx ( 最大堆容量),再减去MaxPermSize (最大方法区容量 ),程序计数器消耗内存很小,可以忽略掉。如果虚拟机进程本身耗费的内存不计算在内 ,剩下的内存就由虚拟机栈和本地方法栈“瓜分” 了。每个线程分配到的栈容量越大,可以建立的线程数量自然就越少,建立线程时就越容易把剩下的内存耗尽。</p><p>&emsp;这一点读者需要在开发多线程的应用时特别注意,出现StackOverflowError异常时有错误堆栈可以阅读,相对来说,比较容易找到问题的所在。而且 ,如果使用虚拟机默认参数,栈深度在大多数情况下(因为每个方法压入栈的帧大小并不是一样的,所以只能说在大多数情况下)达到1000〜2000完全没有问题,对于正常的方法调用(包括递归),这个深度应该完全够用了。但是 ,<strong>如果是建立过多线程导致的内存溢出,在不能减少线程数或者更换64位虚拟机的情况下,就只能通过减少最大堆和减少栈容量来换取更多的线程</strong>。如果没有这方面的处理经验,这种通过“减少内存”的手段来解决内存溢出的方式会比较难以想到。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xss2M （这时候不妨设大些）</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaVMStackOOM</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">dontStop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">stackLeakByThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">              <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">                     Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                   dontStop();</span><br><span class="line">                            &#125;</span><br><span class="line">                     &#125;);</span><br><span class="line">                     thread.start();</span><br><span class="line">              &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">              JavaVMStackOOM oom = <span class="keyword">new</span> JavaVMStackOOM();</span><br><span class="line">              oom.stackLeakByThread();</span><br><span class="line">       &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread&quot;main&quot;java.lang.OutOfMemoryError :unable to create new native thread</span><br></pre></td></tr></table></figure></p><h2 id="3-方法区和运行时常量池溢出"><a href="#3-方法区和运行时常量池溢出" class="headerlink" title="3. 方法区和运行时常量池溢出"></a>3. 方法区和运行时常量池溢出</h2><p>&emsp;由于运行时常量池是方法区的一部分,因此这两个区域的溢出测试就放在一起进行。前面提到JDK 1.7开始逐步“去永久代”的事情,在此就以测试代码观察一下这件事对程序的实际影响。</p><h3 id="3-1-常量池"><a href="#3-1-常量池" class="headerlink" title="3.1 常量池"></a>3.1 常量池</h3><p>&emsp;String.intern() 是一个Native方法,它的作用是:如果字符串常量池中已经包含一个等于此String对象的字符串,则返回代表池中这个字符串的String对 象 ;否则 ,将此String对象包含的字符串添加到常量池中,并且返回此String对象的引用。在JDK 1.6及之前的版本中,由于常量池分配在永久代内,我们可以通过-XX : PermSize和-XX : MaxPermSize限制方法区大小 ,从而间接限制其中常量池的容量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 使用List保持着常量池引用，避免Full GC回收常量池行为</span></span><br><span class="line">        List&lt;String&gt; list = <span class="keyword">new</span> ArrayList&lt;String&gt;();</span><br><span class="line">        <span class="comment">// 10MB的PermSize在integer范围内足够产生OOM了</span></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            list.add(String.valueOf(i++).intern());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread&quot;main&quot;java.lang.OutOfMemoryError :PermGen space</span><br><span class="line">at java.lang.String, intern (Native Method)</span><br><span class="line">at org.fenixsoft.oom.RuntimeConstantPoolOOM.main(RuntimeConstantPoolOOM.java:18)</span><br></pre></td></tr></table></figure><br>&emsp;从运行结果中可以看到,运行时常量池溢出,在OutOfMemoryError后面跟随的提示信息是“<strong>PermGen space</strong>” ,说明运行时常量池属于方法区(HotSpot虚拟机中的永久代)的一部 分。<br>而使用JDK 1.7/1.8运行这段程序就不会得到相同的结果,while循环将一直进行下去。<br>&emsp;关于这个字符串常量池的实现问题,还可以引申出一个更有意思的影响,String.intern()返回引用的测试:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RuntimeConstantPoolOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        String str1 = <span class="keyword">new</span> StringBuilder(<span class="string">"中国"</span>).append(<span class="string">"钓鱼岛"</span>).toString();</span><br><span class="line">        System.out.println(str1.intern() == str1);</span><br><span class="line"></span><br><span class="line">        String str2 = <span class="keyword">new</span> StringBuilder(<span class="string">"ja"</span>).append(<span class="string">"va"</span>).toString();</span><br><span class="line">        System.out.println(str2.intern() == str2);</span><br><span class="line">    &#125;   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;这段代码在JDK 1.6中运行,会得到两个false,而在JDK 1.7/1.8中运行,会得到一个true和一 个false。产生差异的原因是:在JDK 1.6中,intern() 方法会把首次遇到的字符串实例复制到永久代中,返回的也是永久代中这个字符串实例的引用,而由StringBuilder创建的字符串实例在Java堆上,所以必然不是同一个引用,将返回false。而JDK 1.7/1.8 (以及部分其他虚拟机 ,例如JRockit) 的intern() 实现不会再复制实例,只是<strong>在常量池中记录首次出现的实例引用</strong>，因此intern() 返回的引用和由StringBuilder(）创建的那个字符串实例是同一个。对str2比较返回false是因为“java”这个字符串在执行StringBuilder.toString() 之前已经出现过,字符串常量池中已经有它的引用了,不符合“ 首次出现” 的原则 ,而“计算机软件”这个字符串则是首次出现的,因此返回true。</p><h3 id="3-2-方法区"><a href="#3-2-方法区" class="headerlink" title="3.2 方法区"></a>3.2 方法区</h3><p>&emsp;方法区用于存放Class的相关信息,如类名、访问修饰符、常量池、字段描述、方法描述 等。对于这些区域的测试,基本的思路是运行时产生大量的类去填满方法区,直到溢出。虽然直接使用Java SE API也可以动态产生类(如反射时的GeneratedConstmctorAccessor和动态代理等),但在本次实验中操作起来比较麻烦。在下面代码中,借助CGLib直接操作字节码运行时生成了大量的动态类。</p><p>&emsp;值得特别注意的是,我们在这个例子中模拟的场景并非纯粹是一个实验,这样的应用经常会出现在实际应用中:当前的很多主流框架,如Spring、Hibernate ,在对类进行增强时, 都会使用到CGLib这类字节码技术,增强的类越多,就需要越大的方法区来保证动态生成的 Class可以加载入内存。另外,JVM上的动态语言(例如Groovy等 )通常都会持续创建类来实现语言的动态性,随着这类语言的流行,也越来越容易遇到与下面相似的溢出场景。</p><p>借助CGLib使方法区出现内存溢出异常:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args： -XX:PermSize=10M -XX:MaxPermSize=10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaMethodAreaOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            Enhancer enhancer = <span class="keyword">new</span> Enhancer();</span><br><span class="line">            enhancer.setSuperclass(OOMObject<span class="class">.<span class="keyword">class</span>)</span>;</span><br><span class="line">            enhancer.setUseCache(<span class="keyword">false</span>);</span><br><span class="line">            enhancer.setCallback(<span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object obj, Method method, Object[] args, MethodProxy proxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> proxy.invokeSuper(obj, args);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            enhancer.create();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">OOMObject</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Caused by :java.lang.OutOfMemoryError :PermGen space</span><br><span class="line">at java.lang.ClassLoader.defineClassl (Native Method)</span><br><span class="line">at java.lang.ClassLoader.defineClassCond (ClassLoader. java :632 ) at java.lang.ClassLoader.defineClass (ClassLoader.java :616 )</span><br><span class="line">— 8 more</span><br></pre></td></tr></table></figure><br>&emsp;方法区溢出也是一种常见的内存溢出异常,一个类要被垃圾收集器回收掉,判定条件是比较苛刻的。<strong>在经常动态生成大量Class的应用中,需要特别注意类的回收状况</strong>。这类场景除了上面提到的程序使用了<strong>CGLib</strong>字节码增强和动态语言之外,常见的还有:大量<strong>JSP</strong>或动态产生JSP文件的应用(JSP第一次运行时需要编译为Java类 )、基于<strong>OSGi</strong>的应用(即使是同一个类文件,被不同的加载器加载也会视为不同的类)等。</p><h2 id="4-本机直接内存溢出"><a href="#4-本机直接内存溢出" class="headerlink" title="4. 本机直接内存溢出"></a>4. 本机直接内存溢出</h2><p>&emsp;DirectMemory容量可通过-XX : MaxDirectMemorySize指定,如果不指定,则默认与Java堆最大值(-Xmx指定)一样 ,下面代码越过了DirectByteBuffer类 ,直接通过反射获取Unsafe实例进行内存分配(Unsafe类的getUnsafe()方法限制了只有引导类加载器才会返回实例,也就是设计者希望只有rt.jar中的类才能使用Unsafe的功能)。因为,虽然使用 DirectByteBuffer分配内存也会拋出内存溢由异常,但它抛出异常时并没有真正向操作系统申请分配内存,而是通过计算得知内存无法分配,于是手动拋出异常,真正申请分配内存的方法unsafe.allocateMemory()。<br>使用unsafe分配本机内存：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * VM Args：-Xmx20M -XX:MaxDirectMemorySize=10M</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zzm</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DirectMemoryOOM</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> _1MB = <span class="number">1024</span> * <span class="number">1024</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Field unsafeField = Unsafe.class.getDeclaredFields()[0];</span><br><span class="line">        unsafeField.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">        Unsafe unsafe = (Unsafe) unsafeField.get(<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>) &#123;</span><br><span class="line">            unsafe.allocateMemory(_1MB);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exception in thread&quot;main&quot;java.lang.OutOfMemoryError at sun.misc.Unsafe .allocateMemory (Native Method ) at org. fenixsoft. oom.DMOOM.main (DMOOM.java :20 )</span><br></pre></td></tr></table></figure><br>&emsp;由DirectMemory导致的内存溢出,一个明显的特征是在Heap Dump文件中不会看见明显的异常,如果读者发现OOM之后Dump文件很小,而程序中又直接或间接使用了NIO,那就可以考虑检查一下是不是这方面的原因。</p><p>&nbsp;</p><blockquote><p>参考：<br>《深入理解Java虚拟机》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>深入理解Java虚拟机 之 Java内存区域</title>
      <link href="/java/java-memory-area/"/>
      <url>/java/java-memory-area/</url>
      
        <content type="html"><![CDATA[<h1 id="Java内存区域"><a href="#Java内存区域" class="headerlink" title="Java内存区域"></a>Java内存区域</h1><p>&emsp;对C和C++的开发人员来说，在内存管理领域，他们既拥有每一个对象的“所有权”，也担负着每一个对象生命开始到终结的维护责任。<br>&emsp;对Java程序猿来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄露和内存溢出的问题。但是也出现问题：如果不理解虚拟机是怎么使用内存的，排查错误将会是一项非常艰难的工作。</p><h2 id="1-运行时数据区域"><a href="#1-运行时数据区域" class="headerlink" title="1. 运行时数据区域"></a>1. 运行时数据区域</h2><p>&emsp;Java虚拟机在执行Java程序的时候，会把它所管理的的内存分成若干个不同的数据区。包括如下几部分:<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/memory-area.jpg?raw=true" alt="memory-area"></p><h3 id="1-1-程序计数器"><a href="#1-1-程序计数器" class="headerlink" title="1.1 程序计数器"></a>1.1 程序计数器</h3><p>&emsp;程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的<strong>行号指示器</strong>。字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖与其完成。<br>&emsp;每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立储存，我们称这类内存区域为”<strong>线程私有</strong>“的内存。<br>&emsp;如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 <strong>Native</strong> 方法，这个计数器值则为空（Undefined）。<strong>此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError 情况的区域</strong>。</p><h3 id="1-2-Java-虚拟机栈-VM-Stack"><a href="#1-2-Java-虚拟机栈-VM-Stack" class="headerlink" title="1.2 Java 虚拟机栈 VM Stack"></a>1.2 Java 虚拟机栈 VM Stack</h3><p>&emsp;Java 虚拟机栈也是线程私有，与线程生命周期相同。虚拟机栈描述的是 Java 执行方法的内存模型。每个方法在执行时会创建一个<strong>栈帧</strong>，栈帧内存储的是局部变量表，操作数栈，动态链接，方法出口等信息。每个方法从调用直到执行完成，就是一个栈帧入栈到出栈的过程。<br>&emsp;局部变量表存放了编译期可知的各种<strong>基本数据类型</strong>（boolean、byte、char、short、int、float、<strong>对象引用reference</strong>(实际内存在堆上分配，引用指向在堆中分配的内存地址)）。其中64位长度的long和double会占用2个局部变量空间（Slot），其余数据类型只占用一个。<strong>局部变量表所需的内存空间在编译期间完成分配</strong>，当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期不会改变局部变量表的大小。</p><p>&emsp;虚拟机栈这块区域规定了两种异常：</p><ul><li>StackOverflowError：线程请求栈深度大于虚拟机所允许的深度。</li><li>OutOfMemoryError：虚拟机栈扩展时无法申请到足够内存。</li></ul><h3 id="1-3-本地方法栈-Native-Method-Stack"><a href="#1-3-本地方法栈-Native-Method-Stack" class="headerlink" title="1.3 本地方法栈 Native Method Stack"></a>1.3 本地方法栈 Native Method Stack</h3><p>&emsp;本地方法栈与虚拟机栈作用相似，区别就是虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务，有些虚拟机（如Sun HotSpot）将两者合并。</p><h3 id="1-4-Java-堆-Heap"><a href="#1-4-Java-堆-Heap" class="headerlink" title="1.4 Java 堆 Heap"></a>1.4 Java 堆 Heap</h3><p>&emsp;Java 堆是 Java 虚拟机所管理的内存最大的一块，Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：<strong>所有的对象实例以及数组都在这里分配内存</strong>，但是随着 JIT 编译器的发展和逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有对象在堆上分配逐渐变得不是那么”绝对“。<br>&emsp;<strong>Java 堆是垃圾收集器管理的主要区域</strong>。为了更好的回收或者分配内存，堆可能会被分为多个区域，例如分代收集算法的垃圾回收器会将堆分为新生代和老年代（当然还可以继续细分：Eden、From Survivor、To Survivor等）。但不管如何划分，每个区间存储的内容是不变的，都是对象实例。<br>另外，堆在内存中并不是物理连续的，只要逻辑连续即可。当向堆申请内存（实例化对象），而堆中找不到这么大的空间时）会抛出OutOfMemoryError（最新虚拟机都可动态扩展，但扩无可扩时也会抛错）。</p><h3 id="1-5-方法区-Mtthod-Area"><a href="#1-5-方法区-Mtthod-Area" class="headerlink" title="1.5 方法区 Mtthod Area"></a>1.5 方法区 Mtthod Area</h3><p>&emsp;方法区是各个线程<strong>共享</strong>的内存区域。方法区内存储的是已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。一些虚拟机实现上，将方法区称为 <strong>“永久代”(Permanent Generation)</strong>，意味着垃圾回收器可以向管理堆一样来管理这块内存。但本质上，方法区和永久代是不等价的，使用永久代来实现方法区可能会遇到内存溢出的问题。而且极少数方法(例如String.intern())在不同的虚拟上会因为该机制而表现不同。<br>&emsp;方法区内存回收的主要目标是针对常量池的回收和对类型的卸载。<br>&emsp;当方法区无法满足内存分配要求时，将抛出 OutOfMemoryError 异常。</p><h3 id="1-6-运行时常量池-Runtime-Constant-Pool"><a href="#1-6-运行时常量池-Runtime-Constant-Pool" class="headerlink" title="1.6 运行时常量池 Runtime Constant Pool"></a>1.6 运行时常量池 Runtime Constant Pool</h3><p>&emsp;运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放在编译期会生成各种字面量和符号引用，这部分内容将在类加载后，放入到方法区的运行时常量池中存放。<br>&emsp;<strong>运行时常量池</strong>相对于<strong>Class文件常量池</strong>的另外一个重要特征是具备动态性。并非只有预置入Class文件中的常量池的部分才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，例如String类的intern()方法。<br>&emsp;运行时常量池属于方法区的一部分，所以当申请不到内存的时候，会抛出 OutOfMemoryError 异常。 </p><h3 id="1-7-直接内存-Direct-Memory"><a href="#1-7-直接内存-Direct-Memory" class="headerlink" title="1.7 直接内存 Direct Memory"></a>1.7 直接内存 Direct Memory</h3><p>&emsp;直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。<br>&emsp;在 JDK1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以<strong>使用 Native 函数库直接分配堆外内存</strong>，然后通过一个存储在 Java &emsp;堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。<br>直接内存不会受到 Java 堆大小限制，但会受到内机总内存的限制，动态扩展时可能出现 OutOfMemoryError。</p><h2 id="2-HotSpot-虚拟机对象探秘"><a href="#2-HotSpot-虚拟机对象探秘" class="headerlink" title="2. HotSpot 虚拟机对象探秘"></a>2. HotSpot 虚拟机对象探秘</h2><h3 id="2-1-对象的创建"><a href="#2-1-对象的创建" class="headerlink" title="2.1 对象的创建"></a>2.1 对象的创建</h3><p>&emsp;在语言层面，创建一个新的对象只需要使用 new 关键字就可以，而在虚拟机上，对象的创建需要经过下面几个步骤：</p><ul><li><ol><li>类加载</li></ol></li><li><ol><li>为新生对象分配内存</li></ol></li><li><ol><li>初始化</li></ol></li><li><ol><li>设置对象头</li></ol></li><li><ol><li>调用 init 方法</li></ol></li></ul><ol><li><p>类加载<br>虚拟机遇到一条 new 指令时，首先将去检查指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 </p></li><li><p>为新生对象分配内存<br>在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。</p></li></ol><p>&emsp;对象分配方式有：</p><ul><li><p>1.指针碰撞（Bump the Pointer)<br>假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把哪个指针向空闲那边挪动一段与对象大小相等的距离。</p></li><li><p>2.空闲列表（Free List)<br>如果 Java 堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。</p></li></ul><p>&emsp;选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。</p><p>&emsp;对象创建的线程安全性问题：<br>&emsp;对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配地址，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案。</p><p>方案一：对分配内存空间的动作进行<strong>同步处理</strong>，虚拟机采用 CAS 配上失败重试 的方式保证更新操作的原子性。<br>方案二：将内存分配的动作按照线程划分在不同的空间中进行，每个线程在 Java 堆中预先分配一小块内存，称为 本地线程分配缓冲（Thread Local Allocation Buffer, <strong>TLAB</strong>） 。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。通过 -XX:+/-UseTLAB 参数设定是否使用 TLAB。</p><ol><li><p>初始化<br>&emsp;内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB，这一过程就可以提前至 TLAB 分配时进行。<br>这一步保证对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型对应的零值。</p></li><li><p>设置对象头<br>&emsp;接下来，虚拟机要为对象头数据进行设置，例如对象的实例类、类的元数据信息的地址、对象的哈希码、对象的 GC 分代年龄等。</p></li><li><p>调用 init 方法<br>&emsp;在上面步骤完成后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的角度来看，对象的创建才刚刚开始，<init> 方法还没有被执行，所有的字段还为零值。一般来说，执行 new 指令之后会接着执行 <init> 方法，将对象按照程序员的意愿进行初始化，这样一个真正的对象才算完全产生。</p></li></ol><h3 id="2-2-对象的内存布局"><a href="#2-2-对象的内存布局" class="headerlink" title="2.2 对象的内存布局"></a>2.2 对象的内存布局</h3><p>&emsp;在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为以下 3 块区域:</p><ul><li><ol><li>对象头（Header）</li></ol></li><li><ol><li>实例数据（Instance Data）</li></ol></li><li><ol><li>对齐填充（Padding）</li></ol></li></ul><ol><li>对象头<br>&emsp;HotSpot 虚拟机的对象头包括两部分信息，存储对象自身的运行时数据的（Mark Word） 和 类型指针。</li></ol><p>1.1 Mark Word<br>&emsp;用于存储对象自身的运行时数据，如（HashCode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳），这部分数据的长度在 32 位和 64 位的虚拟机中（未开启压缩指针）分别为 32bit 和 64bit。对象需要存储的运行时数据很多，其实已经超出了 32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个 非固定的数据结构 以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。<br>HotSpot 虚拟机对象头 Mark Word 表如下：<br>|                存储内容               | 标志位 |        状态        |<br>|:——————————————————-:|:———:|:—————————:|<br>|        对象哈希码、对象分代年龄       |   01   |       未锁定       |<br>|            指向锁记录的指针           |   00   |     轻量级锁定     |<br>|           指向重量级锁的指针          |   10   | 膨胀（重量级锁定） |<br>|          空（不需要记录信息）         |   11   |       GC 标记      |<br>| 偏向线程 ID、偏向时间戳、对象分代年龄 |   01   |       可偏向       |</p><p>1.2 类型指针<br>&emsp;对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。<br>并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据并不一定要经过对象本身。如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。</p><ol><li><p>实例数据<br>&emsp;实例数据是对象真正储存的有效信息，也是程序代码中所定义的各种类型的字段内存。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。</p></li><li><p>对齐填充<br>&emsp;不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求 对象起始地址必须是 8 字节的整倍数，换句话说，就是对象的大小必须是 8 字节的整倍数。而对象头部分正好是 8 字节的整倍数（ 1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。</p></li></ol><h3 id="2-3-对象的访问定位"><a href="#2-3-对象的访问定位" class="headerlink" title="2.3 对象的访问定位"></a>2.3 对象的访问定位</h3><p>&emsp;Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。如何通过这个引用去定位、访问堆中对象的具体位置，取决于虚拟机的实现，目前主流的有两种方式：</p><ul><li>使用句柄</li><li>直接指针</li></ul><ol><li><p>使用句柄<br>&emsp;Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/handle-access-object.jpg?raw=true" alt="handle"></p></li><li><p>直接指针<br>&emsp;Java 堆对象的布局中必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/pointer-access-object.jpg?raw=true" alt="pointer"></p></li></ol><p>&emsp;使用句柄访问的最大好处就是 reference 中存储的是 稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。<br>&emsp;使用直接访问最大的好处就是速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。</p><p>&emsp;Sun HotSpot 虚拟机使用的是直接指针方式访问对象，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。</p><p>&nbsp;</p><blockquote><p>参考：<br>《深入理解Java虚拟机》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>volatile 的特殊规则和 long&amp;&amp;double 的非原子协定</title>
      <link href="/java/java-special-variable/"/>
      <url>/java/java-special-variable/</url>
      
        <content type="html"><![CDATA[<h1 id="1-volatile-型变量的特殊规则"><a href="#1-volatile-型变量的特殊规则" class="headerlink" title="1. volatile 型变量的特殊规则"></a>1. volatile 型变量的特殊规则</h1><p>&emsp;关键字volatile可以说是Java虚拟机提供的最轻量级的同步机制，但是它并不容易完全被正确、完整地理解，以至于许多程序员都习惯不去使用它，遇到需要处理多线程数据竞争问题的时候一律使用synchronized来进行同步，了解volatile变量的语义对后面了解多线程操作的其他特性很有意义。<br>&emsp;当一个变量定义为volatile之后，它将具备两种特性，第一是保证此变量对所有线程的<strong>可见性</strong>，第二个语义是<strong>禁止指令重排序优化</strong>。</p><h2 id="1-1-可见性"><a href="#1-1-可见性" class="headerlink" title="1.1 可见性"></a>1.1 可见性</h2><p>&emsp;这里的“可见性”是指当一条线程修改了这个变量的值，新值对于其他线程来说是可以立即得知的。 而普通变量不能做到这一点，普通变量的值在线程间传递均需要通过主内存来完成，例如，线程A修改一个普通变量的值，然后向主内存进行回写，另外一条线程B在线程A回写完成了之后再从主内存进行读取操作，新变量值才会对线程B可见。</p><p>&emsp;关于 volatile 变量的可见性，经常会被开发人员误解，认为以下描述成立：“volatile变量对所有线程是立即可见的，对volatile变量所有的写操作都能立刻反应到其他线程之中，换句话说，volatile变量在各个线程中是一致的，所以基于volatile变量的运算在并发下是安全的”。 这句话的论据部分并没有错，但是其论据并不能得出“基于volatile变量的运算在并发下是安全的”这个结论。volatile变量在各个线程的工作内存中不存在一致性问题（在各个线程的工作内存中，volatile变量也可以存在不一致的情况，但由于每次使用之前都要先刷新，执行引擎看不到不一致的情况，因此可以认为不存在一致性问题），但是<strong>Java里面的运算并非原子操作，导致 volatile 变量的运算在并发下一样是不安全的</strong>，我们可以通过一段简单的演示来说明原因，请看如下代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VolatileTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">volatile</span> <span class="keyword">int</span> race = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        race++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> THREADS_COUNT = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Thread[] threads = <span class="keyword">new</span> Thread[THREADS_COUNT];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; THREADS_COUNT; i++) &#123;</span><br><span class="line">            threads[i] = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000</span>; i++) &#123;</span><br><span class="line">                        increase();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">            threads[i].start();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//等待所有累加线程都结束</span></span><br><span class="line">        <span class="keyword">while</span> (Thread.activeCount() &gt; <span class="number">1</span>)</span><br><span class="line">            Thread.yield();</span><br><span class="line">        System.out.println(race);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;这段代码发起了20个线程，每个线程对race变量进行10000次自增操作，如果这段代码能够正确并发的话，最后输出的结果应该是200000。 读者运行完这段代码之后，并不会获得期望的结果，而且会发现每次运行程序，输出的结果都不一样，都是一个小于200000的数字，这是为什么呢？</p><p>&emsp;问题就出现在自增运算“race++”之中，我们用Javap反编译这段代码后会得到代码清单，发现只有一行代码的 increase() 方法在Class文件中是由4条字节码指令构成的（return指令不是由race++产生的，这条指令可以不计算），从字节码层面上很容易就分析出并发失败的原因了：当 getstatic 指令把 race 的值取到操作栈顶时，volatile 关键字保证了 race 的值在此时是正确的，但是在执行 iconst_1、iadd 这些指令的时候，其他线程可能已经把 race 的值加大了，而在操作栈顶的值就变成了过期的数据，所以 putstatic 指令执行后就可能把较小的 race 值同步回主内存之中。下面是 VolatileTest 的字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">public static void increase（）；</span><br><span class="line">Code：</span><br><span class="line">Stack&#x3D;2，Locals&#x3D;0，Args_size&#x3D;0</span><br><span class="line">0：getstatic#13；&#x2F;&#x2F;Field race：I</span><br><span class="line">3：iconst_1</span><br><span class="line">4：iadd</span><br><span class="line">5：putstatic#13；&#x2F;&#x2F;Field race：I</span><br><span class="line">8：return</span><br><span class="line">LineNumberTable：</span><br><span class="line">line 14：0</span><br><span class="line">line 15：8</span><br></pre></td></tr></table></figure><br>&emsp;客观地说，在此使用字节码来分析并发问题，仍然是不严谨的，因为即使编译出来只有一条字节码指令，也并不意味执行这条指令就是一个原子操作。 一条字节码指令在解释执行时，解释器将要运行许多行代码才能实现它的语义，如果是编译执行，一条字节码指令也可能转化成若干条本地机器码指令，此处使用 -XX：+PrintAssembly 参数输出反汇编来分析会更加严谨一些，但考虑到读者阅读的方便，并且字节码已经能说明问题，所以此处使用字节码来分析。</p><p><strong>由于 volatile 变量只能保证可见性，如果符合以下两条规则才能保证原子性</strong>：</p><ul><li>1.运算结果并不依赖变量的当前值，或者能够确保只有单一的线程修改变量的值。 </li><li>2.变量不需要与其他的状态变量共同参与不变约束。</li></ul><p>&emsp;如果在不符合以下两条规则的运算场景中，我们仍然要通过<strong>加锁（使用synchronized或java.util.concurrent中的原子类）来保证原子性</strong>。</p><p>&emsp;而在像如下的代码所示的场景就很适合使用volatile变量来控制并发，当shutdown（）方法被调用时，能保证所有线程中执行的doWork（）方法都立即停下来：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> shutdownRequested;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">shutdown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        shutdownRequested = <span class="keyword">true</span>; <span class="comment">//直接赋值，不依赖于当前值，且没有其他约束</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doWork</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!shutdownRequested) &#123;</span><br><span class="line">        <span class="comment">//do stuff</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="1-2-禁止指令重排序优化"><a href="#1-2-禁止指令重排序优化" class="headerlink" title="1.2 禁止指令重排序优化"></a>1.2 禁止指令重排序优化</h2><p>&emsp;使用volatile变量的第二个语义是禁止指令重排序优化，普通的变量仅仅会保证在该方法的执行过程中所有依赖赋值结果的地方都能获取到正确的结果，而不能保证变量赋值操作的顺序与程序代码中的执行顺序一致。 因为在一个线程的方法执行过程中无法感知到这点，这也就是Java内存模型中描述的所谓的“<strong>线程内表现为串行的语义</strong>”（Within-Thread As-If-SerialSemantics）。<br>上面的描述仍然不太容易理解，我们还是继续通过一个例子来看看为何指令重排序会干扰程序的并发执行，演示程序如代码如下所示:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Map configOptions;</span><br><span class="line"><span class="keyword">char</span>[]configText;</span><br><span class="line"><span class="comment">//此变量必须定义为volatile</span></span><br><span class="line"><span class="keyword">volatile</span> <span class="keyword">boolean</span> initialized=<span class="keyword">false</span>;</span><br><span class="line"><span class="comment">//假设以下代码在线程A中执行</span></span><br><span class="line"><span class="comment">//模拟读取配置信息，当读取完成后将initialized设置为true以通知其他线程配置可用</span></span><br><span class="line">configOptions=<span class="keyword">new</span> HashMap();</span><br><span class="line">configText=readConfigFile(fileName);</span><br><span class="line">processConfigOptions(configText,configOptions);</span><br><span class="line">initialized=<span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//假设以下代码在线程B中执行</span></span><br><span class="line"><span class="comment">//等待initialized为true，代表线程A已经把配置信息初始化完成</span></span><br><span class="line"><span class="keyword">while</span>(！initialized)&#123;</span><br><span class="line">    sleep();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//使用线程A中初始化好的配置信息</span></span><br><span class="line">doSomethingWithConfig();</span><br></pre></td></tr></table></figure><br>&emsp;以上是一段伪代码，其中描述的场景十分常见，只是我们在处理配置文件时一般不会出现并发而已。 如果定义initialized变量时没有使用volatile修饰，就可能会由于指令重排序的优化，导致位于线程A中最后一句的代码“initialized=true”被提前执行（这里虽然使用Java作为伪代码，但所指的重排序优化是机器级的优化操作，提前执行是指这句话对应的汇编代码被提前执行），这样在线程B中使用配置信息的代码就可能出现错误，而volatile关键字则可以避免此类情况的发生。</p><p>&emsp;指令重排序是并发编程中最容易让开发人员产生疑惑的地方，除了上面伪代码的例子之外，再举一个可以实际操作运行的例子来分析volatile关键字是如何禁止指令重排序优化的。下面代码是一段标准的DCL单例代码，可以观察加入volatile和未加入volatile关键字时所生成汇编代码的差别。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Singleton</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">static</span> Singleton instance;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Singleton <span class="title">getInstance</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (Singleton<span class="class">.<span class="keyword">class</span>) </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (instance == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    instance = <span class="keyword">new</span> Singleton();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Singleton.getInstance();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;编译后，这段代码对instance变量赋值部分如下所示：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0x01a3de0f：mov$0x3375cdb0，%esi；……beb0cd75 33</span><br><span class="line">；&#123;oop（&#39;Singleton&#39;）&#125;</span><br><span class="line">0x01a3de14：mov%eax，0x150（%esi）；……89865001 0000</span><br><span class="line">0x01a3de1a：shr$0x9，%esi；……c1ee09</span><br><span class="line">0x01a3de1d：movb$0x0，0x1104800（%esi）；……c6860048 100100</span><br><span class="line">0x01a3de24：lock addl$0x0，（%esp）；……f0830424 00</span><br><span class="line">；*putstatic instance</span><br><span class="line">；-</span><br><span class="line">Singleton：getInstance@24</span><br></pre></td></tr></table></figure></p><p>&emsp;通过对比发现，关键变化在于有volatile修饰的变量，赋值后（前面mov%eax，0x150（%esi）这句便是赋值操作）多执行了一个“<strong>lock</strong> addl ＄0x0，（%esp）”操作，这个操作相当于一个<strong>内存屏障</strong>（Memory Barrier或Memory Fence，指重排序时不能把后面的指令重排序到内存屏障之前的位置），只有一个CPU访问内存时，并不需要内存屏障；但如果有两个或更多CPU访问同一块内存，且其中有一个在观测另一个，就需要内存屏障来保证一致性了。 这句指令中的“addl ＄0x0，（%esp）”（把ESP寄存器的值加0）显然是一个空操作（采用这个空操作而不是空操作指令nop是因为IA32手册规定lock前缀不允许配合nop指令使用），关键在于lock前缀，查询IA32手册，它的作用是使得本CPU的Cache写入了内存，该写入动作也会引起别的CPU或者别的内核无效化（Invalidate）其Cache，这种操作相当于对Cache中的变量做了一次前面介绍Java内存模式中所说的“store和write”操作[2]。 所以通过这样一个空操作，可让前面volatile变量的修改对其他CPU立即可见。</p><p>&emsp;那为何说它禁止指令重排序呢？从硬件架构上讲，指令重排序是指CPU采用了允许将多条指令不按程序规定的顺序分开发送给各相应电路单元处理。 但并不是说指令任意重排，CPU需要能正确处理指令依赖情况以保障程序能得出正确的执行结果。 譬如指令1把地址A中的值加10，指令2把地址A中的值乘以2，指令3把地址B中的值减去3，这时指令1和指令2是有依赖的，它们之间的顺序不能重排——（A+10）<em>2与A</em>2+10显然不相等，但指令3可以重排到指令1、 2之前或者中间，只要保证CPU执行后面依赖到A、 B值的操作时能获取到正确的A和B值即可。 所以在本内CPU中，重排序看起来依然是有序的。 因此，lockaddl＄0x0，（%esp）指令把修改同步到内存时，意味着所有之前的操作都已经执行完成，这样便形成了“指令重排序无法越过内存屏障”的效果。</p><p>&emsp;解决了volatile的语义问题，再来看看在众多保障并发安全的工具中选用volatile的意义——它能让我们的代码比使用其他的同步工具更快吗？在某些情况下，volatile的同步机制的性能确实要优于锁（使用synchronized关键字或java.util.concurrent包里面的锁），但是由于虚拟机对锁实行的许多消除和优化，使得我们很难量化地认为volatile就会比synchronized快多少。 如果让volatile自己与自己比较，那可以确定一个原则：<strong>volatile变量读操作的性能消耗与普通变量几乎没有什么差别，但是写操作则可能会慢一些，因为它需要在本地代码中插入许多内存屏障指令来保证处理器不发生乱序执行。 不过即便如此，大多数场景下volatile的总开销仍然要比锁低，我们在volatile与锁之中选择的唯一依据仅仅是volatile的语义能否满足使用场景的需求</strong>。</p><blockquote><p>关于volatile的正确使用可以参考<a href="https://blog.csdn.net/sted_zxz/article/details/76615583" target="_blank" rel="noopener">正确使用 Volatile 变量</a>。</p></blockquote><h1 id="2-long-和-double-的非原子协定"><a href="#2-long-和-double-的非原子协定" class="headerlink" title="2. long 和 double 的非原子协定"></a>2. long 和 double 的非原子协定</h1><p>&emsp;Java内存模型要求lock、unlock、read、load、use、assign、store、write这8个操作都具有原子性。但是对于64位的数据类型（long和double），在模型中特别定义了一条相对宽松的规定：允许虚拟机将没有被 volatile 修饰的64位数据读写操作划分为2次32位的操作来进行，即<strong>允许虚拟机实现选择可以不保证64位数据类型的read、load、store、write这4个操作的原子性</strong>。这点就是所谓的 <strong>long 和 double 的非原子协定</strong>。</p><p>&emsp;如果有多个线程共享一个并未被 volatile 修饰的64位数据类型变量（long或double类型），并且同时对它们进行读取和修改操作，那么某些线程可能会读取到一个既非原值，也不是其他线程修改值的代表了“半个变量”的数值。</p><p>&emsp;不过这种读取到“半个变量”的情况非常罕见（目前商用的Java虚拟机中不会出现），因为Java内存模型虽然允许虚拟机不把long和double类型变量的读写实现成原子操作，但允许虚拟机选择把这些操作实现为具有原子性的操作，而且还“强烈建议”虚拟机这样实现。目前各种平台下的商用虚拟机几乎都选择把64位数据的读写操作作为原子操作来对待，因为我们再编写代码时无需把 long 和 double 类型变量专门声明为 volatile。</p><p>&nbsp;</p><blockquote><p>参考：<br>《深入理解JAVA虚拟机》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jvm </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发容器 之 ConcurrentLinkedQueue</title>
      <link href="/java/java-ConcurrentLinkedQueue/"/>
      <url>/java/java-ConcurrentLinkedQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="ConcurrentLinkedQueue-详解"><a href="#ConcurrentLinkedQueue-详解" class="headerlink" title="ConcurrentLinkedQueue 详解"></a>ConcurrentLinkedQueue 详解</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;在并发编程中我们有时候需要使用线程安全的队列。如果我们要实现一个线程安全的队列有两种实现方式：</p><ul><li>阻塞算法，使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现。</li><li>非阻塞算法，非阻塞的实现方式则可以使用循环CAS的方式来实现。</li></ul><p>&emsp;下面我们一起来研究下Doug Lea是如何使用非阻塞的方式来实现线程安全队列ConcurrentLinkedQueue的。</p><p>&emsp;ConcurrentLinkedQueue是一个基于链接节点的无界线程安全队列，它采用先进先出的规则对节点进行排序，当我们添加一个元素的时候，它会添加到队列的尾部，当我们获取一个元素时，它会返回队列头部的元素。它采用了“wait－free”算法来实现，该算法在Michael &amp; Scott算法上进行了一些修改。</p><p>&emsp;ConcurrentLinkedQueue的类图如下：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/ConcurrentLinkedQueue/ConcurrentLinkedQueue.png" alt="ConcurrentLinkedQueue"></p><p>&emsp;ConcurrentLinkedQueue由head节点和tail节点组成，每个节点（Node）由节点元素（item）和指向下一个节点的引用(next)组成，节点与节点之间就是通过这个next关联起来，从而组成一张链表结构的队列。</p><h2 id="2-源码详解"><a href="#2-源码详解" class="headerlink" title="2. 源码详解"></a>2. 源码详解</h2><h3 id="2-1-构造"><a href="#2-1-构造" class="headerlink" title="2.1 构造"></a>2.1 构造</h3><p>&emsp;我们前面介绍了，ConcurrentLinkedQueue的节点都是Node类型的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> E item;</span><br><span class="line">        <span class="keyword">volatile</span> Node&lt;E&gt; next;</span><br><span class="line"></span><br><span class="line">        Node(E item) &#123;</span><br><span class="line">            UNSAFE.putObject(<span class="keyword">this</span>, itemOffset, item);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casItem</span><span class="params">(E cmp, E val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, itemOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">lazySetNext</span><span class="params">(Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            UNSAFE.putOrderedObject(<span class="keyword">this</span>, nextOffset, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">boolean</span> <span class="title">casNext</span><span class="params">(Node&lt;E&gt; cmp, Node&lt;E&gt; val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapObject(<span class="keyword">this</span>, nextOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> itemOffset;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> nextOffset;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; k = Node<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                itemOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"item"</span>));</span><br><span class="line">                nextOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (k.getDeclaredField(<span class="string">"next"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;Node 代码中使用了 UNSAFE 提供的 CAS 方法保证操作的原子性。<br>&emsp;Node 类中的 lazySetNext(Node<E> val) 方法，可以理解为延迟设置 Next，内部是使用 UNSAFE 类的 putOrderedObject 方法实现，putOrderedXXX 方法是 putXXXVolatile 方法的延迟实现，不保证值的改变被其他线程立即看到。为什么要 <strong>lazySetNext</strong> 这个方法呢？其实它是一种<strong>低级别的优化手段</strong>，就是在不需要让共享变量的修改立刻让其他线程可见的时候，以设置普通变量的方式来修改共享状态，可以<strong>减少不必要的内存屏障，从而提高程序执行的效率</strong>。<br>&emsp;《Java内存模型中》提到 volatile 变量可以实现可见性，其原理就是插入内存屏障以保证不会重排序指令，使用的是 store-load 内存屏障，开销较大。UNSAFE 类的 putOrderedXXX 方法则是在指令中插入 <strong>StoreStore</strong> 内存屏障，避免发生写操作重排序，由于 StoreStore 屏障的性能损耗小于 StoreLoad 屏障，所以 lazySetNext 方法比直接写 volatile 变量的性能要高。需要注意的是，StoreStore 屏障仅可以避免写写重排序，不保证内存可见性。<br>&emsp;在出队操作中更新 Queue的Head 节点时用到了 lazySetNext(Node<E> val) 方法，将旧 head 节点的 next 指向自己。</p><p>&emsp;ConcurrentLinkedQueue类有下面两个构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//volatile类型</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; head;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">volatile</span> Node&lt;E&gt; tail;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//默认情况下head节点存储的元素为空，tail节点等于head节点。</span></span><br><span class="line">    head = tail = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ConcurrentLinkedQueue</span><span class="params">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class="line">    Node&lt;E&gt; h = <span class="keyword">null</span>, t = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">for</span> (E e : c) &#123;</span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">        <span class="keyword">if</span> (h == <span class="keyword">null</span>)</span><br><span class="line">            h = t = newNode;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            t.lazySetNext(newNode);</span><br><span class="line">            t = newNode;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (h == <span class="keyword">null</span>)</span><br><span class="line">        h = t = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);</span><br><span class="line">    head = h;</span><br><span class="line">    tail = t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-2-入队"><a href="#2-2-入队" class="headerlink" title="2.2 入队"></a>2.2 入队</h3><p>&emsp;入队列就是将入队节点添加到队列的尾部。为了方便理解入队时队列的变化，以及head节点和tail节点的变化，添加节点的过程可以看下面的队列快照图：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/ConcurrentLinkedQueue/EnQueue.png" alt="EnQueue"></p><p>&emsp;上图所示的元素添加过程如下：</p><ul><li>添加元素1：队列更新head节点的next节点为元素1节点。又因为tail节点默认情况下等于head节点，所以它们的next节点都指向元素1节点。</li><li>添加元素2：队列首先设置元素1节点的next节点为元素2节点，然后更新tail节点指向元素2节点。</li><li>添加元素3：设置tail节点的next节点为元素3节点。</li><li>添加元素4：设置元素3的next节点为元素4节点，然后将tail节点指向元素4节点。</li></ul><p>&emsp;入队操作主要做两件事情:</p><ul><li>第一是将入队节点设置成当前队列尾节点的下一个节点。</li><li>第二是更新tail节点，如果tail节点的next节点不为空，则将入队节点设置成tail节点，如果tail节点的next节点为空，则将入队节点设置成tail的next节点，所以<strong>tail节点不总是尾节点</strong>，理解这一点很重要。</li></ul><p>&emsp;上面的分析让我们从单线程入队的角度来理解入队过程，但是多个线程同时进行入队情况就变得更加复杂，因为可能会出现其他线程插队的情况。如果有一个线程正在入队，那么它必须先获取尾节点，然后设置尾节点的下一个节点为入队节点，但这时可能有另外一个线程插队了，那么队列的尾节点就会发生变化，这时当前线程要暂停入队操作，然后重新获取尾节点。</p><p>&emsp;下面我们来看ConcurrentLinkedQueue的add(E e)入队方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> offer(e);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果e为null，则直接抛出NullPointerException异常</span></span><br><span class="line">        checkNotNull(e);</span><br><span class="line">        <span class="comment">// 创建入队节点</span></span><br><span class="line">        <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 循环CAS直到入队成功</span></span><br><span class="line">        <span class="comment">// 1、根据tail节点定位出尾节点（last node）；2、将新节点置为尾节点的下一个节点；3、casTail更新尾节点</span></span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; t = tail, p = t;;) &#123;</span><br><span class="line">            <span class="comment">// p用来表示队列的尾节点，初始情况下等于tail节点</span></span><br><span class="line">            <span class="comment">// q是p的next节点</span></span><br><span class="line">            Node&lt;E&gt; q = p.next;</span><br><span class="line">            <span class="comment">// 判断p是不是尾节点，tail节点不一定是尾节点，判断是不是尾节点的依据是该节点的next是不是null</span></span><br><span class="line">            <span class="comment">// 如果p是尾节点</span></span><br><span class="line">            <span class="keyword">if</span> (q == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// p is last node</span></span><br><span class="line">                <span class="comment">// 设置p节点的下一个节点为新节点，设置成功则casNext返回true；否则返回false，说明有其他线程更新过尾节点</span></span><br><span class="line">                <span class="keyword">if</span> (p.casNext(<span class="keyword">null</span>, newNode)) &#123;</span><br><span class="line">                    <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                    <span class="comment">// for e to become an element of this queue,</span></span><br><span class="line">                    <span class="comment">// and for newNode to become "live".</span></span><br><span class="line">                    <span class="comment">// 如果p != t，则将入队节点设置成tail节点，更新失败了也没关系，因为失败了表示有其他线程成功更新了tail节点</span></span><br><span class="line">                    <span class="keyword">if</span> (p != t) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                        casTail(t, newNode);  <span class="comment">// Failure is OK.</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// Lost CAS race to another thread; re-read next</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 多线程操作时候，由于poll时候会把旧的head变为自引用，然后将head的next设置为新的head</span></span><br><span class="line">            <span class="comment">// 所以这里需要重新找新的head，因为新的head后面的节点才是激活的节点</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="comment">// We have fallen off list.  If tail is unchanged, it</span></span><br><span class="line">                <span class="comment">// will also be off-list, in which case we need to</span></span><br><span class="line">                <span class="comment">// jump to head, from which all live nodes are always</span></span><br><span class="line">                <span class="comment">// reachable.  Else the new tail is a better bet.</span></span><br><span class="line">                <span class="comment">//重新定位尾节点</span></span><br><span class="line">                p = (t != (t = tail)) ? t : head;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="comment">//寻找尾节点</span></span><br><span class="line">                <span class="comment">// Check for tail updates after two hops.</span></span><br><span class="line">                p = (p != t &amp;&amp; t != (t = tail)) ? t : q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;从源代码角度来看整个入队过程主要做两件事情：</p><ul><li>第一是定位出尾节点</li><li>第二是使用CAS算法能将入队节点设置成尾节点的next节点，如不成功则重试。</li></ul><p>&emsp;第一步定位尾节点。tail节点并不总是尾节点，所以<strong>每次入队都必须先通过tail节点来找到尾节点，尾节点可能就是tail节点，也可能是tail节点的next节点</strong>。代码中循环体中的第一个if就是判断tail是否有next节点，有则表示next节点可能是尾节点。获取tail节点的next节点需要注意的是p节点等于q节点的情况，出现这种情况的原因我们后续再来介绍。</p><p>&emsp;第二步设置入队节点为尾节点。p.casNext(null, newNode)方法用于将入队节点设置为当前队列尾节点的next节点，q如果是null表示p是当前队列的尾节点，如果不为null表示有其他线程更新了尾节点，则需要重新获取当前队列的尾节点。</p><h3 id="2-3-tail节点不一定为尾节点的设计意图"><a href="#2-3-tail节点不一定为尾节点的设计意图" class="headerlink" title="2.3 tail节点不一定为尾节点的设计意图"></a>2.3 tail节点不一定为尾节点的设计意图</h3><p>&emsp;对于先进先出的队列入队所要做的事情就是将入队节点设置成尾节点，doug lea写的代码和逻辑还是稍微有点复杂。那么我用以下方式来实现行不行？<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> Node&lt;E&gt; newNode = <span class="keyword">new</span> Node&lt;E&gt;(e);</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node&lt;E&gt; t = tail;</span><br><span class="line">        <span class="keyword">if</span> (t.casNext(<span class="keyword">null</span> ,newNode) &amp;&amp; casTail(t, newNode)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;让tail节点永远作为队列的尾节点，这样实现代码量非常少，而且逻辑非常清楚和易懂。但是这么做有个缺点就是每次都需要使用循环CAS更新tail节点。<strong>如果能减少CAS更新tail节点的次数，就能提高入队的效率</strong>。</p><p>&emsp;在JDK 1.7的实现中，doug lea使用hops变量来控制并减少tail节点的更新频率，并不是每次节点入队后都将 tail节点更新成尾节点，而是当tail节点和尾节点的距离大于等于常量HOPS的值（默认等于1）时才更新tail节点，tail和尾节点的距离越长使用CAS更新tail节点的次数就会越少，但是距离越长带来的负面效果就是每次入队时定位尾节点的时间就越长，因为循环体需要多循环一次来定位出尾节点，但是这样仍然能提高入队的效率，head和tail是olatile类型变量，因为从本质上来看它<strong>通过增加对volatile变量的读操作来减少了对volatile变量的写操作，而对volatile变量的写操作开销要远远大于读操作，所以入队效率会有所提升</strong>。</p><p>&emsp;在JDK 1.8的实现中，tail的更新时机是通过p和t是否相等来判断的，其实现结果和JDK 1.7相同，即当tail节点和尾节点的距离大于等于1时，更新tail。</p><p>&emsp;ConcurrentLinkedQueue的入队操作整体逻辑如下图所示：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/ConcurrentLinkedQueue/EnQueueDetail.png" alt="EnQueue"></p><h3 id="2-4-出队"><a href="#2-4-出队" class="headerlink" title="2.4 出队"></a>2.4 出队</h3><p>&emsp;出队列的就是从队列里返回一个节点元素，并清空该节点对元素的引用。让我们通过每个节点出队的快照来观察下head节点的变化：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/ConcurrentLinkedQueue/DeQueue.png" alt="DeQueue"></p><p>&emsp;从上图可知，并不是每次出队时都更新head节点，当head节点里有元素时，直接弹出head节点里的元素，而不会更新head节点。只有当head节点里没有元素时，出队操作才会更新head节点。采用这种方式也是<strong>为了减少使用CAS更新head节点的消耗，从而提高出队效率</strong>。让我们再通过源码来深入分析下出队过程。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        restartFromHead:</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="comment">//// p节点表示首节点，即需要出队的节点</span></span><br><span class="line">            <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">                E item = p.item;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//情况1：如果p节点的元素不为null，则通过CAS来设置p节点引用的元素为null，如果CAS成功则返回p节点的元素</span></span><br><span class="line">                <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; p.casItem(item, <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="comment">// Successful CAS is the linearization point</span></span><br><span class="line">                    <span class="comment">// for item to be removed from this queue.</span></span><br><span class="line">                    <span class="comment">// 如果p != h，则更新hea</span></span><br><span class="line">                    <span class="keyword">if</span> (p != h) <span class="comment">// hop two nodes at a time</span></span><br><span class="line">                        updateHead(h, ((q = p.next) != <span class="keyword">null</span>) ? q : p);</span><br><span class="line">                    <span class="keyword">return</span> item;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//情况2：如果头节点的元素为空或头节点发生了变化，这说明头节点已经被另外一个线程修改了。</span></span><br><span class="line">                <span class="comment">// 那么获取p节点的下一个节点，如果p节点的下一节点为null，则表明队列已经空了</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> ((q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="comment">//更新头节点</span></span><br><span class="line">                    updateHead(h, p);</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">// p == q，则使用新的head重新开始</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                    <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">                <span class="comment">// 如果下一个元素不为空，则将头节点的下一个节点设置成头节点</span></span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    p = q;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;该方法的主要逻辑就是首先获取头节点的元素，然后判断头节点元素是否为空，如果为空，表示另外一个线程已经进行了一次出队操作将该节点的元素取走，如果不为空，则使用CAS的方式将头节点的引用设置成null，如果CAS成功，则直接返回头节点的元素，如果不成功，表示另外一个线程已经进行了一次出队操作更新了head节点，导致元素发生了变化，需要重新获取头节点。</p><p>&emsp;在入队和出队操作中，都有p == q的情况，那这种情况是怎么出现的呢？我们来看这样一种操作：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/ConcurrentLinkedQueue/p==q.png" alt="p==q"></p><p>&emsp;在弹出一个节点之后，tail节点有一条指向自己的虚线，这是什么意思呢？我们来看poll()方法，在该方法中，移除元素之后，会调用updateHead方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">updateHead</span><span class="params">(Node&lt;E&gt; h, Node&lt;E&gt; p)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (h != p &amp;&amp; casHead(h, p))</span><br><span class="line">        <span class="comment">//将旧的头结点h的next域指向为h</span></span><br><span class="line">        h.lazySetNext(h);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;我们可以看到，在更新完head之后，会将旧的头结点h的next域指向为h，上图中所示的虚线也就表示这个节点的<strong>自引用</strong>。</p><p>&emsp;如果这时，再有一个线程来添加元素，通过tail获取的next节点则仍然是它本身，这就出现了p == q的情况，出现该种情况之后，则会触发执行head的更新，将p节点重新指向为head，所有“活着”的节点（指未删除节点），都能从head通过遍历可达，这样就能通过head成功获取到尾节点，然后添加元素了。</p><h3 id="2-5-peek"><a href="#2-5-peek" class="headerlink" title="2.5 peek()"></a>2.5 peek()</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取链表的首部元素（只读取而不移除）</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    restartFromHead:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; h = head, p = h, q;;) &#123;</span><br><span class="line">            E item = p.item;</span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span> || (q = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                updateHead(h, p);</span><br><span class="line">                <span class="keyword">return</span> item;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == q)</span><br><span class="line">                <span class="keyword">continue</span> restartFromHead;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                p = q;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;从源码中可以看到，peek操作会改变head指向，执行peek()方法后head会指向第一个具有非空元素的节点。</p><h3 id="2-6-remove-Object-o"><a href="#2-6-remove-Object-o" class="headerlink" title="2.6 remove(Object o)"></a>2.6 remove(Object o)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 删除的元素不能为null</span></span><br><span class="line">    <span class="keyword">if</span> (o != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Node&lt;E&gt; next, pred = <span class="keyword">null</span>;</span><br><span class="line"> </span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; pred = p, p = next) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> removed = <span class="keyword">false</span>;</span><br><span class="line">            E item = p.item;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 节点元素不为null</span></span><br><span class="line">            <span class="keyword">if</span> (item != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">// 若不匹配，则获取next节点继续匹配</span></span><br><span class="line">                <span class="keyword">if</span> (!o.equals(item)) &#123;</span><br><span class="line">                    next = succ(p);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line"> </span><br><span class="line">                <span class="comment">// 若匹配，则通过CAS操作将对应节点元素置为null</span></span><br><span class="line">                removed = p.casItem(item, <span class="keyword">null</span>);</span><br><span class="line">            &#125;</span><br><span class="line"> </span><br><span class="line">            <span class="comment">// 获取删除节点的后继节点</span></span><br><span class="line">            next = succ(p);</span><br><span class="line">            <span class="comment">// 将被删除的节点移除队列</span></span><br><span class="line">            <span class="keyword">if</span> (pred != <span class="keyword">null</span> &amp;&amp; next != <span class="keyword">null</span>) <span class="comment">// unlink</span></span><br><span class="line">                pred.casNext(p, next);</span><br><span class="line">            <span class="keyword">if</span> (removed)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-7-contains-Object-o"><a href="#2-7-contains-Object-o" class="headerlink" title="2.7 contains(Object o)"></a>2.7 contains(Object o)</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"> </span><br><span class="line">    <span class="comment">// 遍历队列</span></span><br><span class="line">    <span class="keyword">for</span> (Node&lt;E&gt; p = first(); p != <span class="keyword">null</span>; p = succ(p)) &#123;</span><br><span class="line">        E item = p.item;</span><br><span class="line">        <span class="comment">// 若找到匹配节点，则返回true</span></span><br><span class="line">        <span class="keyword">if</span> (item != <span class="keyword">null</span> &amp;&amp; o.equals(item))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;该方法和size方法类似，有可能返回错误结果，比如调用该方法时，元素还在队列里面，但是遍历过程中，该元素被删除了，那么就会返回false。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>&emsp;ConcurrentLinkedQueue 的非阻塞算法实现可概括为下面 5 点：</p><ol><li>使用 CAS 原子指令来处理对数据的并发访问，这是非阻塞算法得以实现的基础。</li><li><strong>head/tail 并非总是指向队列的头 / 尾节点，也就是说允许队列处于不一致状态</strong>。 这个特性把入队 / 出队时，原本需要一起原子化执行的两个步骤分离开来，从而缩小了入队 / 出队时需要原子化更新值的范围到唯一变量。这是非阻塞算法得以实现的关键。</li><li>由于队列有时会处于不一致状态。为此，ConcurrentLinkedQueue 使用三个不变式来维护非阻塞算法的正确性。</li><li>以批处理方式来更新 head/tail，从整体上减少入队 / 出队操作的开销。</li><li>为了有利于垃圾收集，队列使用特有的 head 更新机制；为了确保从已删除节点向后遍历，可到达所有的非删除节点，队列使用了特有的向后推进策略。<br>ConcurrentLinkedQueue 有机整合了上述 5 点来实现非阻塞算法。更多关于非阻塞算法和三个不变式的知识可以参考文章<a href="https://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html" target="_blank" rel="noopener">《非阻塞算法在并发容器中的实现》</a>。</li></ol><p>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.cnblogs.com/zaizhoumo/p/7726218.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaizhoumo/p/7726218.html</a><br><a href="https://blog.csdn.net/qq_38293564/article/details/80798310" target="_blank" rel="noopener">https://blog.csdn.net/qq_38293564/article/details/80798310</a><br><a href="https://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html" target="_blank" rel="noopener">https://www.ibm.com/developerworks/cn/java/j-lo-concurrent/index.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 之 ReentrantReadWriteLock</title>
      <link href="/java/java-ReentrantReadWriteLock/"/>
      <url>/java/java-ReentrantReadWriteLock/</url>
      
        <content type="html"><![CDATA[<h1 id="ReentrantReadWriteLock-详解"><a href="#ReentrantReadWriteLock-详解" class="headerlink" title="ReentrantReadWriteLock 详解"></a>ReentrantReadWriteLock 详解</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;ReentrantLock 是一个排他锁，同一时间只允许一个线程访问，而 ReentrantReadWriteLock 允许多个读线程同时访问，但不允许写线程和读线程、写线程和写线程同时访问。相对于排他锁，提高了并发性。在实际应用中，大部分情况下对共享数据（如缓存）的访问都是读操作远多于写操作，这时ReentrantReadWriteLock能够提供比排他锁更好的并发性和吞吐量。<br>&emsp;读写锁的内部维护了一个 ReadLock 和一个 WriteLock ，它们依赖 Sync 实现具体功能。而 Sync 继承自AQS ，并且也提供了公平和非公平的实现。我们知道 AQS 中只维护了一个state 状态，而 ReentrantReadWriteLock 则需要维护读状态和写状态， 一个 state 怎么表示写和读两种状态呢？ReentrantReadWriteLock 巧妙地使用 state 的高16 位表示读状态，也就是获取到读锁的次数；使用低16 位表示获取到写锁的线程的可重入次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_SHIFT   = <span class="number">16</span>;</span><br><span class="line"><span class="comment">//共享读锁状态，高16位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHARED_UNIT    = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT);</span><br><span class="line"><span class="comment">//共享锁线程最大数65535</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> MAX_COUNT      = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"><span class="comment">//排他锁低16位</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> EXCLUSIVE_MASK = (<span class="number">1</span> &lt;&lt; SHARED_SHIFT) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//返回持有读锁线程锁</span></span><br><span class="line"><span class="comment">/** Returns the number of shared holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">sharedCount</span><span class="params">(<span class="keyword">int</span> c)</span>    </span>&#123; <span class="keyword">return</span> c &gt;&gt;&gt; SHARED_SHIFT; &#125;</span><br><span class="line"><span class="comment">//返回写锁可重入个数</span></span><br><span class="line"><span class="comment">/** Returns the number of exclusive holds represented in count  */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">exclusiveCount</span><span class="params">(<span class="keyword">int</span> c)</span> </span>&#123; <span class="keyword">return</span> c &amp; EXCLUSIVE_MASK; &#125;</span><br></pre></td></tr></table></figure><p>&emsp;其中 firstReader 用来记录第一个获取到读锁的线程， firstReaderHoldCount 则记录第一个获取到读锁的线程获取读锁的可重入次数。cachedHoldCounter 用来记录最后一个获取读锁的线程获取读锁的可重入次数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> HoldCounter cachedHoldCounter;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Thread firstReader = <span class="keyword">null</span>;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> <span class="keyword">int</span> firstReaderHoldCount;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">HoldCounter</span> </span>&#123;</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="comment">// Use id, not reference, to avoid garbage retention</span></span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> tid = getThreadId(Thread.currentThread());</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-写锁的获取与释放"><a href="#2-写锁的获取与释放" class="headerlink" title="2. 写锁的获取与释放"></a>2. 写锁的获取与释放</h2><p>&emsp;在 ReentrantReadWriteLock 中写锁使用 WriteLock 来实现。</p><ul><li>lock()</li></ul><p>&emsp;写锁是个独占锁， 某时只有一个线程可以获取该锁。如果当前没有线程获取到读锁和写锁， 则当前线程可以获取到写锁然后返回。如果当前己经有线程获取到读锁和写锁，则当前请求写锁的线程会被阻塞挂起。另外， 写锁是可重入锁，如果当前线程己经获取了该锁，再次获取只是简单地把可重入次数加 1 后直接返回。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquire(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//sync重写的tryAcquire方法</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">            <span class="comment">//(1 )说明读锁或者写锁已经被某线程获取</span></span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">// (Note: if c != 0 and w == 0 then shared count != 0)</span></span><br><span class="line">                <span class="comment">//(2) 结果为真的两种情况：</span></span><br><span class="line">                <span class="comment">//1. w==0，写锁没有被获取，说明被获取的是读锁，而当前想要获取写锁，失败，直接返回false</span></span><br><span class="line">                <span class="comment">//2. w!=0 &amp;&amp; current != getExclusiveOwnerThread()，当前写锁已经被获取，而且不是被当前线程获取，false</span></span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="comment">//(3 )到这里说明当前线程已经获取了写锁，判断可重入次数</span></span><br><span class="line">                <span class="keyword">if</span> (w + exclusiveCount(acquires) &gt; MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="comment">// Reentrant acquire</span></span><br><span class="line">                <span class="comment">//(4) 设置可重入次数</span></span><br><span class="line">                setState(c + acquires);</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//(5) c==0，第一个写线程获取写锁</span></span><br><span class="line">            <span class="keyword">if</span> (writerShouldBlock() ||</span><br><span class="line">                !compareAndSetState(c, c + acquires))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//(6) 获取写锁成功，设置标志</span></span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;获取写锁的思路为：</p><ul><li><ol><li>当前写锁或读锁已经被某线程持有<ul><li>1.1 读锁已经被持有，当前尝试获取写锁失败</li><li>1.2 写锁已经被持有，并且写锁持有者不是当前线程，获取失败</li><li>1.3 写锁已经被当前线程持有，判断可重入数量是否超出最大值</li></ul></li></ol></li><li><ol><li>写锁和读锁均没有被任何线程获取，则根据公平策略来获取写锁并设置标志</li></ol></li></ul><p>&emsp;这里的根据公平策略来获取写锁由代码(5) 处体现，writerShouldBlock() 函数公平锁和非公平锁有不同的实现。<br>&emsp;公平锁的实现为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里使用 hasQueuedPredecessors 来判断当前线程节点是否有前驱节点等待获取锁，如果有则当前线程放弃获取写锁的权限。</p><p>&emsp;非公平锁的实现为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">writerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>; <span class="comment">// writers can always barge</span></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里直接返回 false，直接参与锁的竞争。</p><ul><li>tryLock()</li></ul><p>&emsp;尝试获取写锁，如果当前没有其他线程持有写锁或者读锁，则当前线程获取写锁会成功， 然后返回 true 。如果当前己经有其他线程持有写锁或者读锁则该方法直接返回false,且当前线程并 <strong>不会被阻塞</strong>。如果当前线程已经持有了该写锁则简单增加AQS 的状态值后直接返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">( )</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> sync.tryWriteLock();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryWriteLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="keyword">if</span> (c != <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> w = exclusiveCount(c);</span><br><span class="line">                <span class="keyword">if</span> (w == <span class="number">0</span> || current != getExclusiveOwnerThread())</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">if</span> (w == MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!compareAndSetState(c, c + <span class="number">1</span>))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            setExclusiveOwnerThread(current);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;tryWriteLock 方法和 tryAcquire 方法类似，不再赘述。</p><ul><li>unlock()</li></ul><p>&emsp;尝试释放锁，如果当前线程持有该锁，调用该方法会让该线程对该线程持有的AQS状态值减1 ，如果减去1后当前状态值为0 则当前线程会释放该锁，否则仅仅减l而己。如果当前线程没有持有该锁而调用了该方法则会抛出Illega!MonitorStateException 异常，代码如下:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.release(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">            <span class="comment">//激活阻塞队列里面的一个线程</span></span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//是否写锁拥有者调用的unlock</span></span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            <span class="keyword">int</span> nextc = getState() - releases;</span><br><span class="line">            <span class="comment">//释放后写锁持有可重入数量是否为0</span></span><br><span class="line">            <span class="keyword">boolean</span> free = exclusiveCount(nextc) == <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (free)</span><br><span class="line">                setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">            setState(nextc);</span><br><span class="line">            <span class="keyword">return</span> free;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-读锁的获取与释放"><a href="#3-读锁的获取与释放" class="headerlink" title="3. 读锁的获取与释放"></a>3. 读锁的获取与释放</h2><p>&emsp;在 ReentrantReadWriteLock 中写锁使用 ReadLock 来实现。</p><ul><li>lock()</li></ul><p>&emsp;获取读锁，如果当前没有其他线程持有写锁，则当前线程可以获取读锁，AQS 的状态值 state 的高16位的值会增加l，然后方法返回。否则如果其他一个线程持有写锁， 则当前线程会被阻塞。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//放进阻塞队列</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            <span class="comment">//(1)获取当前状态值</span></span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            <span class="keyword">int</span> c = getState();</span><br><span class="line">            <span class="comment">//(2)如果写锁被其它线程持有</span></span><br><span class="line">            <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span> &amp;&amp;</span><br><span class="line">                getExclusiveOwnerThread() != current)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">int</span> r = sharedCount(c);</span><br><span class="line">            <span class="comment">//(3)尝试获取锁，多个读线程只有一个会成功，不成功的进入fullTryAcquireShared进行重试</span></span><br><span class="line">            <span class="keyword">if</span> (!readerShouldBlock() &amp;&amp;</span><br><span class="line">                r &lt; MAX_COUNT &amp;&amp;</span><br><span class="line">                compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                <span class="comment">//第一个线程获取读锁</span></span><br><span class="line">                <span class="keyword">if</span> (r == <span class="number">0</span>) &#123;</span><br><span class="line">                    firstReader = current;</span><br><span class="line">                    firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                <span class="comment">//如果是第一个获取读锁的线程</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                    firstReaderHoldCount++;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    HoldCounter rh = cachedHoldCounter;</span><br><span class="line">                    <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                        cachedHoldCounter = rh = readHolds.get();</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                        readHolds.set(rh);</span><br><span class="line">                    rh.count++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//类似 tryAcquireShhared，但是是自旋获取</span></span><br><span class="line">            <span class="comment">//因为读锁是可共享的，只需要自旋获取，不能放进阻塞队列</span></span><br><span class="line">            <span class="keyword">return</span> fullTryAcquireShared(current);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;获取读锁的过程为：</p><ul><li><ol><li>当前写锁被其它线程持有，获取读锁失败；</li></ol></li><li><ol><li>尝试获取读锁，失败则自旋重试；</li></ol></li></ul><p>&emsp;如果当前要获取读锁的线程己经持有了写锁， 则也可以获取读锁。但是需要注意，当一个线程先获取了写锁，然后获取了读锁处理事情完毕后，要记得把读锁和写锁都释放掉，不能只释放写锁。<br>代码(3)处的readerShouldBlock方法公平锁和非公平锁有不同的实现。<br>&emsp;非公平锁的实现为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> apparentlyFirstQueuedIsExclusive();</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">apparentlyFirstQueuedIsExclusive</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Node h, s;</span><br><span class="line">        <span class="keyword">return</span> (h = head) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            (s = h.next)  != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">            !s.isShared()         &amp;&amp;</span><br><span class="line">            s.thread != <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;apparentlyFirstQueuedIsExclusive方法的作用为，，如果队列里面存在一个元素，则判断第一个元素是不是正在尝试获取写锁，如果不是， 则当前线程判断当前获取读锁的线程是否达到了最大值，也就是说如果当前阻塞队列的第一个线程获取的不是写锁，则当前线程可以有机会竞争获得锁。<br>最后执行CAS 操作将AQS 状态值的高16 位值增加l。</p><p>&emsp;公平锁的实现为：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">readerShouldBlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> hasQueuedPredecessors();</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;如果当前阻塞队列还有线程，则当前线程放弃获取锁的权利。</p><p>&emsp;我们再看一下 tryAcquireShared 方法里面最后的 fullTryAcquireShared 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">fullTryAcquireShared</span><span class="params">(Thread current)</span> </span>&#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * This code is in part redundant with that in</span></span><br><span class="line"><span class="comment">             * tryAcquireShared but is simpler overall by not</span></span><br><span class="line"><span class="comment">             * complicating tryAcquireShared with interactions between</span></span><br><span class="line"><span class="comment">             * retries and lazily reading hold counts.</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            HoldCounter rh = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (exclusiveCount(c) != <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (getExclusiveOwnerThread() != current)</span><br><span class="line">                        <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    <span class="comment">// else we hold the exclusive lock; blocking here</span></span><br><span class="line">                    <span class="comment">// would cause deadlock.</span></span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (readerShouldBlock()) &#123;</span><br><span class="line">                    <span class="comment">// Make sure we're not acquiring read lock reentrantly</span></span><br><span class="line">                    <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        <span class="comment">// assert firstReaderHoldCount &gt; 0;</span></span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>) &#123;</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                            <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current)) &#123;</span><br><span class="line">                                rh = readHolds.get();</span><br><span class="line">                                <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                                    readHolds.remove();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (sharedCount(c) == MAX_COUNT)</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum lock count exceeded"</span>);</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, c + SHARED_UNIT)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (sharedCount(c) == <span class="number">0</span>) &#123;</span><br><span class="line">                        firstReader = current;</span><br><span class="line">                        firstReaderHoldCount = <span class="number">1</span>;</span><br><span class="line">                    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (firstReader == current) &#123;</span><br><span class="line">                        firstReaderHoldCount++;</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span>)</span><br><span class="line">                            rh = cachedHoldCounter;</span><br><span class="line">                        <span class="keyword">if</span> (rh == <span class="keyword">null</span> || rh.tid != getThreadId(current))</span><br><span class="line">                            rh = readHolds.get();</span><br><span class="line">                        <span class="keyword">else</span> <span class="keyword">if</span> (rh.count == <span class="number">0</span>)</span><br><span class="line">                            readHolds.set(rh);</span><br><span class="line">                        rh.count++;</span><br><span class="line">                        cachedHoldCounter = rh; <span class="comment">// cache for release</span></span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;fullTryAcquireShared 方法和 tryAcquireShared 类似，它们的不同之处在于，前者通过循环自旋获取。之所以以自旋的方式获取，是因为读锁是可共享的，只需要自旋获取，不能放进阻塞队列。</p><ul><li>unlock()<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//释放锁</span></span><br><span class="line">        <span class="comment">//返回结果为读锁持有数量是否为0，为0则唤醒阻塞线程</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">//唤醒阻塞线程</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">            Thread current = Thread.currentThread();</span><br><span class="line">            ...</span><br><span class="line">            <span class="comment">//CAS自旋更新</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">int</span> nextc = c - SHARED_UNIT;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="comment">// Releasing the read lock has no effect on readers,</span></span><br><span class="line">                    <span class="comment">// but it may allow waiting writers to proceed if</span></span><br><span class="line">                    <span class="comment">// both read and write locks are now free.</span></span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></li></ul><blockquote><p>参考：<br>《Java 并发编程之美》</p><p>相关文章推荐：<br><a href="http://zhoujiapeng.top/java/java-AbstractQueuedSynchronizer">《Java 并发编程 之 AbstractQueuedSynchronizer》</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 之 锁的概述</title>
      <link href="/java/java-lock-summary/"/>
      <url>/java/java-lock-summary/</url>
      
        <content type="html"><![CDATA[<h1 id="乐观锁与悲观锁"><a href="#乐观锁与悲观锁" class="headerlink" title="乐观锁与悲观锁"></a>乐观锁与悲观锁</h1><p>&emsp;乐观锁和悲观锁是在数据库中引入的名词，但是在并发包锁里面也引入了类似的思想。<br>&emsp;悲观锁指对数据被外界修改持保守态度，认为数据很容易就会被其他线程修改，所以在数据被处理前先对数据进行加锁，并在整个数据处理过程中，使数据处于锁定状态。悲观锁的实现往往依靠数据库提供的锁机制，即在数据库中，在对数据记录操作前给记录加排它锁。如果获取锁失败， 则说明数据正在被其他线程修改， 当前线程则等待或者抛出异常。如果获取锁成功，则对记录进行操作，然后提交事务后释放排它锁。<br>&emsp;下面看一个例子，使用悲观锁来避免多线程同时对一个记录进行修改：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateEntry</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (1)使用悲观锁获取指定记录</span></span><br><span class="line">    EntryObject entry= query(<span class="string">"select * from tablel where id = #&#123;id&#125; for update"</span>,id);</span><br><span class="line">    <span class="comment">//(2)修改记录内容， 根据计算修改entry记录的属性</span></span><br><span class="line">    String name = generatorName(entry) ;</span><br><span class="line">    entry.setName(name);</span><br><span class="line">    <span class="comment">//(3)update操作</span></span><br><span class="line">    <span class="keyword">int</span> count = update(<span class="string">"update tablel set name ＝ #&#123;name&#125; , age=#&#123;age&#125; where id =#&#123;id&#125;"</span>, entry);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><br>&emsp;这里的 updateEntry 整个函数作为一个事务提交，多个线程调用 updateEntry 方法，并且传递的是同一个id时，只有一个线程会执行成功，其它线程阻塞。</p><p>&emsp;乐观锁是相对悲观锁来说的，它认为数据在一般情况下不会造成冲突，所以在访问记录前不会加排它锁，而是在进行数据提交更新时，才会正式对数据冲突与否进行检测。具体来说，根据update 返回的行数让用户决定如何去做。<br>&emsp;乐观锁一般会使用<strong>版本号机制</strong>或<strong>CAS算法</strong>实现。<br>&emsp;首先看一下版本号方法，将上面的例子改为使用乐观锁的代码如下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">updateEntry</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// (1)使用乐观锁获取指定记录</span></span><br><span class="line">    EntryObject entry= query(<span class="string">"select * from tablel where id = #&#123;id&#125; for update"</span>,id);</span><br><span class="line">    <span class="comment">//(2)修改记录内容， version字段不能被修改</span></span><br><span class="line">    String name = generatorName(entry) ;</span><br><span class="line">    entry.setName(name);</span><br><span class="line">    <span class="comment">//(3)update操作</span></span><br><span class="line">    <span class="keyword">int</span> count = update(<span class="string">"update tablel set name ＝ #&#123;name&#125; , age=#&#123;age&#125;, version=$&#123;version&#125;+1 where id =#&#123;id&#125; and version=#&#123;version&#125;"</span>, entry);</span><br><span class="line">    <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><br>&emsp;在调用update之前可能会有多个线程都调用了updateEntry，因此版本号 version 可能已经被修改了，所以 update 的时候需要判断 version 是否为原来的 version，如果是，说明该数据没有被其它线程修改，可以更新，version+1，count 会返回1，否则返回0，表示失败，失败的处理策略由用户决定，这有点CAS操作的意思。</p><p>&emsp;接下来看一下CAS方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">updateEntry</span><span class="params">(<span class="keyword">long</span> id)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> result = <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">int</span> retryNum = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">while</span>(retryNum&gt;<span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">// (1)使用乐观锁获取指定记录</span></span><br><span class="line">        EntryObject entry= query(<span class="string">"select * from tablel where id = #&#123;id&#125; for update"</span>,id);</span><br><span class="line">        <span class="comment">//(2)修改记录内容， version字段不能被修改</span></span><br><span class="line">        String name = generatorName(entry) ;</span><br><span class="line">        entry.setName(name);</span><br><span class="line">        <span class="comment">//(3)update操作</span></span><br><span class="line">        <span class="keyword">int</span> count = update(<span class="string">"update tablel set name ＝ #&#123;name&#125; , age=#&#123;age&#125;, version=$&#123;version&#125;+1 where id =#&#123;id&#125; and version=#&#123;version&#125;"</span>, entry);</span><br><span class="line">        <span class="keyword">if</span>(count ==<span class="number">1</span>)&#123;</span><br><span class="line">            result = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        retryNum--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> count;</span><br></pre></td></tr></table></figure><br>&emsp;如上代码使用retryNum 设置更新失败后的重试次数,如果update更新失败，则会重新尝试，这类似于CAS的自旋操作，只是这里没有使用死循环，而是指定了尝试次数。</p><h1 id="公平锁与非公平锁"><a href="#公平锁与非公平锁" class="headerlink" title="公平锁与非公平锁"></a>公平锁与非公平锁</h1><p>&emsp;根据线程获取锁的抢占机制，锁可以分为公平锁和非公平锁，公平锁表示线程获取锁的顺序是按照线程请求锁的时间早晚来决定的，也就是最早请求锁的线程将最早获取到锁。而非公平锁则在运行时闯入，也就是先来不一定先得。<br>&emsp;ReentrantLock 提供了公平和非公平锁的实现,如果构造函数不传递参数，则默认是非公平锁。</p><ul><li>公平锁： ReentrantLock pairLock = new ReentrantLock(true)。</li><li>非公平锁： ReentrantLock pairLock =new ReentrantLock(false)。</li></ul><p><strong>在没有公平性需求的前提下尽量使用非公平锁，因为公平锁会带来性能开销。</strong></p><h1 id="独占锁与共享锁"><a href="#独占锁与共享锁" class="headerlink" title="独占锁与共享锁"></a>独占锁与共享锁</h1><p>&emsp;根据锁只能被单个线程持有还是能被多个线程共同持有，锁可以分为独占锁和共享锁。<br>独占锁保证任何时候都只有一个线程能得到锁， ReentrantLock 就是以独占方式实现的。共享锁则可以同时由多个线程持有，例如 ReadWriteLock 读写锁，它允许一个资源可以被多线程同时进行读操作。<br>&emsp;独占锁是一种悲观锁，由于每次访问资源都先加上互斥锁，这限制了并发性，因为读操作并不会影响数据的一致性，而独占锁只允许在同一时间由一个线程读取数据，其他线程必须等待当前线程释放锁才能进行读取。<br>&emsp;共享锁则是一种乐观锁，它放宽了加锁的条件，允许多个线程同时进行读操作。</p><h1 id="可重入锁"><a href="#可重入锁" class="headerlink" title="可重入锁"></a>可重入锁</h1><p>&emsp;当一个线程要获取一个被其他线程持有的独占锁时，该线程会被阻塞，那么当一个线程再次获取它自己己经获取的锁时是否会被阻塞呢？如果不被阻塞，那么我们说该锁可重入的。<br>&emsp;实际上，synchronized 内部锁是可重入锁。可重入锁的原理是在锁内部维护一个线程标示，用来标示该锁目前被哪个线程占用，然后关联一个计数器。一开始计数器值为o,说明该锁没有被任何线程占用。当一个钱程获取了该锁时，计数器的值会变成1 ，这时其他线程再来获取该锁时会发现锁的所有者不是自己而被阻塞挂起。<br>但是当获取了该锁的线程再次获取锁时发现锁拥有者是自己，就会把计数器值加+1,当释放锁后计数器值-1 。当计数器值为0 时－，锁里面的线程标示被重置为null ， 这时候被阻塞的线程会被唤醒来竞争获取该锁。</p><h1 id="自选锁"><a href="#自选锁" class="headerlink" title="自选锁"></a>自选锁</h1><p>&emsp;由于Java 中的线程是与操作系统中的线程一一对应的，所以当一个线程在获取锁（比如独占锁）失败后，会被切换到内核状态而被挂起。当该线程获取到锁时又需要将其切换到内核状态而唤醒该线程。而从用户状态切换到内核状态的开销是比较大的，在一定程度上会影响并发性能。自旋锁则是，当前线程在获取锁时，如果发现锁已经被其他线程占有，它不马上阻塞自己，在不放弃CPU 使用权的情况下，<strong>多次尝试获取</strong>（默认次数是10 ，可以使用-XX :PreBlockSpinsh 参数设置该值），很有可能在后面几次尝试中其他线程己经释放了锁。如果尝试指定的次数后仍没有获取到锁则当前线程才会被阻塞挂起。由此看来 <strong>自旋锁是使用CPU时间换取线程阻塞与调度的开销</strong>，但是很有可能这些CPU 时间白白浪费了。</p><p>&nbsp;</p><blockquote><p>参考：<br>《Java 并发编程之美》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 之 ThreadLocal</title>
      <link href="/java/java-ThreadLocal/"/>
      <url>/java/java-ThreadLocal/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadLocal-详解"><a href="#ThreadLocal-详解" class="headerlink" title="ThreadLocal 详解"></a>ThreadLocal 详解</h1><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>&emsp;在我们日常 Java Web 开发中难免遇到需要把一个参数层层的传递到最内层，然后中间层根本不需要使用这个参数，或者是仅仅在特定的工具类中使用，这样我们完全没有必要在每一个方法里面都传递这样一个通用的参数。如果有一个办法能够在任何一个类里面想用的时候直接拿来使用就太好了。Java的Web项目大部分都是基于Tomcat，每次访问都是一个新的线程，这样让我们联想到了ThreadLocal，每一个线程都独享一个ThreadLocal，在接收请求的时候set特定内容，在需要的时候get这个值。下面我们就进入主题。</p><h2 id="2-概述"><a href="#2-概述" class="headerlink" title="2. 概述"></a>2. 概述</h2><p>&emsp;多线程访问同一个共享变量时很容易出现并发问题，ThreadLocal 提供了线程本地变量，如果创建一个 ThreadLocal 变量。那么访问这个变量的每个线程都会有这个变量的一个本地<strong>副本</strong>，当多线程操作这个变量时，实际操作的是自己本地内存里面的变量，从而避免了线程安全问题。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line">threadLocal.set(<span class="string">"Hello World"</span>);</span><br><span class="line">threadLocal.remove();</span><br></pre></td></tr></table></figure></p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><p>&emsp;可以看到 ThreadLocal有一个内部类 ThreadLocalMap，这是一个定制化的 Hashmap，可以储存一些键值对。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocal.java</span></span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalMap</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Entry</span> <span class="keyword">extends</span> <span class="title">WeakReference</span>&lt;<span class="title">ThreadLocal</span>&lt;?&gt;&gt; </span>&#123;</span><br><span class="line">            <span class="comment">/** The value associated with this ThreadLocal. */</span></span><br><span class="line">            Object value;</span><br><span class="line"></span><br><span class="line">            Entry(ThreadLocal&lt;?&gt; k, Object v) &#123;</span><br><span class="line">                <span class="keyword">super</span>(k);</span><br><span class="line">                value = v;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;另外，在 Thread 类内部，有两个 ThreadLocalMap 类型的属性：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread.java</span></span><br><span class="line">ThreadLocal.ThreadLocalMap threadLocals = <span class="keyword">null</span>;</span><br><span class="line">ThreadLocal.ThreadLocalMap inheritableThreadLocals = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><br>&emsp;这两个变量就是本文的重点了，其实每个线程的本地变量不是存放在 ThreadLocal 实例里面的，而是存放在 Thread.threadLocals 里面，也就是说，ThreadLocal 类型的本地变量存放在具体的线程内存空间中，ThreadLocal 只是一个工具壳，封装了操作这些副本变量的方法。</p><p>&emsp;下面分析一些 ThreadLocal 的 set、get 以及 remove 方法的实现逻辑：</p><h3 id="3-1-set-方法"><a href="#3-1-set-方法" class="headerlink" title="3.1 set 方法"></a>3.1 set 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">set</span><span class="params">(T value)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取当前线程内部的threadLocals</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        <span class="comment">//如果是第一次调用，则创建当前线程对应的threadLocals</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> t.threadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.threadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;set的逻辑很简单，获取当前线程内部的 threadLocals，<strong>ThreadLocal 对象</strong>作为key，变量值作为 value，保存到 threadLocals 里面。<br>&emsp;这里使用了延迟加载的策略，Thread 里面的 threadLocals 默认为 null，只有等到第一次使用到的时候才会创建。</p><h3 id="3-2-get-方法"><a href="#3-2-get-方法" class="headerlink" title="3.2 get 方法"></a>3.2 get 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程</span></span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        <span class="comment">//获取当前线程内部的 threadlocals</span></span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//如果 threadlocals 不为 null，则从 threadlocals 里面查找</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ThreadLocalMap.Entry e = map.getEntry(<span class="keyword">this</span>);</span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                T result = (T)e.value;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//threadlocals为null或者threadlocals找不到当前 ThreadLocal 对象，则进行初始化</span></span><br><span class="line">        <span class="keyword">return</span> setInitialValue();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> T <span class="title">setInitialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//value为null</span></span><br><span class="line">        T value = initialValue();</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        ThreadLocalMap map = getMap(t);</span><br><span class="line">        <span class="comment">//如果当前threadlocals不为null</span></span><br><span class="line">        <span class="keyword">if</span> (map != <span class="keyword">null</span>)</span><br><span class="line">            map.set(<span class="keyword">this</span>, value);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            createMap(t, value);</span><br><span class="line">        <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">initialValue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;get 方法的思路和set类似，同样是获取当前线程内部的 threadLocals，然后以当前 ThreadLocals 对象为 key 去查找，若找不到则为当前 ThreadLocals 对象初始化一个 null 的 value。</p><h3 id="3-3-remove-方法"><a href="#3-3-remove-方法" class="headerlink" title="3.3 remove 方法"></a>3.3 remove 方法</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//获取当前线程内部的 threadlocals</span></span><br><span class="line">         ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class="line">         <span class="keyword">if</span> (m != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//从threadlocals里面移除指定的ThreadLocal实例的本地变量</span></span><br><span class="line">             m.remove(<span class="keyword">this</span>);</span><br><span class="line">     &#125;</span><br></pre></td></tr></table></figure><p>&emsp;需要注意的是，当一个本地变量不再使用时，要调用 remove 方法，将这个本地变量移除，减少内存的占用。</p><h3 id="3-4-总结"><a href="#3-4-总结" class="headerlink" title="3.4 总结"></a>3.4 总结</h3><p>&emsp;每个线程内部都有一个名为 threadLocals 的成员变量，该变量类型为 HashMap，其中 key 为我们定义的 ThreadLocal 对象的 this 引用，value 则为我们使用 set 设置的值。每个线程的本地变量存放在线程自己的内存变量 threadLocals 中，如果当前线程一直不消亡，那么这些本地变量会一直存在，所以可能造成内存溢出，因此使用完毕时候，要调用 remove 方法，将这个本地变量移除，减少内存的占用。</p><h2 id="4-举个例子"><a href="#4-举个例子" class="headerlink" title="4. 举个例子"></a>4. 举个例子</h2><p>&emsp;ThreadLocal 会将数据以K-V形式保存在具体的 Thread 中，其中的 Key 是 ThreadLocal 对象，Value 是具体的值，比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ThreadLocal&lt;UserInfo&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;UserInfo&gt;();</span><br></pre></td></tr></table></figure><br>&emsp;则 key 为 threadLocal 对象。<br>&emsp;这里以《Spring5高级编程(第5版)》中 AOP 的一段代码为例，通过使用前置通知来保护方法访问，从而实现对用户身份限制的效果，其中的 ThreadLocal 就用来在当前线程共享登录用户的信息。<br>&emsp;SecureManager 类封装了 threadLocal，并且 threadLocal 是 static 类型，所以可以在程序的任意地方通过 SecureManager 来访问同一个 threadLocal，从而共享 threadLocal 里面保存的用户信息。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecureManager</span> </span>&#123;</span><br><span class="line">    <span class="comment">//注意这里是 static，所有 SecureManager 对象才能共享同一个 threadLocal</span></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> ThreadLocal&lt;UserInfo&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;UserInfo&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">login</span><span class="params">(String userName,String password)</span></span>&#123;</span><br><span class="line">        threadLocal.set(<span class="keyword">new</span> UserInfo(userName,password));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">logout</span><span class="params">()</span></span>&#123;</span><br><span class="line">        threadLocal.set(<span class="keyword">null</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> UserInfo <span class="title">getLoggedUserInfo</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> threadLocal.get();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;SecureBean 里面 writeSecureMessage 方法是我们将会调用的方法，但是希望在调用这个方法之前验证是否已经登录，SecureAdvice 类实现了前置通知的接口。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecureBean</span> </span>&#123;</span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">writeSecureMessage</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"This is the secure message!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SecureAdvice</span> <span class="keyword">implements</span> <span class="title">MethodBeforeAdvice</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> SecureManager secureManager;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">SecureAdvice</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.secureManager = <span class="keyword">new</span> SecureManager();</span><br><span class="line">        System.out.println(<span class="string">"SecureManager in SecureAdvice:"</span> + secureManager);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">(Method method, Object[] objects, Object o)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">        UserInfo userInfo = secureManager.getLoggedUserInfo();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(userInfo==<span class="keyword">null</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"No user authenticated!"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"You must login before attempting to invoke the method:"</span></span><br><span class="line">                    + method.getName());</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="string">"John"</span>.equals(userInfo.getUserName()))&#123;</span><br><span class="line">            System.out.println(<span class="string">"Logged in user John!"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"User "</span> + userInfo.getUserName() + <span class="string">" is not authenticated!"</span>);</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"User "</span> + userInfo.getUserName() + <span class="string">" is not authenticated!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;接下来将 SecureBean 和 SecureAdvice 的实例绑定在一起，获取 SecureBean 的代理，当我们调用代理的 writeSecureMessage 时，就会触发先执行 SecureAdvice 的 before 方法。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> SecureBean <span class="title">getSecureBean</span><span class="params">()</span></span>&#123;</span><br><span class="line">        SecureBean bean = <span class="keyword">new</span> SecureBean();</span><br><span class="line">        SecureAdvice advice = <span class="keyword">new</span> SecureAdvice();</span><br><span class="line">        <span class="comment">//创建目标对象的代理</span></span><br><span class="line">        ProxyFactory proxyFactory = <span class="keyword">new</span> ProxyFactory();</span><br><span class="line">        <span class="comment">//添加通知</span></span><br><span class="line">        proxyFactory.addAdvice(advice);</span><br><span class="line">        <span class="comment">//指定织入目标</span></span><br><span class="line">        proxyFactory.setTarget(bean);</span><br><span class="line">        <span class="comment">//获取代理实例</span></span><br><span class="line">        SecureBean proxy = (SecureBean)proxyFactory.getProxy();</span><br><span class="line">        <span class="keyword">return</span> proxy;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;最后是main方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SecureManager secureManager = <span class="keyword">new</span> SecureManager();</span><br><span class="line">        System.out.println(<span class="string">"SecureManager in main:"</span> + secureManager);</span><br><span class="line">        SecureBean secureBean = getSecureBean();</span><br><span class="line"></span><br><span class="line">        secureManager.login(<span class="string">"John"</span>,<span class="string">"123456"</span>);</span><br><span class="line">        secureBean.writeSecureMessage();</span><br><span class="line">        secureManager.logout();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            secureManager.login(<span class="string">"Invalid user"</span>,<span class="string">"123"</span>);</span><br><span class="line">            secureBean.writeSecureMessage();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SecurityException ex)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception caught:"</span> + ex.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            secureManager.logout();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            secureBean.writeSecureMessage();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (SecurityException ex)&#123;</span><br><span class="line">            System.out.println(<span class="string">"Exception caught:"</span> + ex.getMessage());</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">            secureManager.logout();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;注意我们在main方法中创建一个 SecureManager 实例来执行登录操作，而在 getSecureBean 方法中创建一个 SecureAdvice 实例，在 SecureAdvice 里面也会创建一个 SecureManager 实例来获取已登录的用户信息。由于 SecureManager 里面的 threadLocal 是 static，所以实际上我们操作的是同一个 threadLocal 对象，从而达到了共享用户信息的效果。</p><h2 id="5-ThreadLocal-不支持继承性"><a href="#5-ThreadLocal-不支持继承性" class="headerlink" title="5. ThreadLocal 不支持继承性"></a>5. ThreadLocal 不支持继承性</h2><p>&emsp;ThreadLocal 存在的一个问题是，父线程的 ThreadLocal 变量无法被子线程获取到，这是很合理的现象，因为 ThreadLocal 变量是绑定在线程上的，而父线程和子线程是两个不同的的线程，子线程自然而然无法获取到父线程的本地变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalsTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建线程变量</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; threadLocal = <span class="keyword">new</span> ThreadLocal&lt;String&gt;();</span><br><span class="line">    <span class="comment">//inheritableThreadLocal 子线程创建的时候会复制父线程的一份副本</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> ThreadLocal&lt;String&gt; inheritableThreadLocal = <span class="keyword">new</span> InheritableThreadLocal&lt;String&gt;();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        threadLocal.set(<span class="string">"Hello World"</span>);</span><br><span class="line">        inheritableThreadLocal.set(<span class="string">"Hello World"</span>);</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="comment">//子线程输出线程变量</span></span><br><span class="line">                System.out.println(<span class="string">"thread threadLocal:"</span> + threadLocal.get()); <span class="comment">//获取不到</span></span><br><span class="line">                System.out.println(<span class="string">"thread inheritableThreadLocal:"</span> + inheritableThreadLocal.get()); <span class="comment">//可以获取到</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        thread.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//主线程输出线程变量</span></span><br><span class="line">        System.out.println(<span class="string">"main threadLocal:"</span> + threadLocal.get()); <span class="comment">//null</span></span><br><span class="line">        System.out.println(<span class="string">"main inheritableThreadLocal:"</span> + inheritableThreadLocal.get()); <span class="comment">//Hello World</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;为了解决这个问题，InheritableThreadLocal应运而生。</p><h2 id="6-InheritableThreadLocal-类"><a href="#6-InheritableThreadLocal-类" class="headerlink" title="6. InheritableThreadLocal 类"></a>6. InheritableThreadLocal 类</h2><p>&emsp;InheritableThreadLocal 继承自 ThreadLocal，提供了一个特性，就是让子线程可以访问在父线程中设置的本地变量。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InheritableThreadLocal</span>&lt;<span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">ThreadLocal</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">ThreadLocalMap <span class="title">getMap</span><span class="params">(Thread t)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> t.inheritableThreadLocals;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createMap</span><span class="params">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class="line">        t.inheritableThreadLocals = <span class="keyword">new</span> ThreadLocalMap(<span class="keyword">this</span>, firstValue);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;InheritableThreadLocal 重写了三个方法。getMap 返回的是 Thread 内部的 inheritableThreadLocals 变量而不是 threadLocals，createMap 也是为 inheritableThreadLocals 创建新的值。简单来说，在 InheritableThreadLocal 的世界里，inheritableThreadLocals 替代了 threadLocals。<br>&emsp;接下来我们看一下 InheritableThreadLocal 怎么实现子线程继承父线程的 InheritableThreadLocal，这要从 Thread 的创建说起：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Thread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        init(<span class="keyword">null</span>, <span class="keyword">null</span>, <span class="string">"Thread-"</span> + nextThreadNum(), <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize)</span> </span>&#123;</span><br><span class="line">                          <span class="comment">//最后一个参数为 inheritThreadLocals=true，表示继承inheritThreadLocals</span></span><br><span class="line">        init(g, target, name, stackSize, <span class="keyword">null</span>, <span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">(ThreadGroup g, Runnable target, String name,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">long</span> stackSize, AccessControlContext acc,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">boolean</span> inheritThreadLocals)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//获取当前线程，新线程是由当前线程创建的，所以当前线程是新线程的父线程</span></span><br><span class="line">        Thread parent = currentThread();</span><br><span class="line">        ...</span><br><span class="line">        <span class="comment">//如果inheritThreadLocals参数为true且父线程的inheritableThreadLocals不为null</span></span><br><span class="line">        <span class="keyword">if</span> (inheritThreadLocals &amp;&amp; parent.inheritableThreadLocals != <span class="keyword">null</span>)</span><br><span class="line">            <span class="comment">//设置子线程的inheritableThreadLocals值</span></span><br><span class="line">            <span class="keyword">this</span>.inheritableThreadLocals =</span><br><span class="line">                ThreadLocal.createInheritedMap(parent.inheritableThreadLocals);</span><br><span class="line">        <span class="comment">/* Stash the specified stack size in case the VM cares */</span></span><br><span class="line">        <span class="keyword">this</span>.stackSize = stackSize;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/* Set thread ID */</span></span><br><span class="line">        tid = nextThreadID();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> ThreadLocalMap <span class="title">createInheritedMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadLocalMap(parentMap);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="title">ThreadLocalMap</span><span class="params">(ThreadLocalMap parentMap)</span> </span>&#123;</span><br><span class="line">            Entry[] parentTable = parentMap.table;</span><br><span class="line">            <span class="keyword">int</span> len = parentTable.length;</span><br><span class="line">            setThreshold(len);</span><br><span class="line">            table = <span class="keyword">new</span> Entry[len];</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; len; j++) &#123;</span><br><span class="line">                Entry e = parentTable[j];</span><br><span class="line">                <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                    ThreadLocal&lt;Object&gt; key = (ThreadLocal&lt;Object&gt;) e.get();</span><br><span class="line">                    <span class="keyword">if</span> (key != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="comment">//（1）调用重写的方法 childValue</span></span><br><span class="line">                        Object value = key.childValue(e.value);</span><br><span class="line">                        Entry c = <span class="keyword">new</span> Entry(key, value);</span><br><span class="line">                        <span class="keyword">int</span> h = key.threadLocalHashCode &amp; (len - <span class="number">1</span>);</span><br><span class="line">                        <span class="keyword">while</span> (table[h] != <span class="keyword">null</span>)</span><br><span class="line">                            h = nextIndex(h, len);</span><br><span class="line">                        table[h] = c;</span><br><span class="line">                        size++;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">protected</span> T <span class="title">childValue</span><span class="params">(T parentValue)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> parentValue;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;返回一个新的ThreadLocalMap，ThreadLocalMap 的构造函数其实就是把父线程的 inheritThreadLocals 成员变量的值复制到新的 ThreadLocalMap中 ,其中代码（1）处调用了重写的childValue方法。<br>&emsp;总的来说，InheritableThreadLocal 将本地变量保存到了具体线程的 inheritThreadLocals 变量里面。当父线程创建子线程时，构造函数会把父线程中 inheritThreadLocals 变量里面的本地变量<strong>复制</strong>（注意不是共享）一份保存到子线程的 inheritThreadLocals 变量里面。</p><p>&emsp;那么在什么情况下需要子线程可以获取父线程的本地变量呢？比如子线程需要使用存放在 threadLocal 变量的用户登录信息，一些中间件需要把统一的id追踪的整个调用链路记录下来。有了 InheritableThreadLocal，我们就不再需要通过传参的形式来传递这些变量了。</p><blockquote><p>参考：<br>《Java 并发编程之美》</p></blockquote><p>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/java/java-ThreadLocal">http://zhoujiapeng.top/java/java-ThreadLocal</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 之 线程基础</title>
      <link href="/java/java-thread-base/"/>
      <url>/java/java-thread-base/</url>
      
        <content type="html"><![CDATA[<h2 id="1-线程的创建与运行"><a href="#1-线程的创建与运行" class="headerlink" title="1. 线程的创建与运行"></a>1. 线程的创建与运行</h2><p>&emsp;Java 中由三种线程创建方式，分别为实现 Runnable 接口的run方法，继承 Thread 类并重写run方法，使用 FutureTask 方式。</p><h3 id="1-1-Thread-方式"><a href="#1-1-Thread-方式" class="headerlink" title="1.1 Thread 方式"></a>1.1 Thread 方式</h3><p>示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程创建的三种方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCreate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"I am a child thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        MyThread thread = <span class="keyword">new</span> MyThread();</span><br><span class="line">        thread.start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-2-Runnable-方式"><a href="#1-2-Runnable-方式" class="headerlink" title="1.2 Runnable 方式"></a>1.2 Runnable 方式</h3><p>示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程创建的三种方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCreate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"I am a child thread"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        RunableTask task = <span class="keyword">new</span> RunableTask();</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(task).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="1-3-FutureTask-方式"><a href="#1-3-FutureTask-方式" class="headerlink" title="1.3 FutureTask 方式"></a>1.3 FutureTask 方式</h3><p>示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Callable;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.FutureTask;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 线程创建的三种方式</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadCreate</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CallerTask</span> <span class="keyword">implements</span> <span class="title">Callable</span>&lt;<span class="title">String</span>&gt;</span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">call</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            <span class="comment">//返回值</span></span><br><span class="line">            <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        FutureTask&lt;String&gt; futureTask = <span class="keyword">new</span> FutureTask&lt;&gt;(<span class="keyword">new</span> CallerTask());</span><br><span class="line">        <span class="keyword">new</span> Thread(futureTask).start();</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//等待任务结束，并返回结果</span></span><br><span class="line">            String result = futureTask.get();</span><br><span class="line">            System.out.println(result);</span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-线程通知与等待"><a href="#2-线程通知与等待" class="headerlink" title="2. 线程通知与等待"></a>2. 线程通知与等待</h2><p>&emsp;Object 类包含了通知和等待系列函数，由于继承机制，Java 中所有类都带有这类函数。</p><h3 id="2-1-wait-函数"><a href="#2-1-wait-函数" class="headerlink" title="2.1 wait 函数"></a>2.1 wait 函数</h3><p>&emsp;当一个线程调用一个共享变量的wait方法时，该线程会被阻塞挂起，直到发生以下情况：</p><ul><li>其它线程调用该共享变量的 notify 方法 或 notifyAll 方法；</li><li>其它线程调用了该线程的 interrupt 方法，该线程抛出 InterruptedException 异常返回；</li></ul><p>&emsp;需要注意的是，调用 wait 方法需要事<strong>先获取该对象的监视器锁</strong>，否则会抛出 IllegalMonitorStateException 异常。<br>&emsp;获取监视器锁的方法：<br>(1) 执行 synchronized 同步代码块，使用该共享变量作为参数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(共享变量)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>(2) 调用该共享变量的方法，并且该方法使用了 synchronized 修饰<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a,<span class="keyword">int</span> b)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;另外需要注意的是，一个线程可以从挂起状态变为运行状态（也就是被唤醒），即使其它线程没有调用 notify 方法或 notifyAll 方法，或者被中断，或者等待超时，这就是所谓的<strong>虚假唤醒</strong>。虽然虚假唤醒在实际中很少发生，但要防范于未然，做法就是不停去测试该线程被唤醒的条件是否满足，不满足则继续等待。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span>(obi)&#123;</span><br><span class="line">    <span class="keyword">while</span>(条件不满足)</span><br><span class="line">        obj.wait();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;线程调用 wait 方法之后，会释放锁该变量的监视器锁，然后阻塞一直等待到被唤醒，并且重新获得监视器锁才会返回。<br>&emsp;需要<strong>注意</strong>的是，调用 wait 方法只会释放当前共享变量上的锁，如果当前线程还持有其它共享变量的锁，则这些锁是<strong>不会被释放</strong>的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>当一个线程调用wait被阻塞后，其它线程中断了该线程，则该线程会抛出 InterruptedException 异常并返回。</p><p>wait(long timeout)和 wait(long timeout,int nanos)相比 wait 函数多了超时参数，wait 方法就等于wait(0),函数会因为超时而返回，不会一直等待。</p><h3 id="2-2-notify-函数"><a href="#2-2-notify-函数" class="headerlink" title="2.2 notify 函数"></a>2.2 notify 函数</h3><p>&emsp;一个线程调用 notify 方法，会唤醒一个在该共享变量上调用 wait 方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。此外，被唤醒的线程必须在重新获取该共享对象的监视器锁后才会返回，因为被唤醒的线程可能还需要和其它线程竞争该监视器锁，所以被唤醒的线程不一定能够继续执行。<br>&emsp;notifyAll 方法则会唤醒所有在该共享变量上调用wait被阻塞的线程。<br>&emsp;类似wait函数，只有当前线程<strong>获取到了共享变量的监视器锁才能调用notify方法</strong>。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WaitTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Object resourceA = <span class="keyword">new</span> Object();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> Object resourceB = <span class="keyword">new</span> Object();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableA</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread A get resourceA lock"</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread A get resourceB lock"</span>);</span><br><span class="line"></span><br><span class="line">                        <span class="comment">//线程A阻塞并释放 resourceA 上的锁</span></span><br><span class="line">                        resourceA.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">RunableB</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                <span class="comment">//休眠，保证ThreadA先拿到锁</span></span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">                <span class="keyword">synchronized</span> (resourceA) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"Thread B get resourceA lock"</span>);</span><br><span class="line">                    System.out.println(<span class="string">"Thread B try to get resourceB lock..."</span>);</span><br><span class="line">                    <span class="keyword">synchronized</span> (resourceB) &#123;</span><br><span class="line">                        System.out.println(<span class="string">"Thread B get resourceB lock"</span>);</span><br><span class="line">                        <span class="comment">//阻塞并释放 resourceA 上的锁</span></span><br><span class="line">                        resourceA.wait();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunableA());</span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> RunableB());</span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;上述例子threadA在调用wait之后释放了resourceA上的锁，但是没有释放resourceB上的锁，threadA阻塞在 resourceA.wait()处，threadB 阻塞在 synchronized (resourceB) 处。</p><h2 id="3-join-方法"><a href="#3-join-方法" class="headerlink" title="3. join 方法"></a>3. join 方法</h2><p>&emsp;Thread类的join方法可以使得当前线程被阻塞，等待某个线程结束再继续往下执行，join是无参且返回值为void的方法。另外，线程A调用线程B的join方法后被阻塞，当其它线程调用了线程A的interrupt方法中断了线程A，线程A会抛出 InterruptedException 异常而返回。</p><h2 id="4-sleep-方法"><a href="#4-sleep-方法" class="headerlink" title="4. sleep 方法"></a>4. sleep 方法</h2><p>&emsp;sleep是Thread类的静态方法，当一个线程调用 Thread.sleep 后，调用线程会暂时让出指定时间的执行权，在这段时间内不参与CPU调度。<br>&emsp;当时该线程持有的监视器资源，比如<strong>锁是保持持有不让出的</strong>。在睡眠期间其它线程调用了该线程的 interrupt 方法中断该线程，则该线程会抛出 InterruptedException 异常而返回。</p><h2 id="5-yield-方法"><a href="#5-yield-方法" class="headerlink" title="5. yield 方法"></a>5. yield 方法</h2><p>&emsp;yield是Thread的静态方法，当一个线程调用 yield 方法时，当前线程会让出 CPU 使用权，然后处于就绪状态，线程调度器会从线程就绪队列中获取一个线程优先级最高的线程，当然也可能会调度到刚刚让出 CPU 的那个线程来获取 CPU 执行权。</p><h2 id="6-线程中断"><a href="#6-线程中断" class="headerlink" title="6. 线程中断"></a>6. 线程中断</h2><p>&emsp;Java中的线程中断是一种线程间协作模式，实际是通过<strong>设置线程的中断标志，并不能直接终止该线程的执行，而需要被中断线程根据中断状态自行处理</strong>。<br>&emsp;关于中断有几个方法需要区分：</p><ul><li>void interrupt()：该方法会设置被调用线程的中断标志为true，实际并不会直接中断该线程。如果线程A因为调用 wait、join 或 sleep 方法而被阻塞，其它线程调用线程A的interrupt方法会导致线程A在调用这些方法的地方抛出 InterruptedException 异常而返回。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">interrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//检查权限</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span> != Thread.currentThread())</span><br><span class="line">            checkAccess();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">synchronized</span> (blockerLock) &#123;</span><br><span class="line">            Interruptible b = blocker;</span><br><span class="line">            <span class="keyword">if</span> (b != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="comment">//设置中断标志</span></span><br><span class="line">                interrupt0();           <span class="comment">// Just to set the interrupt flag</span></span><br><span class="line">                b.interrupt(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        interrupt0();</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">interrupt0</span><span class="params">()</span></span>;</span><br></pre></td></tr></table></figure></li><li>boolean isInterrupted()：检测<strong>当前被调用线程</strong>是否被中断，返回中断标志状态<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> isInterrupted(<span class="keyword">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">isInterrupted</span><span class="params">(<span class="keyword">boolean</span> ClearInterrupted)</span></span>;</span><br></pre></td></tr></table></figure></li><li>boolean interrupted()：静态方法，检测<strong>当前线程</strong>是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">interrupted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> currentThread().isInterrupted(<span class="keyword">true</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>下面看一个线程使用 Interrupted 优雅退出的例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Thread.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">try</span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!Thread.currentThread().isInterrupted()&amp;&amp; more work to <span class="keyword">do</span>)&#123;</span><br><span class="line">            <span class="comment">//do more work</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">catch</span>(InterruptedException e)&#123;</span><br><span class="line">        <span class="comment">// thread was interrupted during sleep or wait</span></span><br><span class="line">    &#125;<span class="keyword">finally</span>&#123;</span><br><span class="line">        <span class="comment">//cleanup,if required</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;最后使用一个例子区分总结一下这三个方法的区别：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">InterruptTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        Thread thread = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span>(;;)&#123;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line"><span class="comment">//                while(!Thread.interrupted())&#123;  //中断标志为true时会退出循环，并清除中断标志</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">//                &#125;</span></span><br><span class="line"><span class="comment">//                System.out.println("in isInterrupted:" + Thread.currentThread().isInterrupted());</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//启动</span></span><br><span class="line">        thread.start();</span><br><span class="line">        <span class="comment">//设置中断标志</span></span><br><span class="line">        thread.interrupt();</span><br><span class="line">        <span class="comment">//获取中断标志</span></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted:"</span> + thread.isInterrupted()); <span class="comment">//判断thread</span></span><br><span class="line">        <span class="comment">//获取中断标志并重置</span></span><br><span class="line">        <span class="comment">//获取的是当前线程(主线程)，不是thread线程</span></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted:"</span> + thread.interrupted());   <span class="comment">//判断currentThread</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted:"</span> + Thread.interrupted());   <span class="comment">//判断currentThread</span></span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"isInterrupted:"</span> + thread.isInterrupted());  <span class="comment">//判断thread</span></span><br><span class="line"></span><br><span class="line">        thread.join();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"main thread is over"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>运行结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">isInterrupted:true</span><br><span class="line">isInterrupted:false</span><br><span class="line">isInterrupted:false</span><br><span class="line">isInterrupted:true</span><br></pre></td></tr></table></figure><br>如果上述例子的for空循环替换成注释部分，可以验证 interrupted 函数是否会真的清除标志位，执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">isInterrupted:true</span><br><span class="line">isInterrupted:false</span><br><span class="line">isInterrupted:false</span><br><span class="line">isInterrupted:true  &#x2F;&#x2F;可能为true或false，这里运行时可能在标志位清除之前或之后</span><br><span class="line">in isInterrupted:false &#x2F;&#x2F;标志位被清除</span><br><span class="line">main thread is over</span><br></pre></td></tr></table></figure></p><h2 id="7-守护线程与用户线程"><a href="#7-守护线程与用户线程" class="headerlink" title="7. 守护线程与用户线程"></a>7. 守护线程与用户线程</h2><p>&emsp;Java中的线程分为两类，分别为 daemon线程（守护线程）和 user线程（用户线程）。JVM启动时会调用main函数，main函数所在的线程就是一个用户线程，其实在JVM内部同时启动了好多守护线程，比如垃圾回收线程。守护线程和非守护线程的区别在于：当最后一个非守护线程结束时，JVM会正常退出，而不管当前是否有守护线程，也就是说守护线程是否结束不会影响JVM的退出，只要有一个用户线程还没结束，JVM就不会退出。<br>注意：</p><ul><li>正在运行的常规线程不应该设置为守护线程；</li><li>thread.setDaemon(true)必须在thread.start()之前设置，否则会跑出一个IllegalThreadStateException异常；</li><li>在Daemon线程中产生的新线程也是Daemon的（这里要和linux的区分，linux中守护进程fork()出来的子进程不再是守护进程）；</li><li>根据自己的场景使用（在应用中，有可能你的Daemon Thread还没来的及进行操作时，虚拟机可能已经退出了）；</li></ul><p>&nbsp;</p><blockquote><p>参考：<br>《Java 并发编程之美》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 线程同步器 之 Semaphore 原理剖析</title>
      <link href="/java/java-Semaphore/"/>
      <url>/java/java-Semaphore/</url>
      
        <content type="html"><![CDATA[<h1 id="Semaphore-原理剖析"><a href="#Semaphore-原理剖析" class="headerlink" title="Semaphore 原理剖析"></a>Semaphore 原理剖析</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;Semaphore 信号量也是 Java 中的一个同步器，与 CountDownLatch 和 CycleBarrier 不同的是，它内部的计数器是<strong>递增</strong>的，并且在一开始初始化 Semaphore 时可以指定一个初始值，但是并不需要知道同步的线程数量，而是在需要同步的地方调用 acquire 方法时指定需要同步的线程数量。<br>&emsp;信号量（Semaphore）控制同时访问资源的线程数量，支持公平和非公平两种方式。</p><p>提供的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span>    <span class="comment">//permits为许可数，默认非公平方式</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//获取一个许可。若获取成功，permits-1，直接返回；否则当前线程阻塞直到有permits被释放，除非线程被中断</span></span></span><br><span class="line"><span class="function"><span class="comment">//如果线程被中断，则抛出 InterruptedException，并且清除当前线程的已中断状态。 </span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//忽略中断</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//尝试获取一个许可，成功返回true，否则返回false。</span></span></span><br><span class="line"><span class="function"><span class="comment">//即使已将此信号量设置为使用公平排序策略，但是调用 tryAcquire() 也将 立即获取许可（如果有一个可用），而不管当前是否有正在等待的线程。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//超时尝试获取一个许可，该方法遵循公平设置</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function"><span class="comment">//释放一个许可</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//以上方法都是获取或释放一个许可，每个方法都存在对应的获取或释放指定个数许可的方法。例如public boolean tryAcquire(int permits)</span></span></span><br><span class="line"><span class="function">...</span></span><br></pre></td></tr></table></figure></p><p>使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SemaphoreTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Semaphore semaphore = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" over"</span>);</span><br><span class="line">                semaphore.release();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        <span class="comment">//等待子线程执行完毕，返回</span></span><br><span class="line">        semaphore.acquire(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"all child thread over"</span>);</span><br><span class="line">        <span class="comment">//semaphore可复用</span></span><br><span class="line">        executorService.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> MyRunnable());</span><br><span class="line">        <span class="comment">//等待子线程执行完毕，返回</span></span><br><span class="line">        semaphore.acquire(<span class="number">2</span>);</span><br><span class="line">        System.out.println(<span class="string">"all child thread over"</span>);</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h2><p>&emsp;Semaphore 基于AQS实现，用同步状态（state）表示许可数（permits），使用AQS的共享式获取和释放同步状态来实现permits的获取和释放。Semaphore 内部的 Sync 只是对 AQS 的一个修饰，并且 Sync 有两个实现类，用来制定获取信号量时是否采用公平策略：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        sync = <span class="keyword">new</span> NonfairSync(permits); <span class="comment">//默认使用非公平策略</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Semaphore</span><span class="params">(<span class="keyword">int</span> permits, <span class="keyword">boolean</span> fair)</span> </span>&#123;</span><br><span class="line">        sync = fair ? <span class="keyword">new</span> FairSync(permits) : <span class="keyword">new</span> NonfairSync(permits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;下面看一下 acquire 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//阻塞式获取一个许可，响应中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);    <span class="comment">//调用AQS提供的可响应中断共享式获取同步状态方法</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//如果被中断，抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;tryAcquireShared 方法由 Sync 的子类实现，这里分别从两方法来讨论，先讨论非公平策略 NonfairSync 的 tryAcquireShared 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> nonfairTryAcquireShared(acquires);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">nonfairTryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前信号量的值</span></span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="comment">//计算当前剩余值</span></span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="comment">//如果剩余值小于0或者 CAS 设置成功则返回</span></span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;如果当前信号量值不满足需要，即返回的remaining为负数，则会调用 doAcquireSharedInterruptibly 方法，会将当前线程放入 AQS 阻塞队列中挂起。<br>另外，由于 NonfairSync 是非公平获取的，也就是说先调用 acquire 方法的线程不一定比后来者先获取到信号量。考虑下面场景：线程A调用acquire而被阻塞挂起，此时线程 B 调用 release 释放足够的信号量，线程 C 在线程 A 被唤醒前调用了 acquire，则信号量可能被线程C 获取到。<br>下面看一下公平策略 FairSync 的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">if</span> (hasQueuedPredecessors())</span><br><span class="line">                    <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">int</span> available = getState();</span><br><span class="line">                <span class="keyword">int</span> remaining = available - acquires;</span><br><span class="line">                <span class="keyword">if</span> (remaining &lt; <span class="number">0</span> ||</span><br><span class="line">                    compareAndSetState(available, remaining))</span><br><span class="line">                    <span class="keyword">return</span> remaining;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;可以看到，公平性是由 hasQueuedPredecessors 来保证的，如果当前阻塞队列中有等待的线程，则当前线程无法获得信号量。</p><p>&emsp;acquire(int permits) 方法和 acquire 类似，不同的只是可以指定需要信号量数。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> permits)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.acquireSharedInterruptibly(permits);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;acquireUninterruptibly 不同于 acquire 方法之处在于该方法对中断不响应<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">acquireUninterruptibly</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.acquireShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//这里没有检测中断标志</span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;接下来看一下 release 方法，该方法的作用是把当前 semaphore 对象的信号量值增加1，如果当前有线程因为调用 acquire 方法而被阻塞放进 AQS 队列，则会根据公平策略选择一个信号量个数能被满足的线程进行激活，激活的线程再次<strong>尝试</strong>获取刚增加的信号量。注意，这里并不一定能够成功获取，如果设置的是非公平策略，则可能被其它线程抢先获取。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> permits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (permits &lt; <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        sync.releaseShared(permits);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//tryReleaseShared 更新信号量的值</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">//唤醒被阻塞的县城</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="comment">//获取当前信号量值</span></span><br><span class="line">                <span class="keyword">int</span> current = getState();</span><br><span class="line">                <span class="comment">//增加releases个信号量</span></span><br><span class="line">                <span class="keyword">int</span> next = current + releases;</span><br><span class="line">                <span class="keyword">if</span> (next &lt; current) <span class="comment">// overflow</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">"Maximum permit count exceeded"</span>);</span><br><span class="line">                    <span class="comment">//使用CAS保证更新信号量的原子性</span></span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(current, next))</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br>《Java 并发编程之美》</p></blockquote><hr><p>相关推荐：<br>Java 并发包中线程同步器系列：</p><ul><li><a href="http://zhoujiapeng.top/java/java-CountDownLatch">《Java 线程同步器 之 CountDownLatch 原理剖析》</a></li><li><a href="http://zhoujiapeng.top/java/java-CyclicBarrier">《Java 线程同步器 之 CyclicBarrier 原理剖析》</a></li><li><a href="http://zhoujiapeng.top/java/java-Semaphore">《Java 线程同步器 之 Semaphore 原理剖析》</a></li></ul><p>&emsp;使用同步器有助于我们大大减少在Java中使用wait、noify等来实现线程同步的代码量，在日常开发中需要进行线程同步时使用这些同步类会节省很多代码并且保证正确性。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 线程同步器 之 CyclicBarrier 原理剖析</title>
      <link href="/java/java-CyclicBarrier/"/>
      <url>/java/java-CyclicBarrier/</url>
      
        <content type="html"><![CDATA[<h1 id="CyclicBarrier-原理剖析"><a href="#CyclicBarrier-原理剖析" class="headerlink" title="CyclicBarrier 原理剖析"></a>CyclicBarrier 原理剖析</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;CyclicBarrier是一个同步工具类，它允许一组线程互相等待，直到到达某个公共屏障点。与CountDownLatch不同的是该barrier在释放等待线程后可以<strong>重用</strong>，所以称它为循环（Cyclic）的屏障（Barrier）。CyclicBarrier支持一个可选的Runnable命令，在一组线程中的最后一个线程到达之后（但在释放所有线程之前），该命令只在每个屏障点运行一次。若在继续所有参与线程之前更新共享状态，此屏障操作很有用。</p><p>&emsp;提供的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//parties表示屏障拦截的线程数量，当屏障撤销时，先执行barrierAction，然后在释放所有线程</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties, Runnable barrierAction)</span></span></span><br><span class="line"><span class="function"><span class="comment">//barrierAction默认为null</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">CyclicBarrier</span><span class="params">(<span class="keyword">int</span> parties)</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">/*</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 当前线程等待直到所有线程都调用了该屏障的await()方法</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果当前线程不是将到达的最后一个线程，将会被阻塞。解除阻塞的情况有以下几种</span></span></span><br><span class="line"><span class="function"><span class="comment">    1）最后一个线程调用await()</span></span></span><br><span class="line"><span class="function"><span class="comment">    2）当前线程被中断</span></span></span><br><span class="line"><span class="function"><span class="comment">    3）其他正在该CyclicBarrier上等待的线程被中断</span></span></span><br><span class="line"><span class="function"><span class="comment">    4）其他正在该CyclicBarrier上等待的线程超时</span></span></span><br><span class="line"><span class="function"><span class="comment">    5）其他某个线程调用该CyclicBarrier的reset()方法</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果当前线程在进入此方法时已经设置了该线程的中断状态或者在等待时被中断，将抛出InterruptedException，并且清除当前线程的已中断状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果在线程处于等待状态时barrier被reset()或者在调用await()时 barrier 被损坏，将抛出 BrokenBarrierException 异常。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果任何线程在等待时被中断，则其他所有等待线程都将抛出 BrokenBarrierException 异常，并将 barrier 置于损坏状态。 </span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果当前线程是最后一个将要到达的线程，并且构造方法中提供了一个非空的屏障操作（barrierAction），那么在允许其他线程继续运行之前，当前线程将运行该操作。</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，并将 barrier 置于损坏状态。</span></span></span><br><span class="line"><span class="function"><span class="comment"> *</span></span></span><br><span class="line"><span class="function"><span class="comment"> * 返回值为当前线程的索引，0表示当前线程是最后一个到达的线程</span></span></span><br><span class="line"><span class="function"><span class="comment"> */</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException</span></span><br><span class="line"><span class="function"><span class="comment">//在await()的基础上增加超时机制，如果超出指定的等待时间，则抛出 TimeoutException 异常。如果该时间小于等于零，则此方法根本不会等待。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException, TimeoutException</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//将屏障重置为其初始状态。如果所有参与者目前都在屏障处等待，则它们将返回，同时抛出一个BrokenBarrierException。</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><br>&emsp;对于失败的同步尝试，CyclicBarrier 使用了一种要么全部要么全不 (<strong>all-or-none</strong>) 的破坏模式：如果因为中断、失败或者超时等原因，导致线程过早地离开了屏障点，那么在该屏障点等待的其他所有线程也将通过 BrokenBarrierException（如果它们几乎同时被中断，则用 InterruptedException）以反常的方式离开。</p><p>&emsp;使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CyclicBarrier 回环屏障(路障)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CyclicBarrierTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier cyclicBarrier = <span class="keyword">new</span> CyclicBarrier(<span class="number">2</span>, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123; <span class="comment">//当所有线程达到屏障点时触发执行</span></span><br><span class="line">            System.out.println(Thread.currentThread() + <span class="string">" task1 merge result"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        MyRunnable(String name)&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" task 1-"</span> + name);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" reach step1"</span>);</span><br><span class="line">                cyclicBarrier.await();</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" finish step1"</span>);</span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" reach step2"</span>);</span><br><span class="line">                cyclicBarrier.await();  <span class="comment">//可以重复利用</span></span><br><span class="line">                System.out.println(Thread.currentThread() + <span class="string">" finish step2"</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> MyRunnable(<span class="string">"1"</span>));</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> MyRunnable(<span class="string">"2"</span>));</span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-实现原理"><a href="#2-实现原理" class="headerlink" title="2. 实现原理"></a>2. 实现原理</h2><p>&emsp;CyclicBarrier 基于 ReentrantLock 和 Condition 机制实现。除了 getParties() 方法，CyclicBarrier 的其他方法都需要获取锁。</p><p>域<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The lock for guarding barrier entry */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//可重入锁</span></span><br><span class="line"><span class="comment">/** Condition to wait on until tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition trip = lock.newCondition();</span><br><span class="line"><span class="comment">/** The number of parties */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> parties;    <span class="comment">//拦截的线程数量</span></span><br><span class="line"><span class="comment">/* The command to run when tripped */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable barrierCommand;    <span class="comment">//当屏障撤销时，需要执行的屏障操作</span></span><br><span class="line"><span class="comment">//当前的Generation。每当屏障失效或者开闸之后都会自动替换掉。从而实现重置的功能。</span></span><br><span class="line"><span class="keyword">private</span> Generation generation = <span class="keyword">new</span> Generation();</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Number of parties still waiting. Counts down from parties to 0</span></span><br><span class="line"><span class="comment"> * on each generation.  It is reset to parties on each new</span></span><br><span class="line"><span class="comment"> * generation or when broken.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> count;    <span class="comment">//还能阻塞的线程数（即parties-当前阻塞的线程数），当新建generation或generation被破坏时，count会被重置。因为对Count的操作都是在获取锁之后，所以不需要其他同步措施。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//用来记录当前屏障是否被打破</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Generation</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> broken = <span class="keyword">false</span>;    <span class="comment">//当前的屏障是否破坏</span></span><br><span class="line">&#125;</span><br><span class="line">``` </span><br><span class="line">&amp;emsp;这里的 Generation 用来记录当前屏障是否被打破，当当前线程被中断或者等待超时 generation 会被记录为 <span class="keyword">true</span>，所有线程会抛出 BrokenBarrierException 异常而返回，当 CyclicBarrier 重置时会 generation 也会被重置。具体可以看后面的 dowait 方法介绍。</span><br><span class="line"></span><br><span class="line">&amp;emsp;接下来看一下 await 方法，线程调用 await 方法都会被阻塞，知道满足下面条件之一才会返回：</span><br><span class="line">- <span class="number">1</span>）最后一个线程调用await()，即 parties 个线程都调用了 await 方法，返回 <span class="keyword">true</span>；</span><br><span class="line">- <span class="number">2</span>) 设置的超时时间到了，返回 <span class="keyword">false</span>；</span><br><span class="line">- <span class="number">3</span>）其它线程调用当前线程的 interupt 方法中断当前线程，抛出 InterruptedException 异常返回；</span><br><span class="line">- <span class="number">4</span>) 与当前屏障点关联的 Generation 对象的 broken 标志被设置为 <span class="keyword">true</span>，抛出 BrokenBarrierException 异常返回；</span><br><span class="line">    - <span class="number">4.1</span>）其他正在该CyclicBarrier上等待的线程被中断；</span><br><span class="line">    - <span class="number">4.2</span>）其他正在该CyclicBarrier上等待的线程超时；</span><br><span class="line">    - <span class="number">4.3</span>）其他某个线程调用该CyclicBarrier的reset()方法；</span><br><span class="line"></span><br><span class="line">如果当前线程在进入此方法时已经设置了该线程的中断状态或者在等待时被中断，将抛出InterruptedException，并且清除当前线程的已中断状态。</span><br><span class="line">如果在线程处于等待状态时barrier被reset()或者在调用await()时 barrier 被损坏，将抛出 BrokenBarrierException 异常。</span><br><span class="line">如果任何线程在等待时被中断，则其他所有等待线程都将抛出 BrokenBarrierException 异常，并将 barrier 置于损坏状态。 </span><br><span class="line">如果当前线程是最后一个将要到达的线程，并且构造方法中提供了一个非空的屏障操作（barrierAction），那么在允许其他线程继续运行之前，当前线程将运行该操作。</span><br><span class="line">如果在执行屏障操作过程中发生异常，则该异常将传播到当前线程中，并将 barrier 置于损坏状态。</span><br><span class="line"> </span><br><span class="line">返回值为当前线程的索引，<span class="number">0</span>表示当前线程是最后一个到达的线程。</span><br><span class="line"></span><br><span class="line">&amp;emsp;调用 await 方法后，当前线程会被放入条件变量 trip 的条件阻塞队列，当前线程会被挂起并释放获得的 lock 锁。</span><br><span class="line">```java</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, BrokenBarrierException </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> dowait(<span class="keyword">false</span>, <span class="number">0L</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (TimeoutException toe) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(toe); <span class="comment">// cannot happen</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">int</span> <span class="title">dowait</span><span class="params">(<span class="keyword">boolean</span> timed, <span class="keyword">long</span> nanos)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException, BrokenBarrierException,</span></span><br><span class="line"><span class="function">           TimeoutException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//保存此时的generation</span></span><br><span class="line">        <span class="keyword">final</span> Generation g = generation;</span><br><span class="line">        <span class="comment">//判断屏障是否被破坏（可能被其它线程破环了）</span></span><br><span class="line">        <span class="keyword">if</span> (g.broken)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">        <span class="comment">//判断线程是否被中断，如果被中断，调用breakBarrier()进行屏障破坏处理，并抛出InterruptedException</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted()) &#123;</span><br><span class="line">            breakBarrier();    </span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> index = --count;    <span class="comment">//剩余count递减，并赋值给线程索引，作为方法的返回值</span></span><br><span class="line">        <span class="comment">//如果线程索引将为0，说明当前线程是最后一个到达的线程。执行可能存在的屏障操作 barrierCommand，设置下一个Generation。相当于每次开闸之后都进行了一次reset。</span></span><br><span class="line">        <span class="keyword">if</span> (index == <span class="number">0</span>) &#123;  <span class="comment">// tripped    </span></span><br><span class="line">            <span class="keyword">boolean</span> ranAction = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">final</span> Runnable command = barrierCommand;</span><br><span class="line">                <span class="keyword">if</span> (command != <span class="keyword">null</span>)</span><br><span class="line">                    command.run();    <span class="comment">//同步执行barrierCommand</span></span><br><span class="line">                ranAction = <span class="keyword">true</span>;</span><br><span class="line">                nextGeneration();    <span class="comment">//执行成功设置下一个nextGeneration,会重置一些变量</span></span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!ranAction)    <span class="comment">//如果barrierCommand执行失败，进行屏障破坏处理</span></span><br><span class="line">                    breakBarrier();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//如果当前线程不是最后一个到达的线程，阻塞等待</span></span><br><span class="line">        <span class="comment">// loop until tripped, broken, interrupted, or timed out</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!timed)</span><br><span class="line">                    trip.await();    <span class="comment">//调用Condition的await()方法阻塞</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (nanos &gt; <span class="number">0L</span>)</span><br><span class="line">                    nanos = trip.awaitNanos(nanos);    <span class="comment">//调用Condition的awaitNanos()方法阻塞，挂起并释放获得的 lock 锁</span></span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException ie) &#123;</span><br><span class="line">                <span class="comment">//如果当前线程被中断，则判断是否有其他线程已经使屏障破坏。若没有则进行屏障破坏处理，并抛出异常；否则再次中断当前线程</span></span><br><span class="line">                <span class="keyword">if</span> (g == generation &amp;&amp; ! g.broken) &#123;    </span><br><span class="line">                    breakBarrier();</span><br><span class="line">                    <span class="keyword">throw</span> ie;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// We're about to finish waiting even if we had not</span></span><br><span class="line">                    <span class="comment">// been interrupted, so this interrupt is deemed to</span></span><br><span class="line">                    <span class="comment">// "belong" to subsequent execution.</span></span><br><span class="line">                    Thread.currentThread().interrupt();</span><br><span class="line">                    <span class="comment">//这种捕获了InterruptException之后调用Thread.currentThread().interrupt()是一种通用的方式。其实就是为了保存中断状态，从而让其他更高层次的代码注意到这个中断。</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//如果屏障被破坏，当前线程抛BrokenBarrierException</span></span><br><span class="line">            <span class="keyword">if</span> (g.broken)</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> BrokenBarrierException();</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果已经换代，直接返回index（last thread已经执行的nextGeneration，但当前线程还没有执行到该语句）</span></span><br><span class="line">            <span class="keyword">if</span> (g != generation)</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//超时，进行屏障破坏处理，并抛TimeoutException</span></span><br><span class="line">            <span class="keyword">if</span> (timed &amp;&amp; nanos &lt;= <span class="number">0L</span>) &#123;</span><br><span class="line">                breakBarrier();</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();    <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将当前屏障置为破坏状态、重置count、并唤醒所有被阻塞的线程。</span></span><br><span class="line"><span class="comment">//必须先获取锁，才能调用此方法</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">breakBarrier</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    generation.broken = <span class="keyword">true</span>;</span><br><span class="line">    count = parties;</span><br><span class="line">    trip.signalAll(); <span class="comment">//唤醒阻塞在条件变量中的线程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒trip上等待的所有线程，设置下一个Generation，重置一些变量</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">nextGeneration</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// signal completion of last generation</span></span><br><span class="line">    trip.signalAll();</span><br><span class="line">    <span class="comment">// set up next generation</span></span><br><span class="line">    count = parties;</span><br><span class="line">    generation = <span class="keyword">new</span> Generation();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>再看一下 reset 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//重置屏障，先进行屏障破坏处理，再设置下一代generation</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        breakBarrier();   <span class="comment">// break the current generation</span></span><br><span class="line">        nextGeneration(); <span class="comment">// start a new generation</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-CyclicBarrier与CountDownLatch比较"><a href="#3-CyclicBarrier与CountDownLatch比较" class="headerlink" title="3. CyclicBarrier与CountDownLatch比较"></a>3. CyclicBarrier与CountDownLatch比较</h2><ul><li>1）CountDownLatch:一个线程(或者多个)，等待另外N个线程完成某个事情之后才能执行；CyclicBarrier:N个线程相互等待，任何一个线程完成之前，所有的线程都必须等待。</li><li>2）CountDownLatch:一次性的；CyclicBarrier:可以重复使用。</li><li>3）CountDownLatch基于AQS；CyclicBarrier基于ReentrantLock锁和Condition，ReentrantLock锁实际上也是基于AQS。本质上都是依赖于volatile和CAS实现的。</li></ul><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.cnblogs.com/zaizhoumo/p/7787064.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaizhoumo/p/7787064.html</a><br>《Java 并发编程之美》</p></blockquote><hr><p>相关推荐：<br>Java 并发包中线程同步器系列：</p><ul><li><a href="http://zhoujiapeng.top/java/java-CountDownLatch">《Java 线程同步器 之 CountDownLatch 原理剖析》</a></li><li><a href="http://zhoujiapeng.top/java/java-CyclicBarrier">《Java 线程同步器 之 CyclicBarrier 原理剖析》</a></li><li><a href="http://zhoujiapeng.top/java/java-Semaphore">《Java 线程同步器 之 Semaphore 原理剖析》</a></li></ul><p>&emsp;使用同步器有助于我们大大减少在Java中使用wait、noify等来实现线程同步的代码量，在日常开发中需要进行线程同步时使用这些同步类会节省很多代码并且保证正确性。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 线程同步器 之 CountDownLatch 原理剖析</title>
      <link href="/java/java-CountDownLatch/"/>
      <url>/java/java-CountDownLatch/</url>
      
        <content type="html"><![CDATA[<h1 id="CountDownLatch-原理剖析"><a href="#CountDownLatch-原理剖析" class="headerlink" title="CountDownLatch 原理剖析"></a>CountDownLatch 原理剖析</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;CountDownLatch是一个同步工具类，它允许一个或多个线程一直等待，直到其他线程的操作执行完后再执行。<br>&emsp;CountDownLatch使用一个计数器count实现，构建CountDownLatch时需要使用给定的count初始化CountDownLatch。在count到达0之前，调用await()方法的线程将一直阻塞，当count到达0时，会唤醒所有阻塞的线程。注意：计数器count<strong>无法被重置</strong>，即只能实现一次这种功能，这也是CountDownLatch与CyclicBarrier的区别。</p><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>&emsp;CountDownLatch 是一个通用同步工具，它有很多用途。将计数 1 初始化的 CountDownLatch 用作一个简单的开/关锁存器，或入口：在通过调用 countDown() 的线程打开入口前，所有调用 await 的线程都一直在入口处等待。用 N 初始化的 CountDownLatch 可以使一个线程在 N 个线程完成某项操作之前一直等待，或者使其在某项操作完成 N 次之前一直等待。</p><p>&emsp;提供的方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使当前线程阻塞直到计数器count变为0，除非被中断</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//使当前线程阻塞直到计数器count变为0，除非被中断或超过了指定时间</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">await</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException</span></span><br><span class="line"><span class="function"><span class="comment">//将计数器count递减，若count变为0则唤醒所有等待的线程</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span></span></span><br><span class="line"><span class="function"><span class="comment">//返回计数器count值</span></span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">getCount</span><span class="params">()</span></span></span><br></pre></td></tr></table></figure><br>&emsp;使用示例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * CountDownLatch 线程同步器测试</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CountDownLatchTest</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">volatile</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyRunnable</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line">        MyRunnable(String name)&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span>&#123;</span><br><span class="line">                Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                System.out.println(name + <span class="string">" over"</span>);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">        ExecutorService executorService = Executors.newFixedThreadPool(<span class="number">2</span>);</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> MyRunnable(<span class="string">"ThreadOne"</span>));</span><br><span class="line">        executorService.submit(<span class="keyword">new</span> MyRunnable(<span class="string">"ThreadTwo"</span>));</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"wait all child thread over!"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//等待子线程执行完毕，返回</span></span><br><span class="line">        countDownLatch.await();</span><br><span class="line"></span><br><span class="line">        System.out.println(<span class="string">"all child thread over!"</span>);</span><br><span class="line"></span><br><span class="line">        executorService.shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><p>&emsp;CountDownLatch基于AQS实现，使用AQS的同步状态state表示计数器count。<br>&emsp;先看一下CountDownLatch的内部类Syns的实现，Syns继承了 <strong>AbstractQueuedSynchronizer</strong>：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Sync</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">4982264981922014374L</span>;</span><br><span class="line"></span><br><span class="line">        Sync(<span class="keyword">int</span> count) &#123;</span><br><span class="line">            setState(count);  <span class="comment">//设置同步状态state为count</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">int</span> <span class="title">getCount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> getState();  <span class="comment">//查询同步状态</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重写AQS的共享式获取同步状态的方法。当state=0时返回1，获取成功；当state=1时返回-1，获取失败。</span></span><br><span class="line">        <span class="comment">//acquires实际无用</span></span><br><span class="line">        <span class="comment">//该方法会被 await 方法调用，判断count是否减至0</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//重写AQS的共享式释放同步状态的方法。基于自旋CAS递减同步状态</span></span><br><span class="line">        <span class="comment">//会被countDown调用，计数器减1</span></span><br><span class="line">        <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="comment">//如果state=0，那么直接返回false</span></span><br><span class="line">            <span class="comment">//如果state&gt;0，那么递减state。若更新后的state=0则返回true，释放同步状态成功；反之，返回false。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;由Sync源码可以看出，CountDownLatch基于AQS的共享式获取和释放同步状态的机制实现。</p><p>&emsp;接下来看一下await()方法，当线程调用 await 方法后，当前线程会被阻塞，下面的情况之一发生才返回：</p><ul><li>计数器减为0</li><li>其它线程调用当前线程的 interrupt 方法中断当前线程，当前线程抛出 InterruptedException 异常，然后返回<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用AQS提供的共享式可中断获取同步状态方法。</span></span><br><span class="line"><span class="comment">//若获取成功（state=0），继续执行后续代码；否则（state&gt;0）,阻塞当前线程。</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    sync.acquireSharedInterruptibly(<span class="number">1</span>);    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireSharedInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="comment">//响应中断</span></span><br><span class="line">        <span class="comment">//如果线程被中断则抛出异常</span></span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">        <span class="comment">//判断计数器是否为0，为0则直接返回，否则进入AQS的队列等待    </span></span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="comment">//阻塞，进入队列等待</span></span><br><span class="line">            doAcquireSharedInterruptibly(arg);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">tryAcquireShared</span><span class="params">(<span class="keyword">int</span> acquires)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> (getState() == <span class="number">0</span>) ? <span class="number">1</span> : -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>&emsp;await(long timeout, TimeUnit unit)方法和await方法类似，差别是设置的超时时间到了，会超时返回false。</li></ul><p>&emsp;接下来看一下 countDown 方法，线程调用该方法，计数器的值递减，递减之后如果计数器值为0则唤醒所有因调用await方法而被阻塞的线程，否则什么都不做：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">countDown</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        sync.releaseShared(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//计数器减1</span></span><br><span class="line">        <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">            <span class="comment">//AQS释放资源</span></span><br><span class="line">            doReleaseShared();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryReleaseShared</span><span class="params">(<span class="keyword">int</span> releases)</span> </span>&#123;</span><br><span class="line">            <span class="comment">// Decrement count; signal when transition to zero</span></span><br><span class="line">            <span class="comment">//如果state=0，那么直接返回false</span></span><br><span class="line">            <span class="comment">//如果state&gt;0，那么递减state。若更新后的state=0则返回true，释放同步状态成功；反之，返回false。</span></span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">int</span> c = getState();</span><br><span class="line">                <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">int</span> nextc = c-<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (compareAndSetState(c, nextc))</span><br><span class="line">                    <span class="keyword">return</span> nextc == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;如果当前状态值为0，则直接返回false，否则使用CAS循环重试将计数值减1，之后该需要唤醒因调用await方法而被阻塞的线程，具体在AQS的doReleaseShared方法中实现。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>&emsp;CountDownLatch 是使用 AQS 实现的，使用 AQS 的状态变量来存放计数器的值。首先在初始化 CountDownLatch 时设置状态值（计数器值），当多个线程调用 countdown 方法时实际是原子性递减 AQS 的状态值。当线程调用 await 方法后当前线程会被放入 AQS 的阻塞队列待计数器为0后被唤醒返回。其它线程调用 countdown 方法让计数器值递减1，当计数器值变为0时，当前线程还要调用 AQS 的 doReleaseShared 方法来激活由于调用 await 方法而被阻塞的线程。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.cnblogs.com/zaizhoumo/p/7786893.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaizhoumo/p/7786893.html</a><br>《Java 并发编程之美》</p></blockquote><hr><p>相关推荐：<br>Java 并发包中线程同步器系列：</p><ul><li><a href="http://zhoujiapeng.top/java/java-CountDownLatch">《Java 线程同步器 之 CountDownLatch 原理剖析》</a></li><li><a href="http://zhoujiapeng.top/java/java-CyclicBarrier">《Java 线程同步器 之 CyclicBarrier 原理剖析》</a></li><li><a href="http://zhoujiapeng.top/java/java-Semaphore">《Java 线程同步器 之 Semaphore 原理剖析》</a></li></ul><p>&emsp;使用同步器有助于我们大大减少在Java中使用wait、noify等来实现线程同步的代码量，在日常开发中需要进行线程同步时使用这些同步类会节省很多代码并且保证正确性。</p>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 之 synchronized 的实现原理</title>
      <link href="/java/java-synchronized/"/>
      <url>/java/java-synchronized/</url>
      
        <content type="html"><![CDATA[<h1 id="synchronized-的实现原理"><a href="#synchronized-的实现原理" class="headerlink" title="synchronized 的实现原理"></a>synchronized 的实现原理</h1><h2 id="synchronized-常见三种使用方法："><a href="#synchronized-常见三种使用方法：" class="headerlink" title="synchronized 常见三种使用方法：　"></a>synchronized 常见三种使用方法：　</h2><ul><li>1）普通同步方法，锁是当前实例，即对象锁；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>2）静态同步方法，锁是当前类的Class实例，Class数据存在永久代中，是该类的一个全局锁，即类锁；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">increase</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    i++;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>3）对于同步代码块，锁是synchronized括号里配置的对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (a) &#123;</span><br><span class="line">        System.out.println(<span class="string">"..."</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><p>Java中的每个对象都可以作为锁。当一个线程访问同步代码块时，需要首先获取锁，退出代码块或抛出异常时必须释放锁。</p><h2 id="“锁”到底是什么？"><a href="#“锁”到底是什么？" class="headerlink" title="“锁”到底是什么？"></a>“锁”到底是什么？</h2><p>首先通过源代码和反汇编代码研究锁的实现原理。</p><p><strong>1）同步代码块源代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedBlock</span> </span>&#123;</span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">method</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">                    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                System.out.println(<span class="string">"..."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><br>字节码（javap -c）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedBlock &#123;</span><br><span class="line">  </span><br><span class="line">              &#x2F;&#x2F; Method descriptor #6 ()V</span><br><span class="line">              &#x2F;&#x2F; Stack: 1, Locals: 1</span><br><span class="line">              public SynchronizedBlock();</span><br><span class="line"> aload_0 [this]</span><br><span class="line"> invokespecial java.lang.Object() [8]</span><br><span class="line"> return</span><br><span class="line">                  Line numbers:</span><br><span class="line">                [pc: 0, line: 5]</span><br><span class="line">                  Local variable table:</span><br><span class="line">                [pc: 0, pc: 5] local: this index: 0 type: SynchronizedBlock</span><br><span class="line">              </span><br><span class="line">              &#x2F;&#x2F; Method descriptor #6 ()V</span><br><span class="line">              &#x2F;&#x2F; Stack: 2, Locals: 2</span><br><span class="line">              public void method();</span><br><span class="line"> aload_0 [this]</span><br><span class="line"> dup</span><br><span class="line"> astore_1</span><br><span class="line"> monitorenter    &#x2F;&#x2F;在同步块开始位置插入monitorenter指令</span><br><span class="line"> getstatic java.lang.System.out : java.io.PrintStream [15]</span><br><span class="line"> ldc &lt;String &quot;...&quot;&gt; [21]</span><br><span class="line"> invokevirtual java.io.PrintStream.println(java.lang.String) : void [23]</span><br><span class="line"> aload_1</span><br><span class="line"> monitorexit    &#x2F;&#x2F;在同步块结束位置插入</span><br><span class="line"> goto 20</span><br><span class="line"> aload_1</span><br><span class="line"> monitorexit    &#x2F;&#x2F;在抛出异常位置释放锁</span><br><span class="line"> athrow        &#x2F;&#x2F;抛出异常指令</span><br><span class="line"> getstatic java.lang.System.out : java.io.PrintStream [15]</span><br><span class="line"> ldc &lt;String &quot;...&quot;&gt; [21]</span><br><span class="line"> invokevirtual java.io.PrintStream.println(java.lang.String) : void [23]</span><br><span class="line"> return</span><br><span class="line">                  Exception Table:</span><br><span class="line">                [pc: 4, pc: 14] -&gt; 17 when : any</span><br><span class="line">                [pc: 17, pc: 19] -&gt; 17 when : any</span><br><span class="line">                  Line numbers:</span><br><span class="line">                [pc: 0, line: 7]</span><br><span class="line">                [pc: 4, line: 8]</span><br><span class="line">                [pc: 12, line: 7]</span><br><span class="line">                [pc: 20, line: 10]</span><br><span class="line">                [pc: 28, line: 11]</span><br><span class="line">                  Local variable table:</span><br><span class="line">                [pc: 0, pc: 29] local: this index: 0 type: SynchronizedBlock</span><br><span class="line">                  Stack map table: number of frames 2</span><br><span class="line">                [pc: 17, full, stack: &#123;java.lang.Throwable&#125;, locals: &#123;SynchronizedBlock, SynchronizedBlock&#125;]</span><br><span class="line">                [pc: 20, chop 1 local(s)]</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></p><p><strong>2）同步方法源代码：</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SynchronizedMethod</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//普通同步方法</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">method1</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="comment">//静态同步方法</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">method2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    System.out.println(<span class="string">"..."</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br></pre></td></tr></table></figure><br>字节码（javap -v）：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line">public class SynchronizedMethod</span><br><span class="line">              SourceFile: &quot;SynchronizedMethod.java&quot;</span><br><span class="line">              minor version: 0</span><br><span class="line">              major version: 51</span><br><span class="line">              flags: ACC_PUBLIC, ACC_SUPER</span><br><span class="line">            Constant pool:</span><br><span class="line">               #1 &#x3D; Class              #2             &#x2F;&#x2F;  SynchronizedMethod</span><br><span class="line">               #2 &#x3D; Utf8               SynchronizedMethod</span><br><span class="line">               #3 &#x3D; Class              #4             &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object</span><br><span class="line">               #4 &#x3D; Utf8               java&#x2F;lang&#x2F;Object</span><br><span class="line">               #5 &#x3D; Utf8               &lt;init&gt;</span><br><span class="line">               #6 &#x3D; Utf8               ()V</span><br><span class="line">               #7 &#x3D; Utf8               Code</span><br><span class="line">               #8 &#x3D; Methodref          #3.#9          &#x2F;&#x2F;  java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">               #9 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F;  &quot;&lt;init&gt;&quot;:()V</span><br><span class="line">              #10 &#x3D; Utf8               LineNumberTable</span><br><span class="line">              #11 &#x3D; Utf8               LocalVariableTable</span><br><span class="line">              #12 &#x3D; Utf8               this</span><br><span class="line">              #13 &#x3D; Utf8               LSynchronizedMethod;</span><br><span class="line">              #14 &#x3D; Utf8               method1</span><br><span class="line">              #15 &#x3D; Fieldref           #16.#18        &#x2F;&#x2F;  java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">              #16 &#x3D; Class              #17            &#x2F;&#x2F;  java&#x2F;lang&#x2F;System</span><br><span class="line">              #17 &#x3D; Utf8               java&#x2F;lang&#x2F;System</span><br><span class="line">              #18 &#x3D; NameAndType        #19:#20        &#x2F;&#x2F;  out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">              #19 &#x3D; Utf8               out</span><br><span class="line">              #20 &#x3D; Utf8               Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">              #21 &#x3D; String             #22            &#x2F;&#x2F;  ...</span><br><span class="line">              #22 &#x3D; Utf8               ...</span><br><span class="line">              #23 &#x3D; Methodref          #24.#26        &#x2F;&#x2F;  java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">              #24 &#x3D; Class              #25            &#x2F;&#x2F;  java&#x2F;io&#x2F;PrintStream</span><br><span class="line">              #25 &#x3D; Utf8               java&#x2F;io&#x2F;PrintStream</span><br><span class="line">              #26 &#x3D; NameAndType        #27:#28        &#x2F;&#x2F;  println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">              #27 &#x3D; Utf8               println</span><br><span class="line">              #28 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">              #29 &#x3D; Utf8               method2</span><br><span class="line">              #30 &#x3D; Utf8               SourceFile</span><br><span class="line">              #31 &#x3D; Utf8               SynchronizedMethod.java</span><br><span class="line">            &#123;</span><br><span class="line">              public SynchronizedMethod();</span><br><span class="line">                flags: ACC_PUBLIC</span><br><span class="line">                Code:</span><br><span class="line">                  stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">                 0: aload_0       </span><br><span class="line">                 1: invokespecial #8                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">                 4: return        </span><br><span class="line">                  LineNumberTable:</span><br><span class="line">                line 3: 0</span><br><span class="line">                  LocalVariableTable:</span><br><span class="line">                Start  Length  Slot  Name   Signature</span><br><span class="line">      5     0  this   LSynchronizedMethod;</span><br><span class="line"></span><br><span class="line">              public synchronized void method1();</span><br><span class="line">                flags: ACC_PUBLIC, ACC_SYNCHRONIZED        &#x2F;&#x2F;同步方法增加了ACC_SYNCHRONIZED标志</span><br><span class="line">                Code:</span><br><span class="line">                  stack&#x3D;2, locals&#x3D;1, args_size&#x3D;1</span><br><span class="line">                 0: getstatic     #15                 &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">                 3: ldc           #21                 &#x2F;&#x2F; String ...</span><br><span class="line">                 5: invokevirtual #23                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">                 8: return        </span><br><span class="line">                  LineNumberTable:</span><br><span class="line">                line 6: 0</span><br><span class="line">                line 7: 8</span><br><span class="line">                  LocalVariableTable:</span><br><span class="line">                Start  Length  Slot  Name   Signature</span><br><span class="line">      9     0  this   LSynchronizedMethod;</span><br><span class="line"></span><br><span class="line">              public static synchronized void method2();</span><br><span class="line">                flags: ACC_PUBLIC, ACC_STATIC, ACC_SYNCHRONIZED</span><br><span class="line">                Code:</span><br><span class="line">                  stack&#x3D;2, locals&#x3D;0, args_size&#x3D;0</span><br><span class="line">                 0: getstatic     #15                 &#x2F;&#x2F; Field java&#x2F;lang&#x2F;System.out:Ljava&#x2F;io&#x2F;PrintStream;</span><br><span class="line">                 3: ldc           #21                 &#x2F;&#x2F; String ...</span><br><span class="line">                 5: invokevirtual #23                 &#x2F;&#x2F; Method java&#x2F;io&#x2F;PrintStream.println:(Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">                 8: return        </span><br><span class="line">                  LineNumberTable:</span><br><span class="line">                line 10: 0</span><br><span class="line">                line 11: 8</span><br><span class="line">                  LocalVariableTable:</span><br><span class="line">                Start  Length  Slot  Name   Signature</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure><br>&emsp;通过反汇编代码可以观察到：<br>&emsp;同步代码块是使用 <strong>MonitorEnter</strong> 和 <strong>MoniterExit</strong> 指令实现的，在编译时，MonitorEnter指令被插入到同步代码块的开始位置，MoniterExit指令被插入到同步代码块的结束位置和异常位置。任何对象都有一个Monitor与之关联，当Monitor被持有后将处于锁定状态。MonitorEnter指令会尝试获取Monitor的持有权，即尝试获取锁。<br>&emsp;同步方法依赖flags标志 <strong>ACC_SYNCHRONIZED</strong> 实现，字节码中没有具体的逻辑，可能需要查看JVM的底层实现（同步方法也可以通过Monitor指令实现）。ACC_SYNCHRONIZED标志表示方法为同步方法，如果为非静态方法（没有 <strong>ACC_STATIC</strong> 标志），使用调用该方法的对象作为锁对象；如果为静态方法（有ACC_STATIC标志），使用该方法所属的Class类在JVM的内部对象表示Klass作为锁对象。</p><p>&emsp;下面是摘自《Java虚拟机规范》的话：<br>&emsp;<em>Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程（Monitor）来支持的。</em><br>&emsp;<em>方法级的同步是隐式，即无需通过字节码指令来控制的，它实现在方法调用和返回操作之中。虚拟机可以从方法常量池中的方法表结构中的ACC_SYNCHRONIZED访问标志区分一个方法是否同步方法。当方法调用时，调用指令将会检查方法的ACC_SYNCHRONIZED访问标志是否被设置，如果设置了，执行线程将先持有管程，然后再执行方法，最后在方法完成（无论是正常完成还是非正常完成）时释放管程。在方法执行期间，执行线程持有了管程，其他任何线程都无法再获得同一个管程。如果一个同步方法执行期间抛出了异常，并且在方法内部无法处理此异常，那这个同步方法所持有的管程将在异常抛到同步方法之外时自动释放。</em><br>&emsp;<em>同步一段指令集序列通常是由Java语言中的synchronized块来表示的，Java虚拟机的指令集中有monitorenter和monitorexit两条指令来支持synchronized关键字的语义，正确实现synchronized关键字需要编译器与Java虚拟机两者协作支持。</em><br>&emsp;<em>Java虚拟机中的同步（Synchronization）基于进入和退出管程（Monitor）对象实现。无论是显式同步（有明确的monitorenter和monitorexit指令）还是隐式同步（依赖方法调用和返回指令实现的）都是如此。</em><br>&emsp;<em>编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须有执行其对应monitorexit指令，而无论这个方法是正常结束还是异常结束。为了保证在方法异常完成时monitorenter和monitorexit指令依然可以正确配对执行，编译器会自动产生一个异常处理器，这个异常处理器声明可处理所有的异常，它的目的就是用来执行monitorexit指令。</em></p><h2 id="Monitor-到底是什么？"><a href="#Monitor-到底是什么？" class="headerlink" title="Monitor 到底是什么？"></a>Monitor 到底是什么？</h2><p>&emsp;那Monitor到底是什么？一个作为锁的对象是什么样的工作机制？（Java对象头和Monitor）</p><h3 id="Java对象头"><a href="#Java对象头" class="headerlink" title="Java对象头"></a>Java对象头</h3><p>&emsp;对象头含有三部分：Mark Word（存储对象自身运行时数据）、Class Metadata Address（存储类元数据的指针）、Array length（数组长度，只有数组类型才有）。<br>&emsp;重点在Mark Word部分，Mark Word数据结构被设计成非固定的，会随着对象的不同状态而变化，如下表所示。<br><style type="text/css">.tg  {border-collapse:collapse;border-spacing:0;}.tg td{font-family:Arial, sans-serif;font-size:14px;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg th{font-family:Arial, sans-serif;font-size:14px;font-weight:normal;padding:10px 5px;border-style:solid;border-width:1px;overflow:hidden;word-break:normal;border-color:black;}.tg .tg-c3ow{border-color:inherit;text-align:center;vertical-align:top}</style><table class="tg">  <tr>    <th class="tg-c3ow">锁状态</th>    <th class="tg-c3ow">25bit</th>    <th class="tg-c3ow">25bit</th>    <th class="tg-c3ow">4bit</th>    <th class="tg-c3ow">1bit是否是偏向锁</th>    <th class="tg-c3ow">2bit锁标志位</th>  </tr>  <tr>    <td class="tg-c3ow">无锁状态</td>    <td class="tg-c3ow">hashCode</td>    <td class="tg-c3ow">hashCode</td>    <td class="tg-c3ow">age</td>    <td class="tg-c3ow">0</td>    <td class="tg-c3ow">01</td>  </tr>  <tr>    <td class="tg-c3ow">轻量级锁</td>    <td class="tg-c3ow" colspan="4">执行栈中锁记录的指针</td>    <td class="tg-c3ow">00</td>  </tr>  <tr>    <td class="tg-c3ow">重量级锁</td>    <td class="tg-c3ow" colspan="4">执行栈中锁记录的指针</td>    <td class="tg-c3ow">10</td>  </tr>  <tr>    <td class="tg-c3ow">GC标记</td>    <td class="tg-c3ow" colspan="4">空</td>    <td class="tg-c3ow">11</td>  </tr>  <tr>    <td class="tg-c3ow">偏向锁</td>    <td class="tg-c3ow">线程ID</td>    <td class="tg-c3ow">Epoch</td>    <td class="tg-c3ow">age</td>    <td class="tg-c3ow">1</td>    <td class="tg-c3ow">01</td>  </tr></table></p><p>&emsp;锁的级别从低到高：无锁、偏向锁、轻量级锁、重量级锁。</p><h3 id="Monitor"><a href="#Monitor" class="headerlink" title="Monitor"></a>Monitor</h3><p>&emsp;Monitor可以理解为一种同步工具，也可理解为一种同步机制，常常被描述为一个Java对象。</p><ul><li>1）互斥：一个Monitor在一个时刻只能被一个线程持有，即Monitor中的所有方法都是互斥的。</li><li>2）signal机制：如果条件变量不满足，允许一个正在持有Monitor的线程暂时释放持有权，当条件变量满足时，当前线程可以唤醒正在等待该条件变量的线程，然后重新获取Monitor的持有权。</li></ul><p>&emsp;所有的Java对象是天生的Monitor，每一个Java对象都有成为Monitor的潜质，因为在Java的设计中 ，每一个Java对象自打娘胎里出来就带了一把看不见的锁，它叫做内部锁或者<strong>Monitor锁</strong>。<br>&emsp;<strong>Monitor的本质是依赖于底层操作系统的Mutex Lock实现，操作系统实现线程之间的切换需要从用户态到内核态的转换，成本非常高。</strong></p><p>　　</p><h3 id="JDK1-6对锁的优化"><a href="#JDK1-6对锁的优化" class="headerlink" title="JDK1.6对锁的优化"></a>JDK1.6对锁的优化</h3><ul><li><p>重量级锁<br>重量级锁基于Monitor实现，成本高。</p></li><li><p>轻量级锁</p><ul><li>优化点：在没有多线程竞争的情况下，通过CAS减少重量级锁使用操作系统互斥量产生的性能消耗。</li><li>什么情况下使用：关闭偏向锁或由于多线程竞争导致的偏向锁升级为轻量级锁。</li><li><p>获取锁步骤：</p><ul><li>1）判断是否处于无锁状态，若是，则JVM在当前线程的栈帧中创建锁记录（Lock Record）空间，用于存放锁对象中的Mark Word的拷贝，官方称为Displaced Mark Word；否则执行步骤3）。</li><li>2）当前线程尝试利用CAS将锁对象的Mark Word更新为指向锁记录的指针。如果更新成功意味着获取到锁，将锁标志位置为00，执行同步代码块；如果更新失败，执行步骤3）。</li><li>3）判断锁对象的Mark Word是否指向当前线程的栈帧，若是说明当前线程已经获取了锁，执行同步代码，否则说明其他线程已经获取了该锁对象，执行步骤4）。</li><li>4）当前线程尝试使用自旋来获取锁，自旋期间会不断的执行步骤1），直到获取到锁或自旋结束。因为自旋锁会消耗CPU，所以不能无限的自旋。如果自旋期间获取到锁（其他线程释放锁），执行同步块；否则锁膨胀为重量级锁，当前线程阻塞，等待持有锁的线程释放锁时的唤醒。</li></ul></li><li><p>释放锁步骤：</p><ul><li>1）从当前线程的栈帧中取出Displaced Mark Word存储的锁记录的内容。</li><li>2）当前线程尝试使用CAS将锁记录内容更新到锁对象中的Mark Word中。如果更新成功，则释放锁成功，将锁标志位置为01无锁状态；否则，执行3）。</li><li>3）CAS更新失败，说明有其他线程尝试获取锁。需要释放锁并同时唤醒等待的线程。</li></ul></li></ul></li><li><p>偏向锁</p><ul><li>优化点：在没有多线程竞争的情况下，减少轻量级锁的不必要的CAS操作。在无竞争情况下，完全消除同步。</li><li>优化方法：锁对象的Mark Word中记录获取锁的线程ID。</li><li>获取锁步骤：<ul><li>1）判断锁对象是否是偏向锁（即锁标志位为01，偏向锁位为1），若为偏向锁状态执行2）。</li><li>2）判断锁对象的线程ID是否为当前线程的ID，如果是则说明已经获取到锁，执行代码块；否则执行3）。</li><li>3）当前线程使用CAS更新锁对象的线程ID为当前线程ID。如果成功，获取到锁；否则执行4）</li><li>4）当到达全局安全点，当前线程根据Mark Word中的线程ID通知持有锁的线程挂起，将锁对象Mark Word中的锁对象指针指向当前堆栈中最近的一个锁记录，偏向锁升级为轻量级锁，恢复被挂起的线程。</li></ul></li><li>释放锁步骤：偏向锁采用一种等到竞争出现时才释放锁的机制。当其他线程尝试竞争偏向锁时，当前线程才会释放释放锁，线程不会主动去释放偏向锁。偏向锁的撤销需要等待全局安全点。<ul><li>1）首先暂停持有偏向锁的线程。</li><li>2）撤销偏向锁，恢复到无锁状态或轻量级锁状态。</li></ul></li></ul></li></ul><h3 id="几种锁的对比"><a href="#几种锁的对比" class="headerlink" title="几种锁的对比"></a>几种锁的对比</h3><div class="table-container"><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">优点</th><th style="text-align:center">缺点</th><th style="text-align:center">适用情况</th></tr></thead><tbody><tr><td style="text-align:center">偏向锁</td><td style="text-align:center">加锁和解锁不需要额外的消耗，和执行非同步代码相差无几。</td><td style="text-align:center">如果线程存在锁竞争，需要额外的锁撤销的消耗。</td><td style="text-align:center">适用于只有一个线程访问同步块的情况</td></tr><tr><td style="text-align:center">轻量级锁</td><td style="text-align:center">竞争的线程不会阻塞，提高了响应速度</td><td style="text-align:center">长时间得不到锁的线程使用自旋消耗CPU</td><td style="text-align:center">追求响应速度。同步代码执行非常快</td></tr><tr><td style="text-align:center">重量级锁</td><td style="text-align:center">线程竞争不会使用自旋，不会消耗CPU</td><td style="text-align:center">线程出现竞争时会阻塞，响应速度慢</td><td style="text-align:center">追求吞吐量。同步代码执行时间长</td></tr></tbody></table></div><h2 id="synchronized-的一些理解"><a href="#synchronized-的一些理解" class="headerlink" title="synchronized 的一些理解"></a>synchronized 的一些理解</h2><ol><li><p>相对于ReentrantLock而言，synchronized锁是<strong>重量级锁</strong>，重量级体现在活跃性差一点。synchronized锁是内置锁，意味着JVM能基于synchronized锁做一些优化：比如增加锁的粒度(锁粗化)、锁消除。</p></li><li><p>在synchronized锁上阻塞的线程是不可中断的：线程A获得了synchronized锁，当线程B也去获取synchronized锁时会被阻塞。而且，线程B无法被其他线程中断(不可中断的阻塞)，而ReentrantLock锁能实现可中断的阻塞。</p></li><li><p>synchronized锁释放是自动的，当线程执行退出synchronized锁保护的同步代码块时，会自动释放synchronized锁。而ReentrantLock需要显示地释放：即在try-finally块中释放锁。</p></li><li><p>线程在竞争synchronized锁时是非公平的：假设synchronized锁目前被线程A占有，线程B请求锁未果，被放入队列中，线程C请求锁未果，也被 放入队列中，线程D也来请求锁，恰好此时线程A将锁释放了，那么线程D将跳过队列中所有的等待线程(即：线程B和线程C)并获得这个锁。而ReentrantLock能够实现锁的公平性。</p></li><li><p>synchronized锁是读写互斥并且 读读也互斥，ReentrantReadWriteLock 分为读锁和写锁，而读锁可以同时被多个线程持有，适合于读多写少场景的并发。<br>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.cnblogs.com/zaizhoumo/p/7700161.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaizhoumo/p/7700161.html</a><br><a href="https://www.cnblogs.com/hapjin/p/4678773.html" target="_blank" rel="noopener">https://www.cnblogs.com/hapjin/p/4678773.html</a></p></blockquote></li></ol>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 中表格单元格合并的问题</title>
      <link href="/markdown/markdown-table/"/>
      <url>/markdown/markdown-table/</url>
      
        <content type="html"><![CDATA[<h1 id="markdown-中表格单元格合并的问题"><a href="#markdown-中表格单元格合并的问题" class="headerlink" title="markdown 中表格单元格合并的问题"></a>markdown 中表格单元格合并的问题</h1><p>我们知道，在markdown中实现表格是很简单的事情：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">|项目1|项目2|项目3|</span><br><span class="line">|---|---|---|</span><br><span class="line">|a1|a1|a3|</span><br><span class="line">|b1|b2|b3|</span><br><span class="line">|b1|c2|c3|</span><br></pre></td></tr></table></figure><br>效果如下：<br>|项目1|项目2|项目3|<br>|—-|—-|—-|<br>|a1|a1|a3|<br>|b1|b2|b3|<br>|b1|c2|c3|</p><p>但是如果我们要将上表中的相同文字单元格进行合并，如a1与a1横向合并，b1与b1纵向合并，单纯的markdown语法是不能实现的。由于markdown支持html，我们可以通过表格在html中的table进行实现。<br>这个网站可以帮助我们自动生成需要的表格的html代码</p><p><a href="http://www.tablesgenerator.com/" target="_blank" rel="noopener">http://www.tablesgenerator.com/</a></p><p>需要注意的一点是，在markdown中使用html代码来实现表格的效果，需要在表格的外面套上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;escape&gt;&lt;&#x2F;escape&gt;</span><br></pre></td></tr></table></figure><br>（转义），防止markdown直接将代码中的行进行转义成回车，不然会出现表格前空了一大块空白。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&lt;escape&gt;</span><br><span class="line">&lt;table&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;th&gt;项目1&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;th&gt;项目2&lt;&#x2F;th&gt;</span><br><span class="line">    &lt;th&gt;项目3&lt;&#x2F;th&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;a1&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td colspan&#x3D;&quot;2&quot;&gt;a2&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td rowspan&#x3D;&quot;2&quot;&gt;b1&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;b2&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;b3&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">  &lt;tr&gt;</span><br><span class="line">    &lt;td&gt;c2&lt;&#x2F;td&gt;</span><br><span class="line">    &lt;td&gt;c3&lt;&#x2F;td&gt;</span><br><span class="line">  &lt;&#x2F;tr&gt;</span><br><span class="line">&lt;&#x2F;table&gt;</span><br><span class="line">&lt;&#x2F;escape&gt;</span><br></pre></td></tr></table></figure><p>效果：<br><table>  <tr>    <th>项目1</th>    <th>项目2</th>    <th>项目3</th>  </tr>  <tr>    <td>a1</td>    <td colspan="2">a2</td>  </tr>  <tr>    <td rowspan="2">b1</td>    <td>b2</td>    <td>b3</td>  </tr>  <tr>    <td>c2</td>    <td>c3</td>  </tr></table></p><p>但同时，引入html会使得markdown的易读易写的特性降低。除非必要，还是推荐使用markdown本身的表格语法。</p>]]></content>
      
      
      <categories>
          
          <category> markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发容器 之 BlockingQueue</title>
      <link href="/java/java-blockingQueue/"/>
      <url>/java/java-blockingQueue/</url>
      
        <content type="html"><![CDATA[<h1 id="BlockingQueue-详解"><a href="#BlockingQueue-详解" class="headerlink" title="BlockingQueue 详解"></a>BlockingQueue 详解</h1><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;BlockingQueue是支持两个附加操作的Queue：</p><ul><li>1）当Queue为空时，获取元素线程被阻塞直到Queue变为非空；</li><li>2）当Queue满时，添加元素线程被阻塞直到Queue不满。</li></ul><p>BlockingQueue不允许元素为null，如果入队一个null元素，会抛NullPointerException。常用于生产者消费者模式。<br>BlockingQueue对于不能满足条件的操作，提供了四种处理方式：</p><ul><li>1）直接抛异常，抛出异常。如果队列已满，添加元素会抛出IllegalStateException异常；如果队列为空，获取元素会抛出NoSuchElementException异常；</li><li>2）返回一个特殊值（null或false）；</li><li>3）在满足条件之前，无限期的阻塞当前线程，当队列满足条件或响应中断退出；</li><li>4）在有限时间内阻塞当前线程，超时后返回失败。</li></ul><div class="table-container"><table><thead><tr><th></th><th>抛出异常</th><th>返回特殊值</th><th>阻塞</th><th>超时</th></tr></thead><tbody><tr><td>入队</td><td>add(e)</td><td>offer(e)</td><td>put(e)</td><td>offer(e, time, unit)</td></tr><tr><td>出队</td><td>remove()</td><td>poll()</td><td>take()</td><td>poll(time, unit)</td></tr><tr><td>检查</td><td>element()</td><td>peek()</td><td></td><td></td></tr></tbody></table></div><p>JDK提供的阻塞队列：</p><ul><li>ArrayBlockingQueue：一个由数组结构组成的有界阻塞队列，遵循FIFO原则。</li><li>LinkedBlockingQueue：一个由链表结构组成的有界阻塞队列，遵循FIFO原则，默认和最大长度为Integer.MAX_VALUE。</li><li>PriorityBlockingQueue：一个支持优先级排序的无界阻塞队列。</li><li>DelayQueue：一个使用优先级队列实现的无界阻塞队列。</li><li>SynchronousQueue：一个不存储元素的阻塞队列。</li><li>LinkedTransferQueue：一个由链表结构组成的无界阻塞队列。</li><li>LinkedBlockingDeque：一个由链表结构组成的双向阻塞队列。</li></ul><h2 id="2-使用"><a href="#2-使用" class="headerlink" title="2. 使用"></a>2. 使用</h2><p>　　示例：生产者-消费者，BlockingQueue 可以安全地与多个生产者和多个使用者一起使用。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</span><br><span class="line">    Producer(BlockingQueue q) &#123; queue = q; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; queue.put(produce()); &#125;    <span class="comment">//当队列满时，生产者阻塞等待</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Object <span class="title">produce</span><span class="params">()</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//消费者</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> BlockingQueue queue;</span><br><span class="line">    Consumer(BlockingQueue q) &#123; queue = q; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="keyword">true</span>) &#123; consume(queue.take()); &#125;    <span class="comment">//当队列空时，消费者阻塞等待</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (InterruptedException ex) &#123; ... handle ...&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">consume</span><span class="params">(Object x)</span> </span>&#123; ... &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Setup</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        BlockingQueue q = <span class="keyword">new</span> SomeQueueImplementation();</span><br><span class="line">        Producer p = <span class="keyword">new</span> Producer(q);</span><br><span class="line">        Consumer c1 = <span class="keyword">new</span> Consumer(q);</span><br><span class="line">        Consumer c2 = <span class="keyword">new</span> Consumer(q);</span><br><span class="line">        <span class="keyword">new</span> Thread(p).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(c1).start();</span><br><span class="line">        <span class="keyword">new</span> Thread(c2).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-实现原理"><a href="#3-实现原理" class="headerlink" title="3. 实现原理"></a>3. 实现原理</h2><p>&emsp;当队列满时，生产者会一直阻塞，当消费者从队列中取出元素时，如何通知生产者队列可以继续，以ArrayBlockingQueue和LinkedBlockingQueue为例，分析源代码如何实现阻塞队列。它们的阻塞机制都是基于Lock和Condition实现，其中LinkedBlockingQueue还用到了原子变量类。</p><h3 id="3-1-ArrayBlockingQueue"><a href="#3-1-ArrayBlockingQueue" class="headerlink" title="3.1 ArrayBlockingQueue"></a>3.1 ArrayBlockingQueue</h3><p>&emsp;基于数组的<strong>有界</strong>阻塞队列。队列按FIFO原则对元素进行排序，队列头部是在队列中存活时间最长的元素，队尾则是存在时间最短的元素。新元素插入到队列的尾部，队列获取操作则是从队列头部开始获得元素。 这是一个典型的“有界缓存区”，固定大小的数组在其中保持生产者插入的元素和使用者提取的元素。一旦创建了这样的缓存区，就不能再增加其容量。试图向已满队列中放入元素会导致操作受阻塞；试图从空队列中提取元素将导致类似阻塞。ArrayBlockingQueue构造方法可通过设置fairness参数来选择是否采用公平策略，公平性通常会降低吞吐量，但也减少了可变性和避免了“不平衡性”，可根据情况来决策。</p><p>域：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The queued items */</span></span><br><span class="line"><span class="keyword">final</span> Object[] items;</span><br><span class="line"><span class="comment">/** items index for next take, poll, peek or remove */</span></span><br><span class="line"><span class="keyword">int</span> takeIndex;</span><br><span class="line"><span class="comment">/** items index for next put, offer, or add */</span></span><br><span class="line"><span class="keyword">int</span> putIndex;</span><br><span class="line"><span class="comment">/** Number of elements in the queue */</span></span><br><span class="line"><span class="keyword">int</span> count;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Concurrency control uses the classic two-condition algorithm</span></span><br><span class="line"><span class="comment"> * found in any textbook.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/** Main lock guarding all access */</span></span><br><span class="line"><span class="keyword">final</span> ReentrantLock lock;</span><br><span class="line"><span class="comment">/** Condition for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty;</span><br><span class="line"><span class="comment">/** Condition for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull;</span><br></pre></td></tr></table></figure><br>&emsp;由ArrayBlockingQueue的域可以看出，使用循环数组存储队列中的元素，两个索引takeIndex和putIndex分别指向下一个要出队和入队的数组位置，线程间的通信是使用ReentrantLock和两个Condition实现的。</p><h4 id="3-1-1-put-e-amp-take-阻塞"><a href="#3-1-1-put-e-amp-take-阻塞" class="headerlink" title="3.1.1 put(e)&amp;take() 阻塞"></a>3.1.1 put(e)&amp;take() 阻塞</h4><p>&emsp;当不满足入队或出队条件时，当前线程阻塞等待。即当队列满时，生产者会一直阻塞直到被唤醒，当队列空时，消费者会一直阻塞直到被唤醒。</p><p><strong>入队（put）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在队列的尾部（当前putIndex指定的位置）插入指定的元素</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();    <span class="comment">//可响应中断获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length)    <span class="comment">//如果队列满，在入队条件notFull的等待队列上等待。</span></span><br><span class="line">                                        <span class="comment">//这里使用While循环而非if判断，目的是防止过早或意外的通知，只有条件符合才能推出循环</span></span><br><span class="line">            notFull.await();</span><br><span class="line">        insert(e);</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();    <span class="comment">//释放锁，唤醒同步队列中的后继节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//为保证操作线程安全，此方法必须在获取锁的前提下才能被调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">insert</span><span class="params">(E x)</span> </span>&#123;</span><br><span class="line">    items[putIndex] = x;</span><br><span class="line">    putIndex = inc(putIndex);</span><br><span class="line">    ++count;            <span class="comment">//元素数量+1</span></span><br><span class="line">    notEmpty.signal();    <span class="comment">//唤醒出队条件的等待队列上的线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将i增1，当++i等于数组的最大容量时，将i置为0。即通过循环数组的方式</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">int</span> <span class="title">inc</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (++i == items.length) ? <span class="number">0</span> : i;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;从源码可以看出，入队的大致步骤如下：</p><ul><li>1）首先获取锁，如果获取锁失败，当前线程可能自旋获取锁或被阻塞直到获取到锁，否则执行2）；</li><li>2）循环判断队列是否满，如果满，那么当前线程被阻塞到notFull条件的等待队列中，并释放锁，等待被唤醒；</li><li>3）当队列非满或从await方法中返回（此时当前线程从等待队列中被唤醒并重新获取到锁）时，执行插入元素操作。</li><li>4）入队完成后，释放锁，唤醒同步队列中的后继节点。</li></ul><p><strong>出队（take）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();    <span class="comment">//可响应中断获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>)    <span class="comment">//如果队列为空，在出队条件notEmpty的等待队列中等待</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();    <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在当前takeIndex指定的位置取出元素，此方法必须在获取锁的前提下才能被调用</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">extract</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Object[] items = <span class="keyword">this</span>.items;</span><br><span class="line">    E x = <span class="keyword">this</span>.&lt;E&gt;cast(items[takeIndex]);    <span class="comment">//强制类型转换</span></span><br><span class="line">    items[takeIndex] = <span class="keyword">null</span>;</span><br><span class="line">    takeIndex = inc(takeIndex);    <span class="comment">//出队索引同样采用循环的方式增1</span></span><br><span class="line">    --count;</span><br><span class="line">    notFull.signal();    <span class="comment">//唤醒入队条件的等待队列中的线程</span></span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;从源码可以看出，出队的大致步骤如下：</p><ul><li>1）首先获取锁，如果获取锁失败，当前线程可能自旋获取锁或被阻塞直到获取到锁成功。</li><li>2）获取锁成功，循环判断队列是否为空，如果为空，那么当前线程被阻塞到 notEmpty 条件的等待队列中，并释放锁，等待被唤醒；</li><li>3）当队列非空或从await方法中返回（此时当前线程从等待队列中被唤醒并重新获取到锁）时，执行取出元素操作。</li><li>4）出队完成后，释放锁，唤醒同步队列的后继节点，</li></ul><h4 id="3-1-2-offer-e-amp-poll-返回特殊值"><a href="#3-1-2-offer-e-amp-poll-返回特殊值" class="headerlink" title="3.1.2 offer(e)&amp;poll() 返回特殊值"></a>3.1.2 offer(e)&amp;poll() 返回特殊值</h4><p>&emsp;当不能满足入队或出队条件时，返回特殊值。当队列满时，入队会失败，offer方法直接返回false，反之入队成功，返回true；当队列空时，poll方法返回null。</p><p><strong>入队（offer）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (count == items.length)    <span class="comment">//如果队列满，与put阻塞当前线程不同的是，offer方法直接返回false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            insert(e);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();    <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>出队（poll）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//出队</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lock();    <span class="comment">//获取锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> (count == <span class="number">0</span>) ? <span class="keyword">null</span> : extract();    <span class="comment">//如果队列空，与take阻塞当前线程不同的是，poll方法返回null</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();    <span class="comment">//释放锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-1-3-add-e-amp-remove-抛异常"><a href="#3-1-3-add-e-amp-remove-抛异常" class="headerlink" title="3.1.3 add(e)&amp;remove() 抛异常"></a>3.1.3 add(e)&amp;remove() 抛异常</h4><p>&emsp;当不能满足入队或出队条件时，直接抛出异常。当队列满时，入队失败，抛IllegalStateException(“Queue full”)；当队列空时，remove方法抛NoSuchElementException()异常。</p><p><strong>入队（add）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.add(e);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象类AbstractQueue提供的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">add</span><span class="params">(E e)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//如果offer返回true，那么add方法返回true；如果offer返回false，那么add方法抛IllegalStateException("Queue full")异常</span></span><br><span class="line">    <span class="keyword">if</span> (offer(e))</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Queue full"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>出队（remove）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//抽象类AbstractQueue提供的方法</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">remove</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    E x = poll();</span><br><span class="line">    <span class="keyword">if</span> (x != <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> NoSuchElementException();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-1-4-offer-amp-poll-超时"><a href="#3-1-4-offer-amp-poll-超时" class="headerlink" title="3.1.4 offer&amp;poll 超时"></a>3.1.4 offer&amp;poll 超时</h4><p>&emsp;使用Condition的超时等待机制实现，当不满足条件时，只在有限的时间内阻塞，超过超时时间仍然不满足条件才返回false或null。</p><p><strong>入队</strong>（offer(E e, long timeout, TimeUnit unit)）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">offer</span><span class="params">(E e, <span class="keyword">long</span> timeout, TimeUnit unit)</span></span></span><br><span class="line"><span class="function">    <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line"></span><br><span class="line">    checkNotNull(e);</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);    <span class="comment">//转换为纳秒</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == items.length) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            nanos = notFull.awaitNanos(nanos);    <span class="comment">//与offer直接返回false不同，此处使用Condition的超时等待机制实现，超过等待时间如果仍然不满足条件才返回false</span></span><br><span class="line">        &#125;</span><br><span class="line">        insert(e);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>出队</strong>（poll(long timeout, TimeUnit unit)）<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">poll</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">long</span> nanos = unit.toNanos(timeout);</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock lock = <span class="keyword">this</span>.lock;</span><br><span class="line">    lock.lockInterruptibly();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nanos &lt;= <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            nanos = notEmpty.awaitNanos(nanos);    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> extract();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        lock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-2-LinkedBlockingQueue"><a href="#3-2-LinkedBlockingQueue" class="headerlink" title="3.2 LinkedBlockingQueue"></a>3.2 LinkedBlockingQueue</h3><p>&emsp;基于链表的无界(默认Integer.MAX_VALUE，也可自己指定容量)阻塞队列。与ArrayBlockingQueue一样采用FIFO原则对元素进行排序。基于链表的队列吞吐量通常要高于基于数组的队列。<br>&emsp;<strong>Executors</strong>创建固定大小线程池的代码，就使用了LinkedBlockingQueue来作为任务队列。</p><p>域<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** The capacity bound, or Integer.MAX_VALUE if none */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">int</span> capacity;    <span class="comment">//队列最大容量，默认为Integer.MAX_VALUE</span></span><br><span class="line"><span class="comment">/** Current number of elements */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger count = <span class="keyword">new</span> AtomicInteger(<span class="number">0</span>);    <span class="comment">//当前元素数量，原子类保证线程安全</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Head of linked list.</span></span><br><span class="line"><span class="comment"> * Invariant: head.item == null </span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; head;    <span class="comment">//队列的首节点，head节点是个空节点，head.item == null，实际存储元素的第一个节点是head.next</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Tail of linked list.</span></span><br><span class="line"><span class="comment"> * Invariant: last.next == null</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">transient</span> Node&lt;E&gt; last;    <span class="comment">//队列的尾节点</span></span><br><span class="line"><span class="comment">/** Lock held by take, poll, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//出队锁</span></span><br><span class="line"><span class="comment">/** Wait queue for waiting takes */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notEmpty = takeLock.newCondition();    <span class="comment">//出队条件</span></span><br><span class="line"><span class="comment">/** Lock held by put, offer, etc */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//入队锁</span></span><br><span class="line"><span class="comment">/** Wait queue for waiting puts */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Condition notFull = putLock.newCondition();    <span class="comment">//入队条件</span></span><br></pre></td></tr></table></figure></p><p>Node类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">E</span>&gt; </span>&#123;</span><br><span class="line">    E item;    <span class="comment">//元素</span></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * One of:</span></span><br><span class="line"><span class="comment">     * - the real successor Node</span></span><br><span class="line"><span class="comment">     * - this Node, meaning the successor is head.next</span></span><br><span class="line"><span class="comment">     * - null, meaning there is no successor (this is the last node)</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node&lt;E&gt; next;    <span class="comment">//后继节点，LinkedBlockingQueue使用的是单向链表</span></span><br><span class="line">    Node(E x) &#123; item = x; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;由LinkedBlockingQueue的域可以看出，它使用链表存储元素。线程间的通信也是使用ReentrantLock和Condition实现的，与ArrayBlockingQueue不同的是，LinkedBlockingQueue在入队和出队操作时分别使用两个锁putLock和takeLock。</p><ul><li>思考问题一：为什么使用两把锁？</li></ul><p>&emsp;为了提高并发度和吞吐量，使用两把锁，takeLock只负责出队，putLock只负责入队，入队和出队可以同时进行，提高入队和出队操作的效率，增大队列的吞吐量。LinkedBlockingQueue队列的吞吐量通常要高于ArrayBlockingQueue队列，但是在高并发条件下可预测性降低。</p><ul><li>思考问题二：ArrayBlockingQueue中的count是一个普通的int型变量，LinkedBlockingQueue的count为什么是AtomicInteger类型的？</li></ul><p>&emsp;因为ArrayBlockingQueue的入队和出队操作使用同一把锁，对count的修改都是在处于线程获取锁的情况下进行操作，因此不会有线程安全问题。而LinkedBlockingQueue的入队和出队操作使用的是不同的锁，会有对count变量并发修改的情况，所以使用原子变量保证线程安全。</p><ul><li>思考问题三：像notEmpty、takeLock、count域等都声明为final型，final成员变量有什么特点？</li></ul><p>&emsp;1）对于一个final变量，如果是基本数据类型的变量，则其数值一旦在初始化之后便不能更改；如果是引用类型的变量，则在对其初始化之后便不能再让其指向另一个对象。<br>&emsp;2）对于一个final成员变量，必须在定义时或者构造器中进行初始化赋值，而且final变量一旦被初始化赋值之后，就不能再被赋值了。只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指lock和volatile的使用）就可以保证任意线程都能看到这个final域在构造函数中被初始化之后的值。</p><p><strong>初始化</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//指定容量，默认为Integer.MAX_VALUE</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LinkedBlockingQueue</span><span class="params">(<span class="keyword">int</span> capacity)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (capacity &lt;= <span class="number">0</span>) <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">    <span class="keyword">this</span>.capacity = capacity;</span><br><span class="line">    last = head = <span class="keyword">new</span> Node&lt;E&gt;(<span class="keyword">null</span>);    <span class="comment">//构造元素为null的head节点，并将last指向head节点</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-1-put-amp-take-阻塞"><a href="#3-2-1-put-amp-take-阻塞" class="headerlink" title="3.2.1 put&amp;take 阻塞"></a>3.2.1 put&amp;take 阻塞</h4><p><strong>阻塞式入队（put）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">put</span><span class="params">(E e)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (e == <span class="keyword">null</span>) <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">    <span class="comment">// Note: convention in all put/take/etc is to preset local var 预置本地变量，例如入队锁赋给局部变量putLock</span></span><br><span class="line">    <span class="comment">// holding count negative to indicate failure unless set.</span></span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    Node&lt;E&gt; node = <span class="keyword">new</span> Node(e);    <span class="comment">//构造新节点</span></span><br><span class="line">    <span class="comment">//预置本地变量putLock和count</span></span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    putLock.lockInterruptibly();    <span class="comment">//可中断获取入队锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * Note that count is used in wait guard even though it is</span></span><br><span class="line"><span class="comment">         * not protected by lock. This works because count can</span></span><br><span class="line"><span class="comment">         * only decrease at this point (all other puts are shut</span></span><br><span class="line"><span class="comment">         * out by lock), and we (or some other waiting put) are</span></span><br><span class="line"><span class="comment">         * signalled if it ever changes from capacity. Similarly</span></span><br><span class="line"><span class="comment">         * for all other uses of count in other wait guards.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">while</span> (count.get() == capacity) &#123;</span><br><span class="line">            notFull.await();</span><br><span class="line">        &#125;</span><br><span class="line">        enqueue(node);    <span class="comment">//在队尾插入node</span></span><br><span class="line">        c = count.getAndIncrement();    <span class="comment">//count原子方式增1，返回值c为count增长之前的值</span></span><br><span class="line">        <span class="keyword">if</span> (c + <span class="number">1</span> &lt; capacity)    <span class="comment">//如果队列未满，通知入队线程（notFull条件等待队列中的线程）</span></span><br><span class="line">            notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();    <span class="comment">//释放入队锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//如果入队该元素之前队列中元素数量为0，那么通知出队线程（notEmpty条件等待队列中的线程）</span></span><br><span class="line">    <span class="keyword">if</span> (c == <span class="number">0</span>)</span><br><span class="line">        signalNotEmpty();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//通知出队线程（notEmpty条件等待队列中的线程）</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotEmpty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lock();    <span class="comment">//获取出队锁，调用notEmpty条件的方法的前提</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notEmpty.signal();    <span class="comment">//唤醒一个等待出队的线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();    <span class="comment">//释放出队锁</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">enqueue</span><span class="params">(Node&lt;E&gt; node)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert putLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert last.next == null;</span></span><br><span class="line">    last = last.next = node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><ul><li>思考问题一：为什么要再声明一个final局部变量指向putLock和count，直接使用成员变量不行吗？</li></ul><p>&emsp;直接使用成员变量：每次调用putLock的方法，都需要先通过this指针找到Heap中的Queue实例，然后在根据Queue实例的putLock域引用找到Lock实例，最后才能调用Lock的方法（即将相应的方法信息组装成栈帧压入栈顶）。声明一个final局部变量指向putLock：先通过this指针找到Heap中的Queue实例，将Queue实例的putLock域存储的Lock实例的地址赋给局部变量putLock，以后需要调用putLock的方法时，直接使用局部变量putLock引用就可以找到Lock实例。简化了查找Lock实例的过程。count变量也是同样的道理。个人理解应该是为了提升效率。</p><ul><li>思考问题二：使用两把锁怎么保证元素的可见性？</li></ul><p>&emsp;例如：入队线程使用put方法在队列尾部插入一个元素，怎么保证出队线程能看到这个元素？ArrayBlockingQueue的入队和出队使用同一个锁，所以没有可见性问题。<br>&emsp;在LinkedBlockingQueue中，每次一个元素入队， 都需要获取putLock和更新count，而出队线程为了保证可见性，需要获取fullyLock（fullyLock方法用于一些批量操作,对全局加锁）或者获取takeLock，然后读取count.get()。因为volatile对象的写操作happen-before读操作,也就是写线程先写的操作对随后的读线程是可见的，volatile相当于一个内存屏障,volatile后面的指令不允许重排序到它之前，而count是原子整型类，是基于volatile变量和CAS机制实现。所以就保证了可见性，写线程修改count—&gt;读线程读取count—&gt;读线程。</p><ul><li>思考问题三：在put方法中，为什么唤醒出队线程的方法signalNotEmpty()要放在释放putLock锁（putLock.unlock()）之后？同样，take也有同样的疑问？</li></ul><p>&emsp;避免死锁的发生，因为signalNotEmpty()方法中要获取takeLock锁。如果放在释放putLock之前，相当于在入队线程需要先获取putLock锁，再获取takeLock锁。例如：当入队线程先获取到putLock锁，并尝试获取takeLock锁，出队线程获取到takeLock锁，并尝试获取putLock锁时，就会产生死锁。</p><ul><li>思考问题四：什么是级联通知？</li></ul><p>&emsp;比如put操作会调用notEmpty的notify,只会唤醒一个等待的读线程来take,take之后如果发现还有剩余的元素,会继续调用notify,通知下一个线程来获取。</p><p><strong>阻塞式出队（take）</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> E <span class="title">take</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    E x;</span><br><span class="line">    <span class="keyword">int</span> c = -<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">final</span> AtomicInteger count = <span class="keyword">this</span>.count;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock takeLock = <span class="keyword">this</span>.takeLock;</span><br><span class="line">    takeLock.lockInterruptibly();    <span class="comment">//可中断获取出队锁</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> (count.get() == <span class="number">0</span>) &#123;    <span class="comment">//如果队列为空，阻塞线程同时释放锁</span></span><br><span class="line">            notEmpty.await();</span><br><span class="line">        &#125;</span><br><span class="line">        x = dequeue();    <span class="comment">//从队列头弹出元素</span></span><br><span class="line">        c = count.getAndDecrement(); <span class="comment">//count原子式递减</span></span><br><span class="line">        <span class="comment">//c&gt;1说明本次出队后，队列中还有元素</span></span><br><span class="line">        <span class="keyword">if</span> (c &gt; <span class="number">1</span>)</span><br><span class="line">            notEmpty.signal();    <span class="comment">//唤醒一个等待出队的线程</span></span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        takeLock.unlock();    <span class="comment">//释放出队锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//c == capacity说明本次出队之前是满队列，唤醒一个等待NotFull的线程</span></span><br><span class="line">    <span class="keyword">if</span> (c == capacity)</span><br><span class="line">        signalNotFull();</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//唤醒一个等待NotFull条件的线程</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">signalNotFull</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> ReentrantLock putLock = <span class="keyword">this</span>.putLock;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        notFull.signal();</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        putLock.unlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//从队列头弹出元素</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> E <span class="title">dequeue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// assert takeLock.isHeldByCurrentThread();</span></span><br><span class="line">    <span class="comment">// assert head.item == null;</span></span><br><span class="line">    Node&lt;E&gt; h = head;</span><br><span class="line">    Node&lt;E&gt; first = h.next;</span><br><span class="line">    h.next = h; <span class="comment">// help GC</span></span><br><span class="line">    head = first;</span><br><span class="line">    E x = first.item;</span><br><span class="line">    first.item = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h4 id="3-2-2-remove-amp-contains-amp-Iterator"><a href="#3-2-2-remove-amp-contains-amp-Iterator" class="headerlink" title="3.2.2 remove &amp; contains &amp; Iterator"></a>3.2.2 remove &amp; contains &amp; Iterator</h4><p><strong>1）remove</strong></p><p>&emsp;删除指定元素,<strong>全局加锁</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">remove</span><span class="params">(Object o)</span> </span>&#123;   <span class="comment">//正常用不到remove方法,queue正常只使用入队出队操作.</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    fullyLock();                    <span class="comment">// 两个锁都锁上了,禁止进行入队出队操作.</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; trail = head, p = trail.next;</span><br><span class="line">             p != <span class="keyword">null</span>;             <span class="comment">// 按顺序一个一个检索,直到p==null</span></span><br><span class="line">             trail = p, p = p.next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item)) &#123; <span class="comment">//找到了,就删除掉</span></span><br><span class="line">                unlink(p, trail);   <span class="comment">//删除操作是一个unlink方法,意思是p从LinkedList链路中解除.</span></span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;        <span class="comment">//返回删除成功</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p><strong>2）contains</strong></p><p>&emsp;判断是否包含指定的元素,<strong>全局加锁</strong><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">contains</span><span class="params">(Object o)</span> </span>&#123;     <span class="comment">//这种需要检索的操作都是对全局加锁的,很影响性能,要小心使用!</span></span><br><span class="line">    <span class="keyword">if</span> (o == <span class="keyword">null</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    fullyLock();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (Node&lt;E&gt; p = head.next; p != <span class="keyword">null</span>; p = p.next)</span><br><span class="line">            <span class="keyword">if</span> (o.equals(p.item))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        fullyUnlock();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;<strong>remove和contains这种需要检索的操作都是对全局加锁的,很影响性能,要小心使用!</strong><br>&emsp;全局加锁和解锁的方法作为公共的方法供其他需要全局锁的方法调用，避免由于获取锁的顺序不一致导致死锁。另外fullyLock和fullyUnlock两个方法对锁的操作要相反。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Lock to prevent both puts and takes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyLock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    putLock.lock();</span><br><span class="line">    takeLock.lock();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Unlock to allow both puts and takes.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fullyUnlock</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    takeLock.unlock();</span><br><span class="line">    putLock.unlock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>3）迭代器Iterator</strong><br>&emsp;弱一致性，不会不会抛出ConcurrentModificationException异常，不会阻止遍历的时候对queue进行修改操作,可能会遍历到修改操作的结果.</p><h3 id="3-3-LinkedBlockingQueue和ArrayBlockingQueue对比"><a href="#3-3-LinkedBlockingQueue和ArrayBlockingQueue对比" class="headerlink" title="3.3 LinkedBlockingQueue和ArrayBlockingQueue对比"></a>3.3 LinkedBlockingQueue和ArrayBlockingQueue对比</h3><p>&emsp;ArrayBlockingQueue由于其底层基于数组，并且在创建时指定存储的大小，在完成后就会立即在内存分配固定大小容量的数组元素，因此其存储通常有限，故其是一个“有界“的阻塞队列；而LinkedBlockingQueue可以由用户指定最大存储容量，也可以无需指定，如果不指定则最大存储容量将是Integer.MAX_VALUE，即可以看作是一个“无界”的阻塞队列，由于其节点的创建都是动态创建，并且在节点出队列后可以被GC所回收，因此其具有灵活的伸缩性。但是由于ArrayBlockingQueue的有界性，因此其能够更好的对于性能进行预测，而LinkedBlockingQueue由于没有限制大小，当任务非常多的时候，不停地向队列中存储，就有可能导致<strong>内存溢出</strong>的情况发生。<br>&emsp;其次，ArrayBlockingQueue中在入队列和出队列操作过程中，使用的是同一个lock，所以即使在多核CPU的情况下，其读取和操作的都无法做到并行，而LinkedBlockingQueue的读取和插入操作所使用的锁是两个不同的lock，它们之间的操作互相不受干扰，因此两种操作可以并行完成，故LinkedBlockingQueue的吞吐量要高于ArrayBlockingQueue。</p><h3 id="3-4-延迟队列-DelayQueue"><a href="#3-4-延迟队列-DelayQueue" class="headerlink" title="3.4 延迟队列 DelayQueue"></a>3.4 延迟队列 DelayQueue</h3><p>&emsp;Delayed 元素的一个无界阻塞队列，只有在延迟期满时才能从中提取元素。该队列的头部 是延迟期满后保存时间最长的 Delayed 元素。如果延迟都还没有期满，则队列没有头部，并且 poll 将返回 null。当一个元素的 getDelay(TimeUnit.NANOSECONDS) 方法返回一个小于等于 0 的值时，将发生到期。即使无法使用 take 或 poll 移除未到期的元素，也不会将这些元素作为正常元素对待。例如，size 方法同时返回到期和未到期元素的计数。此队列不允许使用 null 元素。</p><h3 id="3-5-具有优先级的阻塞队列-PriorityBlockingQueue"><a href="#3-5-具有优先级的阻塞队列-PriorityBlockingQueue" class="headerlink" title="3.5 具有优先级的阻塞队列 PriorityBlockingQueue"></a>3.5 具有优先级的阻塞队列 PriorityBlockingQueue</h3><p>&emsp;基于优先级的无界阻塞队列。优先级队列的元素按照其自然顺序进行排序，或者根据构造队列时提供的 Comparator 进行排序，具体取决于所使用的构造方法。优先级队列不允许使用 null 元素。依靠自然顺序的优先级队列还不允许插入不可比较的对象（这样做可能导致 ClassCastException）。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致 OutOfMemoryError）。<br>&emsp;一个<strong>无界</strong>阻塞队列，它使用与类 PriorityQueue 相同的顺序规则，并且提供了阻塞获取操作。虽然此队列逻辑上是无界的，但是资源被耗尽时试图执行 add 操作也将失败（导致OutOfMemoryError）。此类不允许使用 null 元素。依赖自然顺序的<br>优先级队列也不允许插入不可比较的对象（这样做会导致抛出 ClassCastException）。<br>&emsp;此类及其迭代器可以实现 Collection 和 Iterator 接口的所有可选 方法。iterator() 方法中提供的迭代器并不 保证以特定的顺序遍历 PriorityBlockingQueue 的元素。如果需要有序地进行遍历，则应考虑使用 Arrays.sort(pq.toArray())。此外，可以使用方法 drainTo 按优先级顺序移除 全部或部分元素，并将它们放在另一个 collection 中。<br>&emsp;在此类上进行的操作不保证具有同等优先级的元素的顺序。如果需要实施某一排序，那么可以定义自定义类或者比较器，比较器可使用修改键断开主优先级值之间的联系。例如，以下是应用先进先出 (first-in-first-out) 规则断开可比较元素之间联系的一个类。要使用该类，则需要插入一个新的 FIFOEntry(anEntry) 来替换普通的条目对象。</p><h3 id="3-6-同步队列-SynchronousQueue"><a href="#3-6-同步队列-SynchronousQueue" class="headerlink" title="3.6 同步队列 SynchronousQueue"></a>3.6 同步队列 SynchronousQueue</h3><p>&emsp;同步的阻塞队列。其中每个插入操作必须等待另一个线程的对应移除操作，等待过程一直处于阻塞状态，同理，每一个移除操作必须等到另一个线程的对应插入操作。SynchronousQueue没有任何容量。不能在同步队列上进行 peek，因为仅在试图要移除元素时，该元素才存在；除非另一个线程试图移除某个元素，否则也不能（使用任何方法）插入元素；也不能迭代队列，因为其中没有元素可用于迭代。Executors.newCachedThreadPool使用了该队列。<br>&emsp;SynchronousQueue 是一个特殊的队列，它的内部同时只能够容纳单个元素。如果该队列已有一元素的话，试图向队列中插入一个新元素的线程将会阻塞，直到另一个线程将该元素从队列中抽走。同样，如果该队列为空，试图向队列中抽取一个元素的线程将会阻塞，直到另一个线程向队列中插入了一条新的元素。<br>&emsp;据此，把这个类称作一个队列显然是夸大其词了。它更多像是一个汇合点。</p><h3 id="3-7-阻塞双端队列-BlockingDeque"><a href="#3-7-阻塞双端队列-BlockingDeque" class="headerlink" title="3.7 阻塞双端队列 BlockingDeque"></a>3.7 阻塞双端队列 BlockingDeque</h3><p>&emsp;java.util.concurrent 包里的 BlockingDeque 接口表示一个线程安放入和提取实例的双端队列。<br>&emsp;BlockingDeque 类是一个双端队列，在不能够插入元素时，它将阻塞住试图插入元素的线程；在不能够抽取元素时，它将阻塞住试图抽取的线程。<br>&emsp;deque(双端队列) 是 “Double Ended Queue” 的缩写。因此，双端队列是一个你可以从任意一端插入或者抽取元素的队列。</p><h3 id="3-8-链阻塞双端队列-LinkedBlockingDeque"><a href="#3-8-链阻塞双端队列-LinkedBlockingDeque" class="headerlink" title="3.8 链阻塞双端队列 LinkedBlockingDeque"></a>3.8 链阻塞双端队列 LinkedBlockingDeque</h3><p>&emsp;一个基于已链接节点的、任选范围的阻塞双端队列。<br>&emsp;可选的容量范围构造方法参数是一种防止过度膨胀的方式。如果未指定容量，那么容量将等于 Integer.MAX_VALUE。只要插入元素不会使双端队列超出容量，每次插入后都将动态地创建链接节点。<br>大多数操作都以固定时间运行（不计阻塞消耗的时间）。异常包括 remove、removeFirstOccurrence、removeLastOccurrence、contains、iterator.remove() 以及批量操作，它们均以线性时间运行。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考链接：<br><a href="https://www.cnblogs.com/zaizhoumo/p/7786793.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaizhoumo/p/7786793.html</a><br><a href="https://blog.csdn.net/wtopps/article/details/80682267" target="_blank" rel="noopener">https://blog.csdn.net/wtopps/article/details/80682267</a><br><a href="https://blog.csdn.net/qq_42135428/article/details/80285737" target="_blank" rel="noopener">https://blog.csdn.net/qq_42135428/article/details/80285737</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>密码学基础 - 群、环、域</title>
      <link href="/cryptography/cryptography/"/>
      <url>/cryptography/cryptography/</url>
      
        <content type="html"><![CDATA[<h1 id="密码学基础-群、环、域"><a href="#密码学基础-群、环、域" class="headerlink" title="密码学基础-群、环、域"></a>密码学基础-群、环、域</h1><h2 id="群"><a href="#群" class="headerlink" title="群"></a>群</h2><h3 id="群的概念"><a href="#群的概念" class="headerlink" title="群的概念"></a>群的概念</h3><p><strong>定义</strong> 设G是一个非空集合, “∗”是G是上的一个代数运算, 即对所有的a, b∈G, 有a∗b∈G.<br>     如果G的运算还满足:</p><ul><li>(G1)结合律:即对所有的a, b, c∈G, 有 (a∗b)∗c=a∗(b∗c)</li><li>(G2) G中存在元素e, 使得对每个a∈G, 有 e∗a=a∗e=a</li><li>(G3) 对G中每个元素a, 存在元素b∈G, 使得 a∗b=b∗a=e.</li></ul><p>则称G关于运算“∗”构成一个群(group), 记为(G, ∗).      </p><ul><li>注1: (G2)中的元素e 称为群G的单位元(unit element)或恒等元(identity). <strong>群G的单位元是唯一的</strong>.</li><li>注2: (G3)中的元素b称为元素a的逆元(inverse).<strong>元素a的逆元是唯一的</strong>,记为a<sup>-1</sup>. 即有<br>a∗a<sup>-1</sup>=a<sup>-1</sup>∗a=e</li></ul><h3 id="交换群"><a href="#交换群" class="headerlink" title="交换群"></a>交换群</h3><p>如果群G的运算还满足:</p><ul><li>(G4)交换律:即对所有的a, b∈G, 有a∗b=b∗a.</li></ul><p>则称G是一个<strong>交换群</strong>(commutative group),或阿贝尔群(abelian group).</p><h3 id="有限群-无限群"><a href="#有限群-无限群" class="headerlink" title="有限群/无限群"></a>有限群/无限群</h3><p>G中元素的个数称为群G的<strong>阶</strong>(order), 记为|G|.<br>如果|G|是有限数,则称G是<strong>有限群</strong>(finite group), 否则称G是<strong>无限群</strong>(infinite group).</p><p>例: 整数加群(Z,+); 有理数加群(Q,+); 实数加群(R,+); 复数加群(C,+).<br>令Q<em>=Q-{0}, (Q</em>, ×)是群; Q<sup>+</sup>={q∈Q| q&gt;0}, (Q<sup>+</sup>, ×)是群.</p><p>例1 设G={1, -1, i, -i}, 则(G, ×) 是一个有限交换群.<br>| 元素a | 逆元a<sup>-1</sup> |<br>| — | — |<br>| 1 | 1  |<br>| -1 |  -1 |<br>| i |  -i |<br>| -i |  i |</p><p>例2 设m∈Z<sup>+</sup>, Zm={0,1,…, m-1}, 则(Zm, ⊕) 是一个有限交换群. 称为模m剩余类加群.</p><ul><li>单位元是e=0; a∈Zm的逆元a<sup>-1</sup>= m-a.</li><li>特别地: 取m=5, 有Z5={0,1,2,3,4},</li></ul><p>有时把交换群(G, ∗)记为(G, +), 称为“加群”.(* 代表的操作为加时)</p><ul><li>把运算“∗”称为“加” 法, 运算结果记为: a∗b= a+b,称为a与b的“和”;</li><li>单位元称为“零元”, 记为“0”;</li><li>a∈G的逆元称为G的负元,记为: “-a”, 即有a+(-a)= 0.</li></ul><p>有时把群(G, ∗)记为(G, ⋅), 称为“ 乘群”.(* 代表的操作为乘时)</p><ul><li>把运算“∗”称为“乘” 法, 运算结果记为: a∗b= a⋅b, 称为a与b的“积”;</li><li>运算符号通常省略, 简记为: a∗b=a⋅b=ab.</li><li>单位元记为: e=1.</li></ul><h3 id="群的幂"><a href="#群的幂" class="headerlink" title="群的幂"></a>群的幂</h3><p>设(G, ⋅)是一个群, n∈Z+, a∈G的n次幂为:</p><ul><li>a<sup>n</sup> = a⋅a⋅…⋅a (n个a)</li><li>a<sup>0</sup> =e, a<sup>-n</sup> =(a<sup>-1</sup>)<sup>n</sup>.</li></ul><p>指数法则: 设a,b∈G, n, m∈Z,则有</p><ul><li>(1) a<sup>n</sup>⋅a<sup>m</sup>= a<sup>n+m</sup>;</li><li>(2) (a<sup>n</sup>)<sup>m</sup> =a<sup>nm</sup>;</li><li>(3) 如果G是一个交换群, 则(a⋅b)<sup>n</sup>= a<sup>n</sup>⋅b<sup>n</sup>.</li></ul><p>加群的倍数<br>设(G, +)是一个加群, n∈Z+, a∈G的n倍为:</p><ul><li>na= a+a+…+a (n个a)</li><li>0a =0, (-n)a =n(-a).</li></ul><p>倍数法则: 设a,b∈G, n, m∈Z,则有</p><ul><li>(1)na +ma =(n+m)a; </li><li>(2) m(na) =(nm)a;</li><li>(3) n(a+b) =na+nb</li></ul><h3 id="群元素的阶"><a href="#群元素的阶" class="headerlink" title="群元素的阶"></a>群元素的阶</h3><p>设G是一个群, e是G的单位元, a∈G, 如果存在正整数r, 使得a<sup>r</sup>=e,则称a是有限阶的, 否则称a是无限阶的.<br>如果a是有限阶的, 则把满足a<sup>r</sup>=e的最小正整数r称为a的阶(order),记为ord a=r.<br>如果a是无限阶的, 则记ord a =∞.</p><p>计算群(Z5<em>, ⊗)每个元素的阶, Z5</em>={1,2,3,4}.<br>解：对于a=2, 有<br>21=2, 22=2⊗2=4, 23=2⊗2⊗2=8=3, 24=2⊗2⊗2⊗2=16=1.<br>∴ ord 2=4.</p><h3 id="循环群"><a href="#循环群" class="headerlink" title="循环群"></a>循环群</h3><p>设G是一个群, 如果存在a∈G, 使得<br>G={a<sup>1</sup>, a<sup>2</sup>,…}=\<a>,<br>则称G是一个<strong>循环群</strong>(cyclic group), 并称a是的一个<strong>生成元</strong>(generator).</p><p>如果G是一个n阶循环群, 则 G={a<sup>1</sup>, a<sup>n</sup>,…,a<sup>n</sup>}=\<a>.</p><p>如果G是一个n阶循环群, 且元素a∈G的阶=群G的阶, 则a是G的一个生成元.</p><p>例8 设m∈Z+, Zm={0,1,…, m-1}, 则(Zm, ⊕) 是m阶循环群.1是一个生成元.<br>特别地: 取m=6, Z6={0,1,2,3,4,5}的生成元有: 1, 5.<br>   5<sup>1</sup>=1×5=5, 5<sup>2</sup>=2×5=10=4, 5<sup>3</sup>=3×5=15=3, 5<sup>4</sup>=4×5=20=2,  5<sup>5</sup>=5×5=25=1, 5<sup>6</sup>=6×5=30=0.<br>∴ Z6={0,1,2,3,4,5}={6×5, 5×5, 4×5, 3×5, 2×5, 1×5}.<br>注意:<strong>循环群的生成元不是唯一的</strong>!</p><ul><li><strong>定理</strong>  设p是素数, 则(Z<sub>p</sub><sup>*</sup>, ⊗)是p-1阶循环群.<br>Z<sub>p</sub><sup>*</sup>的生成元a称为Z的一个模p元根(primitive root).</li></ul><p>群(Z<sub>5</sub><sup>*</sup>, ⊗)是4阶循环群, Z<sub>5</sub><sup>*</sup>={1,2,3,4}. 生成元有: 2, 3.<br>  解 对于a=2, 有<br>   2<sup>1</sup>=2, 2<sup>2</sup>=2⊗2=4, 2<sup>3</sup>=2⊗2⊗2=8=3, 2<sup>4</sup>=2⊗2⊗2⊗2=16=1.<br>∴ Z<sub>5</sub><sup>*</sup>={1,2,3,4}={24, 21, 23, 22}.</p><ul><li><strong>定理</strong> 设G是一个n阶循环群, 则G恰有φ(n)个生成元.<br>如果a是G的一个生成元, 则a<sup>r</sup>也是G的生成元的充分必要条件是:gcd(n, r)=1.</li></ul><p>例10 求(Z12, ⊕)的全部生成元.<br>  提示:1是一个生成元.<br>解:1是一个生成元.<br>满足gcd(12, r)=1的r : 1, 5, 7, 11.<br>∴ Z12的生成元有: 1×1=1, 5×1=5, 7×1=7, 11×1=11.</p><h2 id="环"><a href="#环" class="headerlink" title="环"></a>环</h2><h3 id="环的基本概念"><a href="#环的基本概念" class="headerlink" title="环的基本概念"></a>环的基本概念</h3><p><strong>定义</strong> 设R是一个非空集合. 如果在R上定义了两个代数运算, “+”(称为加法)和“∗” (称为乘法), 并且满足:</p><ul><li>(R1) (R, +)构成一个交换群;</li><li>(R2) 乘法结合律: 即对所有的a, b, c∈R, 有 (a∗b)∗c=a∗(b∗c);</li><li>(R3) 乘法对加法的分配律:即对所有的a, b, c∈R, 有<br>  a∗(b+c)=a∗b+a∗c,<br>  (b+c)∗a=b∗a+c∗a,</li></ul><p>则称R关于运算“+”和“∗”构成一个环(ring), 记为(R,+, ∗).</p><ul><li>注1: (R, +)是一个交换群, 称为R的加法群. 环R的加法单位元称为环的零元,记为0.<br>环R的元素a的加法逆元称为a负元, 记为-a.</li><li>注2: 如果环R的乘法还满足交换律, 则称R为交换环.</li><li>注3: 如果环R中存在元素e, 使对任意的a∈R, 有 a∗e=e∗a=a,</li></ul><p>则称R是一个有单位元的环, 并称e是R的乘法单位元(unit).<br>如果环R有单位元, 则R的单位元是唯一的. 环R的乘法单位元记为e或1.</p><ul><li>注4: 设环R有单位元e, a∈R, 如果存在  b∈R,使a∗b=b∗a=e,</li></ul><p>则称a是R的一个可逆元(invertible element),并称b是a的逆元(inverseelement), 记为b=a-1.<br>一个环中, 可能有些元素有逆元, 而其它元素没有逆元.</p><p>例4.1.2.1 整数环(Z, +, ×); 有理数环(Q,+, ×); 实数环(R,+, ×); 复数环(C,+,×).<br>例4.1.2.2 设m∈Z+, Zm={0,1,…, m-1}, 则(Zm, ⊕, ⊗) 是一个有单位元的交换环. 称为模m剩余类环(residue class ring).</p><h2 id="域"><a href="#域" class="headerlink" title="域"></a>域</h2><h3 id="域的基本概念"><a href="#域的基本概念" class="headerlink" title="域的基本概念"></a>域的基本概念</h3><p><strong>定义</strong> 设(F,+, ∗)是一个环. 如果F有乘法单位元1≠0的, 且每个非零元都是可逆的, 则称(F,+, ∗) 是一个域(field).<br>进一步, 如果F是有限集,则称(F,+, ∗) 是一个有限域(finite field), 也称为伽罗华域(Galois field).</p><p>例  有理数域(Q,+, ×); 实数域(R,+, ×); 复数域(C,+, ×).<br>例4.1.2.2 设p∈Z+是素数, Zp={0,1,…, p-1}, 则(Zp, ⊕, ⊗) 是一个有限域.</p><h3 id="定理"><a href="#定理" class="headerlink" title="定理"></a>定理</h3><ul><li>(1) 每个有限域的阶一定是素数的幂: p<sup>n</sup>. 含有p<sup>n</sup>个元素的有限域记为GF(<sup>n</sup>).</li><li>(2) 任给素数p和正整数n, 一定存在阶为p<sup>n</sup>的有限域.</li><li>(3) 同阶的有限域是同构的.</li><li>(4) 令GF(p<sup>n</sup>)<sup>*</sup>表示GF(p<sup>n</sup>)的全体非零元的集合, 则GF(p<sup>n</sup>)<sup>*</sup>关于乘法是一个p<sup>n</sup>-1阶循环群.\</li><li>含有p<sup>n</sup>个元素的有限域只有一个.</li><li>当n=1时, GF(p)=(Zp, ⊕, ⊗)=F<sub>n</sub> 称为素域.</li></ul><h2 id="多项式环与有限域"><a href="#多项式环与有限域" class="headerlink" title="多项式环与有限域"></a>多项式环与有限域</h2><h3 id="多项式环的基本性质"><a href="#多项式环的基本性质" class="headerlink" title="多项式环的基本性质"></a>多项式环的基本性质</h3><p>设F是一个有限域, 表达式<br>f(x)=a<sub>n</sub>x<sup>n</sup>+ a<sub>n-1</sub>x<sup>n-1</sup>+…+a<sub>n-1</sub>x+a<sub>0</sub> (a<sub>i</sub>∈F, i=0,1,…, n-1)<br>称为有限域F上的一个多项(polynomial), x称为未定元(indeterminate).</p><p>多项式的次数(degree):<br>如果a<sub>n</sub>≠0,则称f(x)的次数为n, 记为: deg(f(x))=n,deg(0)= -∞.<br>首一多项式(monic polynomial): a<sub>n</sub>=1的多项式.<br>多项式的加法“+”与乘法“×”.<br>用F[x]表示有限域F上的全体多项式集合</p><p>定理 任给两个多项式f(x), g(x)∈F[x],一定存在唯一的q(x)和r(x)满足:<br>    f(x)=q(x)g(x)+r(x)    deg(r(x)) x&lt; deg(g(x)).<br>q(x)称为商式, r(x)称为余式.</p><p>已知F5上的多项式<br>    f(x)=2x5+ x4+4x+3, g(x)=3x2+1,<br>   求商式与余式.<br>  解: 使用长除法(long division)<br>  ∴商式q(x)=4x3+2x2+2x+1<br>   余式r(x)=2x+2.</p>]]></content>
      
      
      <categories>
          
          <category> cryptography </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 密码学 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 之 AbstractQueuedSynchronizer</title>
      <link href="/java/java-AbstractQueuedSynchronizer/"/>
      <url>/java/java-AbstractQueuedSynchronizer/</url>
      
        <content type="html"><![CDATA[<h1 id="AbstractQueuedSynchronizer-详解"><a href="#AbstractQueuedSynchronizer-详解" class="headerlink" title="AbstractQueuedSynchronizer 详解"></a>AbstractQueuedSynchronizer 详解</h1><p>&emsp;本文为转载保存，原文链接在文章末尾给出。文章对 AbstractQueuedSynchronizer 进行了细致的分析，非常详细和全面。虽然暂时还未能完全理解这篇文章，但是非常值得保存慢慢学习消化。</p><h2 id="1-背景"><a href="#1-背景" class="headerlink" title="1. 背景"></a>1. 背景</h2><p>&emsp;AQS（java.util.concurrent.locks.AbstractQueuedSynchronizer）是Doug Lea大师创作的用来构建锁或者其他同步组件（信号量、事件等）的基础框架类。JDK中许多并发工具类的内部实现都依赖于AQS，如ReentrantLock, Semaphore, CountDownLatch等等。学习AQS的使用与源码实现对深入理解concurrent包中的类有很大的帮助。<br>本文重点介绍AQS中的基本实现思路，包括独占锁、共享锁的获取和释放实现原理和一些代码细节。</p><p>&emsp;对于AQS中ConditionObject的相关实现，可以参考我的另一篇博文<a href="http://www.cnblogs.com/micrari/p/7219751.html" target="_blank" rel="noopener">AbstractQueuedSynchronizer源码解读—续篇之Condition</a>。</p><h2 id="2-简介"><a href="#2-简介" class="headerlink" title="2. 简介"></a>2. 简介</h2><p>&emsp;AQS的主要使用方式是继承它作为一个内部辅助类实现同步原语，它可以简化你的并发工具的内部实现，屏蔽同步状态管理、线程的排队、等待与唤醒等底层操作。</p><p>&emsp;AQS设计基于模板方法模式，开发者需要继承同步器并且重写指定的方法，将其组合在并发组件的实现中，调用同步器的模板方法，模板方法会调用使用者重写的方法。</p><h2 id="3-实现思路"><a href="#3-实现思路" class="headerlink" title="3. 实现思路"></a>3. 实现思路</h2><p>&emsp;下面介绍下AQS具体实现的大致思路。</p><p>&emsp;AQS内部维护一个CLH队列来管理锁。线程会首先尝试获取锁，如果失败，则将当前线程以及等待状态等信息包成一个Node节点加到同步队列里。接着会不断循环尝试获取锁（条件是当前节点为head的直接后继才会尝试）,如果失败则会阻塞自己，直至被唤醒；而当持有锁的线程释放锁时，会唤醒队列中的后继线程。</p><p>&emsp;下面列举JDK中几种常见使用了AQS的同步组件：</p><ul><li>ReentrantLock: 使用了AQS的独占获取和释放,用state变量记录某个线程获取独占锁的次数,获取锁时+1，释放锁时-1，在获取时会校验线程是否可以获取锁。</li><li>Semaphore: 使用了AQS的共享获取和释放，用state变量作为计数器，只有在大于0时允许线程进入。获取锁时-1，释放锁时+1。</li><li>CountDownLatch: 使用了AQS的共享获取和释放，用state变量作为计数器，在初始化时指定。只要state还大于0，获取共享锁会因为失败而阻塞，直到计数器的值为0时，共享锁才允许获取，所有等待线程会被逐一唤醒。</li></ul><h3 id="3-1-如何获取锁"><a href="#3-1-如何获取锁" class="headerlink" title="3.1 如何获取锁"></a>3.1 如何获取锁</h3><p>&emsp;获取锁的思路很直接：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">while (不满足获取锁的条件) &#123;</span><br><span class="line">    把当前线程包装成节点插入同步队列</span><br><span class="line">    if (需要阻塞当前线程)</span><br><span class="line">        阻塞当前线程直至被唤醒</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">将当前线程从同步队列中移除</span><br></pre></td></tr></table></figure><br>&emsp;以上是一个很简单的获取锁的伪代码流程，AQS的具体实现比这个复杂一些，也稍有不同，但思想上是与上述伪代码契合的。<br>&emsp;通过循环检测是否能够获取到锁，如果不满足，则可能会被阻塞，直至被唤醒。</p><h3 id="3-2-如何释放锁"><a href="#3-2-如何释放锁" class="headerlink" title="3.2 如何释放锁"></a>3.2 如何释放锁</h3><p>&emsp;释放锁的过程设计修改同步状态，以及唤醒后继等待线程：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">修改同步状态</span><br><span class="line">if (修改后的状态允许其他线程获取到锁)</span><br><span class="line">    唤醒后继线程</span><br></pre></td></tr></table></figure><br>这只是很简略的释放锁的伪代码示意，AQS具体实现中能看到这个简单的流程模型。</p><h3 id="3-3-API简介"><a href="#3-3-API简介" class="headerlink" title="3.3 API简介"></a>3.3 API简介</h3><p>&emsp;通过上面的AQS大体思路分析，我们可以看到，AQS主要做了三件事情:</p><ul><li>同步状态的管理</li><li>线程的阻塞和唤醒</li><li><p>同步队列的维护<br>下面三个protected final方法是AQS中用来访问/修改同步状态的方法:</p></li><li><p>int getState(): 获取同步状态</p></li><li>void setState(): 设置同步状态</li><li>boolean compareAndSetState(int expect, int update)：基于CAS，原子设置当前状态</li></ul><p>&emsp;在自定义基于AQS的同步工具时，我们可以选择覆盖实现以下几个方法来实现同步状态的管理：</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>boolean tryAcquire(int arg)</td><td>试获取独占锁</td></tr><tr><td>boolean tryRelease(int arg)</td><td>试释放独占锁</td></tr><tr><td>int tryAcquireShared(int arg)</td><td>试获取共享锁</td></tr><tr><td>boolean tryReleaseShared(int arg)</td><td>试释放共享锁</td></tr><tr><td>boolean isHeldExclusively()</td><td>当前线程是否获得了独占锁</td></tr></tbody></table></div><p>&emsp;以上的几个试获取/释放锁的方法的具体实现应当是无阻塞的。</p><p>&emsp;AQS本身将同步状态的管理用模板方法模式都封装好了，以下列举了AQS中的一些模板方法：</p><div class="table-container"><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void acquire(int arg)</td><td>获取独占锁。会调用tryAcquire方法，如果未获取成功，则会进入同步队列等待</td></tr><tr><td>void acquireInterruptibly(int arg)</td><td>响应中断版本的acquire</td></tr><tr><td>boolean tryAcquireNanos(int arg,long nanos)</td><td>响应中断+带超时版本的acquire</td></tr><tr><td>void acquireShared(int arg)</td><td>获取共享锁。会调用tryAcquireShared方法</td></tr><tr><td>void acquireSharedInterruptibly(int arg)</td><td>响应中断版本的acquireShared</td></tr><tr><td>boolean tryAcquireSharedNanos(int arg,long nanos)</td><td>响应中断+带超时版本的acquireShared</td></tr><tr><td>boolean release(int arg)</td><td>释放独占锁</td></tr><tr><td>boolean releaseShared(int arg)</td><td>释放共享锁</td></tr><tr><td>Collection getQueuedThreads()</td><td>获取同步队列上的线程集合</td></tr></tbody></table></div><p>&emsp;上面看上去很多方法，其实从语义上来区分就是获取和释放，从模式上区分就是独占式和共享式，从中断相应上来看就是支持和不支持。</p><h2 id="4-代码解读"><a href="#4-代码解读" class="headerlink" title="4. 代码解读"></a>4. 代码解读</h2><h3 id="4-1-数据结构定义"><a href="#4-1-数据结构定义" class="headerlink" title="4.1 数据结构定义"></a>4.1 数据结构定义</h3><p>&emsp;首先看一下AQS中的嵌套类Node的定义:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于标记一个节点在共享模式下等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node SHARED = <span class="keyword">new</span> Node();</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于标记一个节点在独占模式下等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> Node EXCLUSIVE = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待状态：取消</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CANCELLED = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待状态：通知</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SIGNAL = -<span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待状态：条件等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CONDITION = -<span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待状态：传播</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> PROPAGATE = -<span class="number">3</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待状态</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">int</span> waitStatus;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 前驱节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node prev;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Node next;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 节点对应的线程</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">volatile</span> Thread thread;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 等待队列中的后继节点</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node nextWaiter;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 当前节点是否处于共享模式等待</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">isShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> nextWaiter == SHARED;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取前驱节点，如果为空的话抛出空指针异常</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">final</span> Node <span class="title">predecessor</span><span class="params">()</span> <span class="keyword">throws</span> NullPointerException </span>&#123;</span><br><span class="line">        Node p = prev;</span><br><span class="line">        <span class="keyword">if</span> (p == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    Node() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * addWaiter会调用此构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Thread thread, Node mode) &#123;</span><br><span class="line">        <span class="keyword">this</span>.nextWaiter = mode;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Condition会用到此构造函数</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    Node(Thread thread, <span class="keyword">int</span> waitStatus) &#123;</span><br><span class="line">        <span class="keyword">this</span>.waitStatus = waitStatus;</span><br><span class="line">        <span class="keyword">this</span>.thread = thread;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里有必要专门梳理一下节点等待状态的定义，因为AQS源码中有大量的状态判断与跃迁。</p><div class="table-container"><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>CANCELLED (1)</td><td>当前线程因为超时或者中断被取消。这是一个终结态，也就是状态到此为止。</td></tr><tr><td>SIGNAL (-1)</td><td>当前线程的后继线程被阻塞或者即将被阻塞，当前线程释放锁或者取消后需要唤醒后继线程。这个状态一般都是后继线程来设置前驱节点的。</td></tr><tr><td>CONDITION (-2)</td><td>当前线程在condition队列中。</td></tr><tr><td>PROPAGATE (-3)</td><td>用于将唤醒后继线程传递下去，这个状态的引入是为了完善和增强共享锁的唤醒机制。在一个节点成为头节点之前，是不会跃迁为此状态的</td></tr><tr><td>0</td><td>表示无状态。</td></tr></tbody></table></div><p>&emsp;对于分析AQS中不涉及ConditionObject部分的代码，可以认为队列中的节点状态只会是CANCELLED, SIGNAL, PROPAGATE, 0这几种情况。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/AQS-status.png" alt="status"></p><p>&emsp;图为自制的AQS状态的流转图，AQS中0状态和CONDITION状态为始态，CANCELLED状态为终态。0状态同时也可以是节点生命周期的终态。<br>注意，上图仅表示状态之间流转的可达性，并不代表一定能够从一个状态沿着线随意跃迁。</p><p>&emsp;在AQS中包含了head和tail两个Node引用，其中head在逻辑上的含义是当前持有锁的线程，head节点实际上是一个虚节点，本身并不会存储线程信息。<br>当一个线程无法获取锁而被加入到同步队列时，会用CAS来设置尾节点tail为当前线程对应的Node节点。<br>head和tail在AQS中是延迟初始化的，也就是在需要的时候才会被初始化，也就意味着在所有线程都能获取到锁的情况下，队列中的head和tail都会是null。</p><h3 id="4-2-获取独占锁的实现"><a href="#4-2-获取独占锁的实现" class="headerlink" title="4.2 获取独占锁的实现"></a>4.2 获取独占锁的实现</h3><p>&emsp;下面来具体看看acquire(int arg)的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 获取独占锁，对中断不敏感。</span></span><br><span class="line"><span class="comment"> * 首先尝试获取一次锁，如果成功，则返回；</span></span><br><span class="line"><span class="comment"> * 否则会把当前线程包装成Node插入到队列中，在队列中会检测是否为head的直接后继，并尝试获取锁,</span></span><br><span class="line"><span class="comment"> * 如果获取失败，则会通过LockSupport阻塞当前线程，直至被释放锁的线程唤醒或者被中断，随后再次尝试获取锁，如此反复。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">        acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">        selfInterrupt();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队列中新增一个节点。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">    Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">    Node pred = tail;</span><br><span class="line">    <span class="comment">// 快速尝试</span></span><br><span class="line">    <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">        node.prev = pred;</span><br><span class="line">        <span class="comment">// 通过CAS在队尾插入当前节点</span></span><br><span class="line">        <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">            pred.next = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 初始情况或者在快速尝试失败后插入节点</span></span><br><span class="line">    enq(node);</span><br><span class="line">    <span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 通过循环+CAS在队列中成功插入一个节点后返回。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">enq</span><span class="params">(<span class="keyword">final</span> Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node t = tail;</span><br><span class="line">        <span class="comment">// 初始化head和tail</span></span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetHead(<span class="keyword">new</span> Node()))</span><br><span class="line">                tail = head;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * AQS的精妙就是体现在很多细节的代码，比如需要用CAS往队尾里增加一个元素</span></span><br><span class="line"><span class="comment">             * 此处的else分支是先在CAS的if前设置node.prev = t，而不是在CAS成功之后再设置。</span></span><br><span class="line"><span class="comment">             * 一方面是基于CAS的双向链表插入目前没有完美的解决方案，另一方面这样子做的好处是：</span></span><br><span class="line"><span class="comment">             * 保证每时每刻tail.prev都不会是一个null值，否则如果node.prev = t</span></span><br><span class="line"><span class="comment">             * 放在下面if的里面，会导致一个瞬间tail.prev = null，这样会使得队列不完整。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            node.prev = t;</span><br><span class="line">            <span class="comment">// CAS设置tail为node，成功后把老的tail也就是t连接到node。</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">                t.next = node;</span><br><span class="line">                <span class="keyword">return</span> t;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 在队列中的节点通过此方法获取锁，对中断不敏感。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 检测当前节点前驱是否head，这是试获取锁的资格。</span></span><br><span class="line"><span class="comment">             * 如果是的话，则调用tryAcquire尝试获取锁,</span></span><br><span class="line"><span class="comment">             * 成功，则将head置为当前节点。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                setHead(node);</span><br><span class="line">                p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                failed = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">return</span> interrupted;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">/*</span></span><br><span class="line"><span class="comment">             * 如果未成功获取锁则根据前驱节点判断是否要阻塞。</span></span><br><span class="line"><span class="comment">             * 如果阻塞过程中被中断，则置interrupted标志位为true。</span></span><br><span class="line"><span class="comment">             * shouldParkAfterFailedAcquire方法在前驱状态不为SIGNAL的情况下都会循环重试获取锁。</span></span><br><span class="line"><span class="comment">             */</span></span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 根据前驱节点中的waitStatus来判断是否需要阻塞当前线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">shouldParkAfterFailedAcquire</span><span class="params">(Node pred, Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = pred.waitStatus;</span><br><span class="line">    <span class="keyword">if</span> (ws == Node.SIGNAL)</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 前驱节点设置为SIGNAL状态，在释放锁的时候会唤醒后继节点，</span></span><br><span class="line"><span class="comment">         * 所以后继节点（也就是当前节点）现在可以阻塞自己。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (ws &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 前驱节点状态为取消,向前遍历，更新当前节点的前驱为往前第一个非取消节点。</span></span><br><span class="line"><span class="comment">         * 当前线程会之后会再次回到循环并尝试获取锁。</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            node.prev = pred = pred.prev;</span><br><span class="line">        &#125; <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>);</span><br><span class="line">        pred.next = node;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">         <span class="comment">/**</span></span><br><span class="line"><span class="comment">          * 等待状态为0或者PROPAGATE(-3)，设置前驱的等待状态为SIGNAL,</span></span><br><span class="line"><span class="comment">          * 并且之后会回到循环再次重试获取锁。</span></span><br><span class="line"><span class="comment">          */</span></span><br><span class="line">        compareAndSetWaitStatus(pred, ws, Node.SIGNAL);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 该方法实现某个node取消获取锁。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">cancelAcquire</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">if</span> (node == <span class="keyword">null</span>)</span><br><span class="line">       <span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">   node.thread = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 遍历并更新节点前驱，把node的prev指向前部第一个非取消节点。</span></span><br><span class="line">   Node pred = node.prev;</span><br><span class="line">   <span class="keyword">while</span> (pred.waitStatus &gt; <span class="number">0</span>)</span><br><span class="line">       node.prev = pred = pred.prev;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 记录pred节点的后继为predNext，后续CAS会用到。</span></span><br><span class="line">   Node predNext = pred.next;</span><br><span class="line"></span><br><span class="line">   <span class="comment">// 直接把当前节点的等待状态置为取消,后继节点即便也在cancel可以跨越node节点。</span></span><br><span class="line">   node.waitStatus = Node.CANCELLED;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/*</span></span><br><span class="line"><span class="comment">    * 如果CAS将tail从node置为pred节点了</span></span><br><span class="line"><span class="comment">    * 则剩下要做的事情就是尝试用CAS将pred节点的next更新为null以彻底切断pred和node的联系。</span></span><br><span class="line"><span class="comment">    * 这样一来就断开了pred与pred的所有后继节点，这些节点由于变得不可达，最终会被回收掉。</span></span><br><span class="line"><span class="comment">    * 由于node没有后继节点，所以这种情况到这里整个cancel就算是处理完毕了。</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * 这里的CAS更新pred的next即使失败了也没关系，说明有其它新入队线程或者其它取消线程更新掉了。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="keyword">if</span> (node == tail &amp;&amp; compareAndSetTail(node, pred)) &#123;</span><br><span class="line">       compareAndSetNext(pred, predNext, <span class="keyword">null</span>);</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// 如果node还有后继节点，这种情况要做的事情是把pred和后继非取消节点拼起来。</span></span><br><span class="line">       <span class="keyword">int</span> ws;</span><br><span class="line">       <span class="keyword">if</span> (pred != head &amp;&amp;</span><br><span class="line">           ((ws = pred.waitStatus) == Node.SIGNAL ||</span><br><span class="line">            (ws &lt;= <span class="number">0</span> &amp;&amp; compareAndSetWaitStatus(pred, ws, Node.SIGNAL))) &amp;&amp;</span><br><span class="line">           pred.thread != <span class="keyword">null</span>) &#123;</span><br><span class="line">           Node next = node.next;</span><br><span class="line">           <span class="comment">/* </span></span><br><span class="line"><span class="comment">            * 如果node的后继节点next非取消状态的话，则用CAS尝试把pred的后继置为node的后继节点</span></span><br><span class="line"><span class="comment">            * 这里if条件为false或者CAS失败都没关系，这说明可能有多个线程在取消，总归会有一个能成功的。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           <span class="keyword">if</span> (next != <span class="keyword">null</span> &amp;&amp; next.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">               compareAndSetNext(pred, predNext, next);</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">/*</span></span><br><span class="line"><span class="comment">            * 这时说明pred == head或者pred状态取消或者pred.thread == null</span></span><br><span class="line"><span class="comment">            * 在这些情况下为了保证队列的活跃性，需要去唤醒一次后继线程。</span></span><br><span class="line"><span class="comment">            * 举例来说pred == head完全有可能实际上目前已经没有线程持有锁了，</span></span><br><span class="line"><span class="comment">            * 自然就不会有释放锁唤醒后继的动作。如果不唤醒后继，队列就挂掉了。</span></span><br><span class="line"><span class="comment">            * </span></span><br><span class="line"><span class="comment">            * 这种情况下看似由于没有更新pred的next的操作，队列中可能会留有一大把的取消节点。</span></span><br><span class="line"><span class="comment">            * 实际上不要紧，因为后继线程唤醒之后会走一次试获取锁的过程，</span></span><br><span class="line"><span class="comment">            * 失败的话会走到shouldParkAfterFailedAcquire的逻辑。</span></span><br><span class="line"><span class="comment">            * 那里面的if中有处理前驱节点如果为取消则维护pred/next,踢掉这些取消节点的逻辑。</span></span><br><span class="line"><span class="comment">            */</span></span><br><span class="line">           unparkSuccessor(node);</span><br><span class="line">       &#125;</span><br><span class="line">       </span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">        * 取消节点的next之所以设置为自己本身而不是null,</span></span><br><span class="line"><span class="comment">        * 是为了方便AQS中Condition部分的isOnSyncQueue方法,</span></span><br><span class="line"><span class="comment">        * 判断一个原先属于条件队列的节点是否转移到了同步队列。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 因为同步队列中会用到节点的next域，取消节点的next也有值的话，</span></span><br><span class="line"><span class="comment">        * 可以断言next域有值的节点一定在同步队列上。</span></span><br><span class="line"><span class="comment">        *</span></span><br><span class="line"><span class="comment">        * 在GC层面，和设置为null具有相同的效果。</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       node.next = node; </span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 唤醒后继线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">    <span class="comment">// 尝试将node的等待状态置为0,这样的话,后继争用线程可以有机会再尝试获取一次锁。</span></span><br><span class="line">    <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">        compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    Node s = node.next;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 这里的逻辑就是如果node.next存在并且状态不为取消，则直接唤醒s即可</span></span><br><span class="line"><span class="comment">     * 否则需要从tail开始向前找到node之后最近的非取消节点。</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * 这里为什么要从tail开始向前查找也是值得琢磨的:</span></span><br><span class="line"><span class="comment">     * 如果读到s == null，不代表node就为tail，参考addWaiter以及enq函数中的我的注释。</span></span><br><span class="line"><span class="comment">     * 不妨考虑到如下场景：</span></span><br><span class="line"><span class="comment">     * 1. node某时刻为tail</span></span><br><span class="line"><span class="comment">     * 2. 有新线程通过addWaiter中的if分支或者enq方法添加自己</span></span><br><span class="line"><span class="comment">     * 3. compareAndSetTail成功</span></span><br><span class="line"><span class="comment">     * 4. 此时这里的Node s = node.next读出来s == null，但事实上node已经不是tail，它有后继了!</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">            <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                s = t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">        LockSupport.unpark(s.thread);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;AQS独占锁的获取的流程示意如下：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/AQS-exclusiveLock.png" alt="获取独占锁"></p><h3 id="4-3-释放独占锁的实现"><a href="#4-3-释放独占锁的实现" class="headerlink" title="4.3 释放独占锁的实现"></a>4.3 释放独占锁的实现</h3><p>&emsp;上面已经分析了acquire的实现，下面来看看release的实现：<br>对于释放一个独占锁，首先会调用tryRelease，在完全释放掉独占锁后，这时后继线程是可以获取到独占锁的，因此释放者线程需要做的事情是唤醒一个队列中的后继者线程，让它去尝试获取独占锁。</p><p>&emsp;上述所谓完全释放掉锁的含义，简单来说就是当前锁处于无主状态，等待线程有可能可以获取。<br>举例：对于可重入锁ReentrantLock, 每次tryAcquire后，state会+1，每次tryRelease后，state会-1，如果state变为0了，则此时称独占锁被完全释放了。</p><p>&emsp;下面，我们来看一下release的具体代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">         * 此时的head节点可能有3种情况:</span></span><br><span class="line"><span class="comment">         * 1. null (AQS的head延迟初始化+无竞争的情况)</span></span><br><span class="line"><span class="comment">         * 2. 当前线程在获取锁时new出来的节点通过setHead设置的</span></span><br><span class="line"><span class="comment">         * 3. 由于通过tryRelease已经完全释放掉了独占锁，有新的节点在acquireQueued中获取到了独占锁，并设置了head</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">         * 第三种情况可以再分为两种情况：</span></span><br><span class="line"><span class="comment">         * （一）时刻1:线程A通过acquireQueued，持锁成功，set了head</span></span><br><span class="line"><span class="comment">         *          时刻2:线程B通过tryAcquire试图获取独占锁失败失败，进入acquiredQueued</span></span><br><span class="line"><span class="comment">         *          时刻3:线程A通过tryRelease释放了独占锁</span></span><br><span class="line"><span class="comment">         *          时刻4:线程B通过acquireQueued中的tryAcquire获取到了独占锁并调用setHead</span></span><br><span class="line"><span class="comment">         *          时刻5:线程A读到了此时的head实际上是线程B对应的node</span></span><br><span class="line"><span class="comment">         * （二）时刻1:线程A通过tryAcquire直接持锁成功，head为null</span></span><br><span class="line"><span class="comment">         *          时刻2:线程B通过tryAcquire试图获取独占锁失败失败，入队过程中初始化了head，进入acquiredQueued</span></span><br><span class="line"><span class="comment">         *          时刻3:线程A通过tryRelease释放了独占锁，此时线程B还未开始tryAcquire</span></span><br><span class="line"><span class="comment">         *          时刻4:线程A读到了此时的head实际上是线程B初始化出来的傀儡head</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// head节点状态不会是CANCELLED，所以这里h.waitStatus != 0相当于h.waitStatus &lt; 0</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>)</span><br><span class="line">            <span class="comment">// 唤醒后继线程，此函数在acquire中已经分析过，不再列举说明</span></span><br><span class="line">            unparkSuccessor(h);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;整个release做的事情就是:</p><ol><li>调用tryRelease</li><li>如果tryRelease返回true也就是独占锁被完全释放，唤醒后继线程。</li></ol><p>&emsp;这里的唤醒是根据head几点来判断的，上面代码的注释中也分析了head节点的情况，只有在head存在并且等待状态小于零的情况下唤醒。</p><h3 id="4-4-获取共享锁的实现"><a href="#4-4-获取共享锁的实现" class="headerlink" title="4.4 获取共享锁的实现"></a>4.4 获取共享锁的实现</h3><p>&emsp;与获取独占锁的实现不同的关键在于，共享锁允许多个线程持有。如果需要使用AQS中共享锁，在实现tryAcquireShared方法时需要注意，返回负数表示获取失败;返回0表示成功，但是后继争用线程不会成功;返回正数表示获取成功，并且后继争用线程也可能成功。</p><p>&emsp;下面来看一下具体的代码实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>)</span><br><span class="line">        doAcquireShared(arg);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">    <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">            <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                <span class="comment">// 一旦共享获取成功，设置新的头结点，并且唤醒后继线程</span></span><br><span class="line">                <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    setHeadAndPropagate(node, r);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    <span class="keyword">if</span> (interrupted)</span><br><span class="line">                        selfInterrupt();</span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                parkAndCheckInterrupt())</span><br><span class="line">                interrupted = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (failed)</span><br><span class="line">            cancelAcquire(node);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这个函数做的事情有两件:</span></span><br><span class="line"><span class="comment"> * 1. 在获取共享锁成功后，设置head节点</span></span><br><span class="line"><span class="comment"> * 2. 根据调用tryAcquireShared返回的状态以及节点本身的等待状态来判断是否要需要唤醒后继线程。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 把当前的head封闭在方法栈上，用以下面的条件检查。</span></span><br><span class="line">    Node h = head;</span><br><span class="line">    setHead(node);</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * propagate是tryAcquireShared的返回值，这是决定是否传播唤醒的依据之一。</span></span><br><span class="line"><span class="comment">     * h.waitStatus为SIGNAL或者PROPAGATE时也根据node的下一个节点共享来决定是否传播唤醒，</span></span><br><span class="line"><span class="comment">     * 这里为什么不能只用propagate &gt; 0来决定是否可以传播在本文下面的思考问题中有相关讲述。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">        (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">            doReleaseShared();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 这是共享锁中的核心唤醒函数，主要做的事情就是唤醒下一个线程或者设置传播状态。</span></span><br><span class="line"><span class="comment"> * 后继线程被唤醒后，会尝试获取共享锁，如果成功之后，则又会调用setHeadAndPropagate,将唤醒传播下去。</span></span><br><span class="line"><span class="comment"> * 这个函数的作用是保障在acquire和release存在竞争的情况下，保证队列中处于等待状态的节点能够有办法被唤醒。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 以下的循环做的事情就是，在队列存在后继线程的情况下，唤醒后继线程；</span></span><br><span class="line"><span class="comment">     * 或者由于多线程同时释放共享锁由于处在中间过程，读到head节点等待状态为0的情况下，</span></span><br><span class="line"><span class="comment">     * 虽然不能unparkSuccessor，但为了保证唤醒能够正确稳固传递下去，设置节点状态为PROPAGATE。</span></span><br><span class="line"><span class="comment">     * 这样的话获取锁的线程在执行setHeadAndPropagate时可以读到PROPAGATE，从而由获取锁的线程去释放后继等待线程。</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        Node h = head;</span><br><span class="line">        <span class="comment">// 如果队列中存在后继线程。</span></span><br><span class="line">        <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">            <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">            <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                unparkSuccessor(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 如果h节点的状态为0，需要设置为PROPAGATE用以保证唤醒的传播。</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                     !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检查h是否仍然是head，如果不是的话需要再进行循环。</span></span><br><span class="line">        <span class="keyword">if</span> (h == head)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="4-5-释放共享锁的实现"><a href="#4-5-释放共享锁的实现" class="headerlink" title="4.5 释放共享锁的实现"></a>4.5 释放共享锁的实现</h3><p>&emsp;释放共享锁与获取共享锁的代码共享了doReleaseShared，用于实现唤醒的传播。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">releaseShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class="line">        <span class="comment">// doReleaseShared的实现上面获取共享锁已经介绍</span></span><br><span class="line">        doReleaseShared();</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;从中，我们可以看出，共享锁的获取和释放都会涉及到doReleaseShared,也就是后继线程的唤醒。关于PROPAGATE状态的必要性，后文会作进一步介绍。</p><h2 id="5-一些思考"><a href="#5-一些思考" class="headerlink" title="5. 一些思考"></a>5. 一些思考</h2><p>&emsp;AQS的代码实在是很精妙，要看懂大致套路并不困难，但是要完全领悟其中的一些细节是一件需要花功夫来仔细琢磨品味的事情。</p><p>&emsp;下面列出一些看源码时的问题与思考:</p><h3 id="5-1-插入节点时的代码顺序"><a href="#5-1-插入节点时的代码顺序" class="headerlink" title="5.1 插入节点时的代码顺序"></a>5.1 插入节点时的代码顺序</h3><p>&emsp;addWaiter和enq方法中新增一个节点时为什么要先将新节点的prev置为tail再尝试CAS，而不是CAS成功后来构造节点之间的双向链接?<br>&emsp;这是因为，双向链表目前没有基于CAS原子插入的手段，如果我们将node.prev = t和t.next = node（t为方法执行时读到的tail，引用封闭在栈上）<br>&emsp;放到compareAndSetTail(t, node)成功后执行，如下所示：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (compareAndSetTail(t, node)) &#123;</span><br><span class="line">   node.prev = t;</span><br><span class="line">   t.next = node;</span><br><span class="line">   <span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>会导致这一瞬间的tail也就是t的prev为null，这就使得这一瞬间队列处于一种不一致的中间状态。</p><h3 id="5-2-唤醒节点时为什么从tail向前遍历"><a href="#5-2-唤醒节点时为什么从tail向前遍历" class="headerlink" title="5.2 唤醒节点时为什么从tail向前遍历"></a>5.2 唤醒节点时为什么从tail向前遍历</h3><p>&emsp;unparkSuccessor方法中为什么唤醒后继节点时要从tail向前查找最接近node的非取消节点，而不是直接从node向后找到第一个后break掉?</p><p>&emsp;在上面的代码注释中已经提及到这一点：如果读到s == null，不代表node就为tail。<br>&emsp;考虑如下场景：node某时刻为tail,有新线程通过addWaiter中的if分支或者enq方法添加自己,compareAndSetTail成功。此时这里的Node s = node.next读出来s == null，但事实上node已经不是tail，它有后继了!</p><h3 id="5-3-unparkSuccessor有新线程争锁是否存在漏洞"><a href="#5-3-unparkSuccessor有新线程争锁是否存在漏洞" class="headerlink" title="5.3 unparkSuccessor有新线程争锁是否存在漏洞"></a>5.3 unparkSuccessor有新线程争锁是否存在漏洞</h3><p>&emsp;unparkSuccessor方法在被release调用时是否存在这样的一个漏洞?</p><ul><li>时刻1: node -&gt; tail &amp;&amp; tail.waitStatus == Node.CANCELLED (node的下一个节点为tail，并且tail处于取消状态)</li><li>时刻2: unparkSuccessor读到s.waitStatus &gt; 0</li><li>时刻3: unparkSuccessor从tail开始遍历</li><li>时刻4: tail节点对应线程执行cancelAcquire方法中的if (node == tail &amp;&amp; compareAndSetTail(node, pred)) 返回true,此时tail变为pred(也就是node)</li><li>时刻5: 有新线程进队列tail变为新节点</li><li>时刻6: unparkSuccessor没有发现需要唤醒的节点</li></ul><p>&emsp;最终新节点阻塞并且前驱节点结束调用，新节点再也无法被unpark这种情况不会发生,确实可能出现从tail向前扫描，没有读到新入队的节点，但别忘了acquireQueued的思想就是不断循环检测是否能够独占获取锁，否则再进行判断是否要阻塞自己，而release的第一步就是tryRelease，它的语义为true表示完全释放独占锁，完全释放之后才会执行后面的逻辑，也就是unpark后继线程。在这种情况下，新入队的线程应当能获取到锁。如果没有获取锁，则必然是在覆盖tryAcquire/tryRelease的实现有问题，导致前驱节点成功释放了独占锁，后继节点获取独占锁仍然失败。也就是说AQS框架的可靠性还在某些程度上依赖于具体子类的实现，子类实现如果有bug，那AQS再精巧也扛不住。</p><h3 id="5-4-AQS如何保证队列活跃"><a href="#5-4-AQS如何保证队列活跃" class="headerlink" title="5.4 AQS如何保证队列活跃"></a>5.4 AQS如何保证队列活跃</h3><p>&emsp;AQS如何保证在节点释放的同时又有新节点入队的情况下，不出现原持锁线程释放锁，后继线程被自己阻塞死的情况,保持同步队列的活跃？<br>&emsp;回答这个问题，需要理解shouldParkAfterFailedAcquire和unparkSuccessor这两个方法。以独占锁为例，后继争用线程阻塞自己的情况是读到前驱节点的等待状态为SIGNAL,只要不是这种情况都会再试着去争取锁。假设后继线程读到了前驱状态为SIGNAL，说明之前在tryAcquire的时候，前驱持锁线程还没有tryRelease完全释放掉独占锁。此时如果前驱线程完全释放掉了独占锁，则在unparkSuccessor中还没执行完置waitStatus为0的操作，也就是还没执行到下面唤醒后继线程的代码，否则后继线程会再去争取锁。那么就算后继争用线程此时把自己阻塞了，也一定会马上被前驱线程唤醒。<br>&emsp;那么是否可能持锁线程执行唤醒后继线程的逻辑时，后继线程读到前驱等待状态为SIGNAL把自己给阻塞，再也无法苏醒呢？这个问题在上面的问题3中已经有答案了，确实可能在扫描后继需要唤醒线程时读不到新来的线程，但只要tryRelease语义实现正确，在true时表示完全释放独占锁，<br>则后继线程理应能够tryAcquire成功，shouldParkAfterFailedAcquire在读到前驱状态不为SIGNAL会给当前线程再一次获取锁的机会的。<br>&emsp;别看AQS代码写的有些复杂，状态有些多，还真的就是没毛病，各种情况都能覆盖。</p><h3 id="5-5-PROPAGATE状态存在的意义"><a href="#5-5-PROPAGATE状态存在的意义" class="headerlink" title="5.5 PROPAGATE状态存在的意义"></a>5.5 PROPAGATE状态存在的意义</h3><p>&emsp;在setHeadAndPropagate中我们可以看到如下的一段代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">       (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">       Node s = node.next;</span><br><span class="line">       <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">           doReleaseShared();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;为什么不只是用propagate &gt; 0来判断呢？我们知道目前AQS代码中的Node.PROPAGATE状态就是为了此处可以读取到h.waitStatus &lt; 0（PROPAGATE值为-3）；如果这里可以只用propagate &gt; 0来判断，是否PROPAGATE状态都没有存在的必要了？</p><p>&emsp;我接触JAVA比较晚，接触的时候就已经是JDK8的年代了。这个问题我思考了很久，没有想到很合理的解释来说明PROPAGATE状态存在的必要性。在网上也鲜少有相关方面的资料、博客提及到这些。后来通过浏览Doug Lea的个人网站，发现在很久以前AQS的代码确实是没有PROPAGATE的，PROPAGATE的引入是为了解决共享锁并发释放导致的线程hang住问题。</p><p>&emsp;在Doug Lea的JSR 166 repository上，我找到了PROPAGATE最早被引入的那一版。可以看到Revision1.73中，PROPAGATE状态被引入用以修复bug 6801020,让我们来看看这个bug:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.Semaphore;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestSemaphore</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> Semaphore sem = <span class="keyword">new</span> Semaphore(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread1</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           sem.acquireUninterruptibly();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Thread2</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line">       <span class="meta">@Override</span></span><br><span class="line">       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">           sem.release();</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10000000</span>; i++) &#123;</span><br><span class="line">           Thread t1 = <span class="keyword">new</span> Thread1();</span><br><span class="line">           Thread t2 = <span class="keyword">new</span> Thread1();</span><br><span class="line">           Thread t3 = <span class="keyword">new</span> Thread2();</span><br><span class="line">           Thread t4 = <span class="keyword">new</span> Thread2();</span><br><span class="line">           t1.start();</span><br><span class="line">           t2.start();</span><br><span class="line">           t3.start();</span><br><span class="line">           t4.start();</span><br><span class="line">           t1.join();</span><br><span class="line">           t2.join();</span><br><span class="line">           t3.join();</span><br><span class="line">           t4.join();</span><br><span class="line">           System.out.println(i);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;很显然，这段程序一定能执行结束的，但是会偶现线程hang住的问题。<br>&emsp;当时的AQS中setHeadAndPropagate是这样的:<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/javabug6801020.png" alt="bug 6801020"><br>&emsp;以上是bug 6801020修复点的对比，左边为修复之前的版本，右边为引入PROPAGATE修复之后的版本。</p><p>&emsp;从左边可以看到原先的setHeadAndPropagate相比目前版本要简单很多，而releaseShared的实现也与release基本雷同，这也正是本问题的核心：为什么仅仅用调用的tryAcquireShared<br>得到的返回值来判断是否需要唤醒不行呢？</p><p>&emsp;在PROPAGATE状态出现之前的源码可以<a href="http://gee.cs.oswego.edu/cgi-bin/viewcvs.cgi/jsr166/src/main/java/util/concurrent/locks/AbstractQueuedSynchronizer.java?revision=1.73&amp;view=markup" target="_blank" rel="noopener">在这里查看</a>。</p><h4 id="5-5-1-分析"><a href="#5-5-1-分析" class="headerlink" title="5.5.1 分析"></a>5.5.1 分析</h4><p>&emsp;让我们来分析一下上面的程序：</p><p>&emsp;上面的程序循环中做的事情就是放出4个线程，其中2个线程用于获取信号量，另外2个用于释放信号量。每次循环主线程会等待所有子线程执行完毕。出现bug也就是线程hang住的问题就在于两个获取信号量的线程有一个会没办法被唤醒，队列就死掉了。</p><p>&emsp;在AQS的共享锁中，一个被park的线程，不考虑线程中断和前驱节点取消的情况，有两种情况可以被unpark：一种是其他线程释放信号量，调用unparkSuccessor；另一种是其他线程获取共享锁时通过传播机制来唤醒后继节点。</p><p>&emsp;我们假设某次循环中队列里排队的节点为情况为:<br>&emsp;head -&gt; t1的node -&gt; t2的node(也就是tail)</p><p>&emsp;信号量释放的顺序为t3先释放，t4后释放:</p><ul><li>时刻1: t3调用releaseShared，调用了unparkSuccessor(h)，head的等待状态从-1变为0</li><li>时刻2: t1由于t3释放了信号量，被t3唤醒，调用Semaphore.NonfairSync的tryAcquireShared，返回值为0</li><li>时刻3: t4调用releaseShared,读到此时h.waitStatus为0(此时读到的head和时刻1中为同一个head)，不满足条件,因此不会调用unparkSuccessor(h)</li><li>时刻4: t1获取信号量成功，调用setHeadAndPropagate时，因为不满足propagate &gt; 0（时刻2的返回值也就是propagate==0）,从而不会唤醒后继节点</li></ul><p>&emsp;这就好比是一个精巧的多米诺骨牌最终由于设计的失误导致动力无法传递下去，至此AQS中的同步队列宣告死亡。</p><p>&emsp;那么引入PROPAGATE是怎么解决问题的呢？<br>&emsp;引入之后，调用releaseShared方法不再简单粗暴地直接unparkSuccessor,而是将传播行为抽了一个doReleaseShared方法出来。<br>&emsp;再看上面的那种情况:</p><ul><li>时刻1：t3调用releaseShared -&gt; doReleaseShared -&gt; unparkSuccessor，完了之后head的等待状态为0</li><li>时刻2：t1由于t3释放了信号量，被t3唤醒，调用Semaphore.NonfairSync的tryAcquireShared，返回值为0</li><li>时刻3：t4调用releaseShared,读到此时h.waitStatus为0(此时读到的head和时刻1中为同一个head)，将等待状态置为PROPAGATE</li><li>时刻4：t1获取信号量成功，调用setHeadAndPropagate时，可以读到h.waitStatus &lt; 0，从而可以接下来调用doReleaseShared唤醒t2</li></ul><p>&emsp;也就是说，上面会产生线程hang住bug的case在引入PROPAGATE后可以被规避掉。在PROPAGATE引入之前，之所以可能会出现线程hang住的情况，就是在于releaseShared有竞争的情况下，可能会有队列中处于等待状态的节点因为第一个线程完成释放唤醒，第二个线程获取到锁，但还没设置好head，又有新线程释放锁，但是读到老的head状态为0导致释放但不唤醒，最终后一个等待线程既没有被释放线程唤醒，也没有被持锁线程唤醒。<br>&emsp;所以，仅仅靠tryAcquireShared的返回值来决定是否要将唤醒传递下去是不充分的。</p><h3 id="5-6-AQS如何防止内存泄露"><a href="#5-6-AQS如何防止内存泄露" class="headerlink" title="5.6 AQS如何防止内存泄露"></a>5.6 AQS如何防止内存泄露</h3><p>&emsp;AQS维护了一个FIFO队列，它是如何保证在运行期间不发生内存泄露的？<br>AQS在无竞争条件下，甚至都不会new出head和tail节点。线程成功获取锁时设置head节点的方法为setHead，由于头节点的thread并不重要，此时会置node的thread和prev为null，完了之后还会置原先head也就是线程对应node的前驱的next为null，从而实现队首元素的安全移出。而在取消节点时，也会令node.thread = null，在node不为tail的情况下，会使node.next = node（之所以这样也是为了isOnSyncQueue实现更加简洁）。</p><h2 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h2><p>&emsp;AQS毫无疑问是Doug Lea大师令人叹为观止的作品，它实现精巧、鲁棒、优雅，很好地封装了同步状态的管理、线程的等待与唤醒，足以满足大多数同步工具的需求。<br>阅读AQS的源码不是一蹴而就就能完全读懂的，阅读源码大致分为三步：</p><ul><li>读懂大概思路以及一些重要方法之间的调用关系</li><li>逐行看代码的具体实现，知道每一段代码是干什么的</li><li>琢磨参悟某一段代码为什么是这么写的，能否换一种写法，能否前后几行代码调换顺序，作者是怎么想的</li></ul><p>&emsp;从Doug Lea大师的论文中，我们也能够看出他设计并实现了AQS本身一方面是本人功力深厚，另一方面也阅读了大量的文献与资料，也做了很多方面的测试。<br>&emsp;读AQS最难的地方不在于明白套路和思路，而在于代码中点点滴滴的细节。从一行行的代码角度来说，比如改一个值，是否需要CAS，是否一定要CAS成功；读一个值，在多线程环境下含义是什么，有哪些种情况。从一个个方法角度来说，这些方法的调用关系是如何保证框架的正确性、鲁棒性、伸缩性等。<br>如果能把这些细节都想清楚，明白作者的思路与考虑，才可以源码理解入木三分了。</p><p>&emsp;对于PROPAGATE状态，网上大多AQS的介绍也都只是浅显地提及是用来设置传播的，缺少对于这个状态存在必要性的思考。一开始我也想了很久不明白为什么一定需要一个PROPAGATE状态而不是直接根据tryAcquireShared的返回值来判断是否需要传播。后来也是去了Doug Lea的个人网站翻出当时最早引入PROPAGATE状态的提交，看到了原来的代码，以及 <a href="http://bugs.java.com/" target="_blank" rel="noopener">http://bugs.java.com/</a> 上的bug才更厘清PROPAGATE状态引入的前因后果。</p><p>&emsp;尽管看懂源码，也可能远远达不到能再造一个能与之媲美的轮子的程度，但是能对同步框架、锁、线程等有更深入的理解，也是很丰硕的收获了。<br>&emsp;当然，AQS也有其局限性，由于维护的是FIFO队列。如果想要实现一个具有优先级的锁，AQS就派不上什么用处了。</p><h2 id="7-参考"><a href="#7-参考" class="headerlink" title="7. 参考"></a>7. 参考</h2><p>Doug Lea的AQS论文:<a href="http://gee.cs.oswego.edu/dl/papers/aqs.pdf" target="_blank" rel="noopener">《The Art of Multiprocessor Programming(多处理器编程的艺术)》</a></p><p>&nbsp;<br>&nbsp;</p><blockquote><p>原文链接：<a href="https://www.cnblogs.com/micrari/p/6937995.html" target="_blank" rel="noopener">https://www.cnblogs.com/micrari/p/6937995.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 之 原子操作类</title>
      <link href="/java/java-atomicOperationClass/"/>
      <url>/java/java-atomicOperationClass/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-并发包中的原子操作类"><a href="#Java-并发包中的原子操作类" class="headerlink" title="Java 并发包中的原子操作类"></a>Java 并发包中的原子操作类</h1><h2 id="1-原子变量操作类"><a href="#1-原子变量操作类" class="headerlink" title="1. 原子变量操作类"></a>1. 原子变量操作类</h2><p>&emsp;JUC 并发包中包含有 Atomiclnteger、AtomicLong 和 AtomicBoolean 等原子性操作类,本文以 AtomicLong 类为例，AtomicLong 是原子性递增或者递减类,其内部使用 Unsafe 来实现,我们看下面的代码：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AtomicLong</span> <span class="keyword">extends</span> <span class="title">Number</span> <span class="keyword">implements</span> <span class="title">java</span>.<span class="title">io</span>.<span class="title">Serializable</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">1927816293512124184L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// setup to use Unsafe.compareAndSwapLong for updates</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">boolean</span> VM_SUPPORTS_LONG_CAS = VMSupportsCS8();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">native</span> <span class="keyword">boolean</span> <span class="title">VMSupportsCS8</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AtomicLong</span><span class="params">(<span class="keyword">long</span> initialValue)</span> </span>&#123;</span><br><span class="line">        value = initialValue;</span><br><span class="line">    &#125;</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><br>&emsp;在<a href="http://zhoujiapeng.top/java/java-unsafe">《Java 并发编程 之 Unsafe 类解析》</a>文章中介绍过，并不是所有的类内部都可以通过 Unsafe.getUnsafe() 来获取 Unsafe 的实例，这里可以这样做是因为 AtomicLong 是在 rt.jar 包下面，是通过 BootStrap 类加载器进行加载的。<br>&emsp;下面看一下 AtomicLong 中的主要函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//调用unsafe方法，原子性设置value值为原始值+1，返回值为递增后的值</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">incrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>) + <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">decrementAndGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, -<span class="number">1L</span>) - <span class="number">1L</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndIncrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, <span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndDecrement</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> unsafe.getAndAddLong(<span class="keyword">this</span>, valueOffset, -<span class="number">1L</span>);</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><br>&emsp;AtomicLong 没有使用 synchronized 或其它锁机制来实现同步，这些都是阻塞算法，对性能有一定的损耗，而是使用 CAS 非阻塞算法，但是在高并发情况下还是会存在一定的问题。<br>&emsp;我们先来看一下 getAndIncrement 方法，它调用了 unsafe.getAndAddLong 方法，我们来看一下这个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndAddLong</span><span class="params">(Object var1, <span class="keyword">long</span> var2, <span class="keyword">long</span> var4)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> var6;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            var6 = <span class="keyword">this</span>.getLongVolatile(var1, var2);</span><br><span class="line">        &#125; <span class="keyword">while</span>(!<span class="keyword">this</span>.compareAndSwapLong(var1, var2, var6, var6 + var4));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> var6;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里使用了 CAS <strong>自旋</strong>操作来设置新值，跟<a href="http://zhoujiapeng.top/java/java-threadLocalRandom/#1-random">《Java 并发编程 之 ThreadLocalRandom》</a>文章中讲到的 Random 类的局限性类似，如果大量线程同时调用这个方法，<strong>大量线程进行自旋重试,这会降低并发性能</strong>，JDK8 提供了一个在高并发下性能更好的 LongAdder 类。</p><h2 id="2-JDK8-新增的原子操作类-LongAdder"><a href="#2-JDK8-新增的原子操作类-LongAdder" class="headerlink" title="2. JDK8 新增的原子操作类 LongAdder"></a>2. JDK8 新增的原子操作类 LongAdder</h2><p>&emsp;既然 AtomicLong 的性能瓶颈是由于过多线程同时去竞争一个变量的更新而产生的,那么如果把一个变量分解为多个变量,让同样多的线程去竞争多个资源,是不是就解决了性能问题？是的,LongAdder 就是这个思路。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/AtomicLong.png" alt="AtomicLong"><br>&emsp;如图，AtomicLong 多个线程同时竞争同一个原子变量。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/LongAdder.png" alt="LongAdder"><br>&emsp;使用 LongAdder 时,则是在内部维护多个 Cell 变量,每个 Cell 里面有一个初始值为 0 的long型变量,这样,在同等并发量的情况下,争夺单个变量更新操作的线程量会减少,这变相地减少了争夺共享资源的并发量。另外,多个线程在争夺同一个 Cell 原子变量时如果失败了,它并不是在当前 Cell 变量上一直自旋 CAS 重试,而是尝试在其他 Cell 的变量上进行 CAS 尝试 ,这个改变增加了当前线程重试 CAS 成功的可能性。最后,在获取 LongAdder 当前值时, 是把所有 Cell 变量的 value 值累加后再加上 base 返回的。</p><p>&emsp;LongAdder 继承了 Striped64，base 和 Cell 是封装在 Striped64 里面的，我们首先看一下 Cell 的结构：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended <span class="keyword">static</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Cell</span> </span>&#123;</span><br><span class="line">        <span class="keyword">volatile</span> <span class="keyword">long</span> value;</span><br><span class="line">        Cell(<span class="keyword">long</span> x) &#123; value = x; &#125;</span><br><span class="line">        <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">cas</span><span class="params">(<span class="keyword">long</span> cmp, <span class="keyword">long</span> val)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> UNSAFE.compareAndSwapLong(<span class="keyword">this</span>, valueOffset, cmp, val);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Unsafe mechanics</span></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">                Class&lt;?&gt; ak = Cell<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">                valueOffset = UNSAFE.objectFieldOffset</span><br><span class="line">                    (ak.getDeclaredField(<span class="string">"value"</span>));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;Cell 类的结构很简单，就是封装了一个 long 类型的 value，以及对这个 value的 CAS 操作，保证对 value 操作的原子性。注意这里使用 @sun.misc.Contended 注解对 Cell 类进行字节填充，这防止了 Cell[] 数组中多个元素共享一个缓存行,在性能上是一个提升。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sum</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line">        <span class="keyword">long</span> sum = base;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    sum += a.value;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;sum()返回当前的值,内部操作是累加所有 Cell 内部的 value 值后再累加 base。由于计算总和时没有对 Cell 数组进行加锁,所以在累加过程中可能有其他线程对 Cell中的值进行了修改,也有可能对数组进行了扩容,所以<strong>sum返回的值并不是非常精确</strong>的, 其返回值并不是一个调用 sum 方法时的原子快照值。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line">        base = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>)</span><br><span class="line">                    a.value = <span class="number">0L</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">sumThenReset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Cell[] as = cells; Cell a;</span><br><span class="line">        <span class="keyword">long</span> sum = base;</span><br><span class="line">        base = <span class="number">0L</span>;</span><br><span class="line">        <span class="keyword">if</span> (as != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; as.length; ++i) &#123;</span><br><span class="line">                <span class="keyword">if</span> ((a = as[i]) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    sum += a.value;</span><br><span class="line">                    a.value = <span class="number">0L</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;reset和sumThenReset的实现比较简单，我们来看一下最关键的 add 方法的实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;<span class="comment">//(1)</span></span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> || <span class="comment">//(2)</span></span><br><span class="line">                (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> || <span class="comment">//(3)</span></span><br><span class="line">                !(uncontended = a.cas(v = a.value, v + x))) <span class="comment">//(4)</span></span><br><span class="line">                longAccumulate(x, <span class="keyword">null</span>, uncontended); <span class="comment">//(5)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;代码(1)首先看 cells 是否为空，如果为空，则在 base 上进行累加，如果 cells 不为空或者在 base 上累加失败则执行根据(2)(3)决定应该访问 cells 数组里面的哪一个 cell 元素。(2)的意思是判断 cells 数组是否为空，以及它的长度，如果不为空且长度至少为1，也就是 cells 存在，则判断(3)，(3)根据当前 cells 的长度决定应该访问cells 数组里面的哪一个 cell 元素(getProbe() &amp; m)，(4) 则是对这个 Cell 元素执行 CAS 操作进行累加。如果执行失败，则需要调用 longAccumulate 函数，这是 Cells 数组被初始化和扩容的地方。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//(1)初始化当前线程的变量 LocalRandomProbe 的值</span></span><br><span class="line">        <span class="keyword">int</span> h;</span><br><span class="line">        <span class="keyword">if</span> ((h = getProbe()) == <span class="number">0</span>) &#123;</span><br><span class="line">            ThreadLocalRandom.current(); <span class="comment">// force initialization</span></span><br><span class="line">            h = getProbe();</span><br><span class="line">            wasUncontended = <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">boolean</span> collide = <span class="keyword">false</span>;                <span class="comment">// True if last slot nonempty</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Cell[] as; Cell a; <span class="keyword">int</span> n; <span class="keyword">long</span> v;</span><br><span class="line">            <span class="comment">//(2)cells不为空</span></span><br><span class="line">            <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> &amp;&amp; (n = as.length) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                <span class="comment">//(2.1)如果当前线程对应的 cell 不存在，则创建</span></span><br><span class="line">                <span class="keyword">if</span> ((a = as[(n - <span class="number">1</span>) &amp; h]) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (cellsBusy == <span class="number">0</span>) &#123;       <span class="comment">// Try to attach new Cell</span></span><br><span class="line">                        Cell r = <span class="keyword">new</span> Cell(x);   <span class="comment">// Optimistically create</span></span><br><span class="line">                        <span class="comment">//新建cell元素，需要调用casCellsBusy将cellsBusy标志设置为1</span></span><br><span class="line">                        <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                            <span class="keyword">boolean</span> created = <span class="keyword">false</span>;</span><br><span class="line">                            <span class="keyword">try</span> &#123;               <span class="comment">// Recheck under lock</span></span><br><span class="line">                                Cell[] rs; <span class="keyword">int</span> m, j;</span><br><span class="line">                                <span class="keyword">if</span> ((rs = cells) != <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">                                    (m = rs.length) &gt; <span class="number">0</span> &amp;&amp;</span><br><span class="line">                                    rs[j = (m - <span class="number">1</span>) &amp; h] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                                    rs[j] = r;</span><br><span class="line">                                    created = <span class="keyword">true</span>;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                                cellsBusy = <span class="number">0</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                            <span class="keyword">if</span> (created)</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            <span class="keyword">continue</span>;           <span class="comment">// Slot is now non-empty</span></span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; </span><br><span class="line">                    <span class="comment">//cellsBusy当前忙，但是不会冲突，循环重试</span></span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!wasUncontended)       <span class="comment">// CAS already known to fail</span></span><br><span class="line">                    wasUncontended = <span class="keyword">true</span>;      <span class="comment">// Continue after rehash</span></span><br><span class="line">                <span class="comment">//(2.2)当前Cell存在，执行CAS进行累加</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (a.cas(v = a.value, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                             fn.applyAsLong(v, x))))</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="comment">//(2.3)累加失败，如果当前cell数组元素个数大于CPU个数，说明不会发生冲突，循环重试</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (n &gt;= NCPU || cells != as)</span><br><span class="line">                    collide = <span class="keyword">false</span>;            <span class="comment">// At max size or stale</span></span><br><span class="line">                <span class="comment">//(2.4)当前cells的元素小于当前机器CPU个数，会发生冲突</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (!collide)</span><br><span class="line">                    collide = <span class="keyword">true</span>;</span><br><span class="line">                <span class="comment">//有冲突，即当前cells的元素小于当前机器CPU个数，并且当前多个线程访问了cells同一个元素</span></span><br><span class="line">                <span class="comment">//如果Cell数组个数没有达到CPU个数并且有冲突则扩容</span></span><br><span class="line">                <span class="comment">//(2.5)如果会发生冲突，则进行 Cell 数组扩容</span></span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        <span class="keyword">if</span> (cells == as) &#123;      <span class="comment">// Expand table unless stale</span></span><br><span class="line">                            <span class="comment">//扩充为两倍</span></span><br><span class="line">                            Cell[] rs = <span class="keyword">new</span> Cell[n &lt;&lt; <span class="number">1</span>];</span><br><span class="line">                            <span class="comment">//拷贝原来的值</span></span><br><span class="line">                            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i)</span><br><span class="line">                                rs[i] = as[i];</span><br><span class="line">                            cells = rs;</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">//重置标志</span></span><br><span class="line">                        cellsBusy = <span class="number">0</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    collide = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">continue</span>;                   <span class="comment">// Retry with expanded table</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//h的改变会改变当前线程对应访问的cell位置</span></span><br><span class="line">                h = advanceProbe(h);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//(3)cells为空，初始化 cell 数组</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (cellsBusy == <span class="number">0</span> &amp;&amp; cells == as &amp;&amp; casCellsBusy()) &#123;</span><br><span class="line">                <span class="keyword">boolean</span> init = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;                           <span class="comment">// Initialize table</span></span><br><span class="line">                    <span class="keyword">if</span> (cells == as) &#123;</span><br><span class="line">                        <span class="comment">//初始化 cells数组长度为 2</span></span><br><span class="line">                        Cell[] rs = <span class="keyword">new</span> Cell[<span class="number">2</span>];</span><br><span class="line">                        <span class="comment">//h = getProbe()，计算当前线程应该访问cell数组哪个位置</span></span><br><span class="line">                        rs[h &amp; <span class="number">1</span>] = <span class="keyword">new</span> Cell(x);</span><br><span class="line">                        cells = rs;</span><br><span class="line">                        <span class="comment">//标志已经初始化</span></span><br><span class="line">                        init = <span class="keyword">true</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    <span class="comment">//重置 cellsBusy 标志，不需要 cas操作，因为 cellsBusy 是 volatile 类型</span></span><br><span class="line">                    cellsBusy = <span class="number">0</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (init)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                        fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;LongAdder 维护了一个延迟初始化的原子性更新数组(默认情况 下 Cell 数组是 null〕和一个基值变量 base 。由于 Cells 占用的内存是相对比较大的,所以一开始并不创建它,而是在需要时创建,也就是惰性加载。当一开始判断 Cell 数组是 null 并且并发线程较少时,所有的累加操作都是对 base 变量进行的 。保持 Cell 数组的大小为 2 的N次方,在初始化时 Cell 数组中的 Cell 元素个数为2。<br>&emsp;longAccumulate 方法的基本思路为：</p><ul><li>(1)初始化当前线程的变量 LocalRandomProbe 的值</li><li>循环<ul><li>(2)如果cells不为空<ul><li>(2.1)如果当前线程对应的 cell 不存在，则创建</li><li>(2.2)如果当前Cell存在，执行CAS进行累加</li><li>(2.3)如果累加失败，如果当前cell数组元素个数大于CPU个数，说明不会发生冲突，循环重试</li><li>(2.4)如果当前cells的元素小于当前机器CPU个数，会发生冲突</li><li>(2.5)如果会发生冲突，则进行 Cell 数组扩容</li></ul></li><li>(3)cells为空，初始化 cell 数组</li></ul></li></ul><p>&emsp;需要注意的是，在进行 Cell 数组初始化和扩容的时候，需要调用 casCellsBusy 将 cellsBusy 标志设置为1，防止多个线程同时初始化或扩容。</p><p>&emsp;总结一下，LongAdder 类通过内部 cells 数组分担了高并发下多线程同时对一个原子变量进行更新时的竞争量,让多个线程可以同时对 cells 数组里面的元素进行并行的更新操作。另外,数组元素 Cell 使用 @sun.misc.Contended 注解进行修饰,这避免了 cells 数组内多个原子变量被放入同一个缓存行,也就是避免了伪共享,这对性能也是一个提升。</p><h2 id="3-LongAccumulator-类"><a href="#3-LongAccumulator-类" class="headerlink" title="3. LongAccumulator 类"></a>3. LongAccumulator 类</h2><p>&emsp;LongAdder 类是 LongAccumulator 的一个特例,LongAccumulator 比 LongAdder 的功能更强大。看一下它的构造函数：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">LongAccumulator</span><span class="params">(LongBinaryOperator accumulatorFunction,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">long</span> identity)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.function = accumulatorFunction;</span><br><span class="line">        base = <span class="keyword">this</span>.identity = identity;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;identity 其实就是 base 值，LongBinaryOperator 可以传入一个累加规则，LongBinaryOperator 是一个接口，只定义了一个方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FunctionalInterface</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">LongBinaryOperator</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;调用 LongAdder 就相当于使用下面的方式调用 LongAccumulator：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">LongAdder adder = <span class="keyword">new</span> LongAdder();</span><br><span class="line">LongAccumulator accumulator = <span class="keyword">new</span> LongAccumulator(<span class="keyword">new</span> LongBinaryOperator() &#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">long</span> <span class="title">applyAsLong</span><span class="params">(<span class="keyword">long</span> left, <span class="keyword">long</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> left + right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;,<span class="number">0</span>);</span><br></pre></td></tr></table></figure><br>&emsp;LongAdder 的 add 方法相当于 LongAccumulator 的 accumulate 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LongAdder.add</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> || !casBase(b = base, b + x)) &#123;<span class="comment">//(1)</span></span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> || <span class="comment">//(2)</span></span><br><span class="line">                (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> || <span class="comment">//(3)</span></span><br><span class="line">                !(uncontended = a.cas(v = a.value, v + x))) <span class="comment">//(4)</span></span><br><span class="line">                longAccumulate(x, <span class="keyword">null</span>, uncontended); <span class="comment">//(5)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//LongAccumulator.accumulate</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">accumulate</span><span class="params">(<span class="keyword">long</span> x)</span> </span>&#123;</span><br><span class="line">        Cell[] as; <span class="keyword">long</span> b, v, r; <span class="keyword">int</span> m; Cell a;</span><br><span class="line">        <span class="keyword">if</span> ((as = cells) != <span class="keyword">null</span> ||</span><br><span class="line">            (r = function.applyAsLong(b = base, x)) != b &amp;&amp; !casBase(b, r)) &#123;</span><br><span class="line">            <span class="keyword">boolean</span> uncontended = <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (as == <span class="keyword">null</span> || (m = as.length - <span class="number">1</span>) &lt; <span class="number">0</span> ||</span><br><span class="line">                (a = as[getProbe() &amp; m]) == <span class="keyword">null</span> ||</span><br><span class="line">                !(uncontended =</span><br><span class="line">                  (r = function.applyAsLong(v = a.value, x)) == v ||</span><br><span class="line">                  a.cas(v, r)))</span><br><span class="line">                longAccumulate(x, function, uncontended);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;对比可以发现，这两个方法基本上是一致的，唯一不同的是，add 方法的累加规则默认使用 b+x，而 accumulate 调用的是 LongBinaryOperator.applyAsLong，<br>我们可以看一下 longAccumulate 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">longAccumulate</span><span class="params">(<span class="keyword">long</span> x, LongBinaryOperator fn,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">boolean</span> wasUncontended)</span> </span>&#123;</span><br><span class="line">        ...</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (casBase(v = base, ((fn == <span class="keyword">null</span>) ? v + x :</span><br><span class="line">                                        fn.applyAsLong(v, x))))</span><br><span class="line">                <span class="keyword">break</span>;                          <span class="comment">// Fall back on using base</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;可以看到，如果 LongBinaryOperator 参数为 null，则默认使用 v+x 规则，否则调用 fn.applyAsLong。</p><p>&emsp;总结一下，LongAdder 类是 LongAccumulator 的一个特例,只是后者提供了更加强大的功能, 可以让用户自定义累加规则。</p><h2 id="4-解决CAS自旋在高并发情况下的性能问题的思路比较"><a href="#4-解决CAS自旋在高并发情况下的性能问题的思路比较" class="headerlink" title="4. 解决CAS自旋在高并发情况下的性能问题的思路比较"></a>4. 解决CAS自旋在高并发情况下的性能问题的思路比较</h2><p>&emsp;在<a href="http://zhoujiapeng.top/java/java-threadLocalRandom">《Java 并发编程 之 ThreadLocalRandom》</a>文章中以及本文都有提到，使用 CAS 自旋来设置变量的值可以避免加锁和线程调度的开销，但这可能导致大量线程进行自旋重试,从而降低并发性能。对此，ThreadLocalRandom 和 LongAdder 都有自己的解决方法，我们来对比一下：</p><ul><li>ThreadLocalRandom 的方法是让每一个线程都维护自己随机数种子，而生成随机数的算法是线程无关的，从而实现每个线程可以在不加锁的情况下随意调用随机数生成方法。</li><li>LongAdder 的情况和 ThreadLocalRandom 不同的是，LongAdder 的 value 值是需要对所有线程共享的，所以不可能让每一个线程独自维护一个 value，它的方法是在内部维护多个 Cell 变量，多个线程对 value 的 CAS 操作可以分散到多个 Cell 变量上，减少了争夺共享资源的并发量，最后,在获取 LongAdder 当前值时, 是把所有 Cell 变量的 value 值累加后再加上 base 返回。</li></ul><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br>《Java并发编程之美》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 之 ThreadLocalRandom</title>
      <link href="/java/java-threadLocalRandom/"/>
      <url>/java/java-threadLocalRandom/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-并发编程-之-ThreadLocalRandom"><a href="#Java-并发编程-之-ThreadLocalRandom" class="headerlink" title="Java 并发编程 之 ThreadLocalRandom"></a>Java 并发编程 之 ThreadLocalRandom</h1><h2 id="1-Random-类及其局限性"><a href="#1-Random-类及其局限性" class="headerlink" title="1. Random 类及其局限性"></a>1. Random 类及其局限性</h2><p>&emsp;java.util.Random 是使用比较广泛的随机数生成工具类，而且 java.lang.Math 中的随机数也是使用 java.util.Random 的实例。我们看一下 Random 的 nextInt 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//参数检查</span></span><br><span class="line">        <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//1.根据老的种子生成新的种子</span></span><br><span class="line">        <span class="keyword">int</span> r = next(<span class="number">31</span>);</span><br><span class="line">        <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//2.根据新的种子计算随机数</span></span><br><span class="line">        <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>)  <span class="comment">// i.e., bound is a power of 2</span></span><br><span class="line">            r = (<span class="keyword">int</span>)((bound * (<span class="keyword">long</span>)r) &gt;&gt; <span class="number">31</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = r;</span><br><span class="line">                 u - (r = u % bound) + m &lt; <span class="number">0</span>;</span><br><span class="line">                 u = next(<span class="number">31</span>))</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;由此可见，新的随机数的生成需要两个步骤</p><ul><li>首先根据老的种子生成新的种子</li><li>根据新的种子来计算新的随机数</li></ul><p>&emsp;我们看一下这里的 next 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">next</span><span class="params">(<span class="keyword">int</span> bits)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> oldseed, nextseed;</span><br><span class="line">        AtomicLong seed = <span class="keyword">this</span>.seed;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            oldseed = seed.get();</span><br><span class="line">            nextseed = (oldseed * multiplier + addend) &amp; mask;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!seed.compareAndSet(oldseed, nextseed));</span><br><span class="line">        <span class="keyword">return</span> (<span class="keyword">int</span>)(nextseed &gt;&gt;&gt; (<span class="number">48</span> - bits));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;在 next 方法里面，使用 CAS 操作，使用新的种子去更新老的种子，因此这里是线程安全的。但是，如果多个线程同时执行到 compareAndSet 函数这里，CAS 操作会保证只有一个线程可以更新种子，失败的线程会通过循环重新获取更新后的种子作为当前种子去<br>计算老的种子,保证了随机数的随机性。<br>&emsp;总结:每个 Random 实例里面都有一个原子性的种子变量用来记录当前的种子值,当要生成新的随机数时需 要根据当前种子计算新的种子并更新回原子变量。在多线程下使用单个 Random 实例生成随机数时,当多个线程同时计算随机数来计算新的种子时, 多个线程会竞争同一个原子变量的更新操作,由于原子变量的更新是 CAS 操作,同时只有一个线程会成功,所以会造成<strong>大量线程进行自旋重试,这会降低并发性能</strong>,所以 ThreadLocalRandom 应运而生。</p><h2 id="2-ThreadLocalRandom"><a href="#2-ThreadLocalRandom" class="headerlink" title="2. ThreadLocalRandom"></a>2. ThreadLocalRandom</h2><p>&emsp;为了弥补多线程高并发情况下 Random 的缺陷 , 在且 JUC 包下新增了 ThreadLocalRandom类,下面首先看下如何使用它：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadLocalRandomTest</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        ThreadLocalRandom random = ThreadLocalRandom.current();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            System.out.println(random.nextInt(<span class="number">5</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;Random 的缺点是多个线程会使用同一个原子性种子变量, 从而导致对原子变量更新的竞争。ThreadLocalRandom 的原理是让<strong>每个线程都维护一个种子变量</strong>,则每个线程生成随机数时都根据自己老的种子计算新的种子,并使用新种子更新老的种子,再根据新种子计算随机数,就不会存在竞争问题了,这会大大提高并发性能。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/ThreadLocalRandom.png?raw=true" alt="ThreadLocalRandom"></p><p>&emsp;下面从源码具体分析一下。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadLocalRandom.java</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> sun.misc.Unsafe UNSAFE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SEED;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> PROBE;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> SECONDARY;</span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            UNSAFE = sun.misc.Unsafe.getUnsafe();</span><br><span class="line">            Class&lt;?&gt; tk = Thread<span class="class">.<span class="keyword">class</span></span>;</span><br><span class="line">            SEED = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">"threadLocalRandomSeed"</span>));</span><br><span class="line">            PROBE = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">"threadLocalRandomProbe"</span>));</span><br><span class="line">            SECONDARY = UNSAFE.objectFieldOffset</span><br><span class="line">                (tk.getDeclaredField(<span class="string">"threadLocalRandomSecondarySeed"</span>));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里的 SEED 是代表 Thread 类里面 threadLocalRandomSeed 变量的偏移量，Unsafe可以通过这个偏移量来获取到储存在每个 Thread 实例中的 seed，而 threadLocalRandomProbe 在这里是用来判断是否初始化使用的，在其它地方会有其他用途（如 <a href="http://zhoujiapeng.top/java/java-atomicOperationClass">LongAdder</a> 类中用来决定应该访问cells数组的哪个元素）。<br>&emsp;下面是获取 ThreadLocalRandom 实例的 current() 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">final</span> ThreadLocalRandom instance = <span class="keyword">new</span> ThreadLocalRandom();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ThreadLocalRandom <span class="title">current</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (UNSAFE.getInt(Thread.currentThread(), PROBE) == <span class="number">0</span>)</span><br><span class="line">            localInit();</span><br><span class="line">        <span class="keyword">return</span> instance;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">localInit</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> p = probeGenerator.addAndGet(PROBE_INCREMENT);</span><br><span class="line">        <span class="keyword">int</span> probe = (p == <span class="number">0</span>) ? <span class="number">1</span> : p; <span class="comment">// skip 0</span></span><br><span class="line">        <span class="keyword">long</span> seed = mix64(seeder.getAndAdd(SEEDER_INCREMENT));</span><br><span class="line">        Thread t = Thread.currentThread();</span><br><span class="line">        UNSAFE.putLong(t, SEED, seed);</span><br><span class="line">        UNSAFE.putInt(t, PROBE, probe);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;注意这里的 instance 是 static 的一个 ThreadLocalRandom 实例，current 方法返回的是 instance。因此当多线程通过 current 方法获取 ThreadLocalRandom 实例的时候其实获取到的是同一个实例。由于具体的 seed 是放在线程里面的，ThreadLocalRandom 的实例里面只包含与线程无关的通用算法，所以它是线程安全的。<br>&emsp;默认情况下，Thread 里面的 threadLocalRandomProbe 变量值是0，如果判断这个值为0，则说明当前线程是第一次调用 ThreadLocalRandom 的 current 方法，那么需要调用 localInit 方法进行初始化。这里使用了延迟初始化，在不需要使用随机数功能的时候就不初始化 Thread 里面的种子变量，这是一种优化。<br>&emsp;接下来看一下获取随机数的 next 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">nextInt</span><span class="params">(<span class="keyword">int</span> bound)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//参数检验</span></span><br><span class="line">        <span class="keyword">if</span> (bound &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(BadBound);</span><br><span class="line">        <span class="comment">//1.根据当前线程中的种子计算新种子</span></span><br><span class="line">        <span class="keyword">int</span> r = mix32(nextSeed());</span><br><span class="line">        <span class="comment">//2.根据新种子计算随机数</span></span><br><span class="line">        <span class="keyword">int</span> m = bound - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> ((bound &amp; m) == <span class="number">0</span>) <span class="comment">// power of two</span></span><br><span class="line">            r &amp;= m;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">// reject over-represented candidates</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> u = r &gt;&gt;&gt; <span class="number">1</span>;</span><br><span class="line">                 u + m - (r = u % bound) &lt; <span class="number">0</span>;</span><br><span class="line">                 u = mix32(nextSeed()) &gt;&gt;&gt; <span class="number">1</span>)</span><br><span class="line">                ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;生成随机数的逻辑和 Random 类似，我们重点看一下生成新种子的 nextSeed 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">long</span> <span class="title">nextSeed</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t; <span class="keyword">long</span> r; <span class="comment">// read and update per-thread seed</span></span><br><span class="line">        UNSAFE.putLong(t = Thread.currentThread(), SEED,</span><br><span class="line">                       r = UNSAFE.getLong(t, SEED) + GAMMA);</span><br><span class="line">        <span class="keyword">return</span> r;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;上面代码使用 r = UNSAFE.getLong(t, SEED) 获取当前线程中的 threadLocalRandomSeed 变量的值，然后在种子的基础上累加 GAMMA 值作为新的种子重新放回 threadLocalRandomSeed 中，这里不会涉及多线程竞争的问题。</p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><p>&emsp;本文首先讲解了 Random 的实现原理以及 Random 在多线程下需要竞争种子原子变量更新操作的缺点,从而引出 ThreadLocalRandom 类。ThreadLoca!Random 使用 ThreadLocal 的原理,让每个线程都持有一个本地的种子变量,该种子变量只有在使用随机数时才会被<br>初始化。在多线程下计算新种子时是根据自己线程内维护的种子变量进行更新,从而避免了竞争。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br>《Java并发编程之美》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Scala 强大的集合操作</title>
      <link href="/scala/scala-operation/"/>
      <url>/scala/scala-operation/</url>
      
        <content type="html"><![CDATA[<h1 id="Scala-强大的集合操作"><a href="#Scala-强大的集合操作" class="headerlink" title="Scala 强大的集合操作"></a>Scala 强大的集合操作</h1><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><ul><li>map<a href="f: (A">B</a> ⇒ B): List[B]<br>定义一个变换,把该变换应用到列表的每个元素中,原列表不变，返回一个新的列表数据<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> text = <span class="type">List</span>(<span class="string">"Homeway,23,Male"</span>,<span class="string">"Jpne,23,Female"</span>)</span><br><span class="line"><span class="comment">//map</span></span><br><span class="line"><span class="keyword">val</span> userList = text.map(line =&gt; &#123;</span><br><span class="line">    <span class="keyword">val</span> fields = line.split(<span class="string">","</span>)</span><br><span class="line">    (fields(<span class="number">0</span>),fields(<span class="number">1</span>),fields(<span class="number">2</span>))</span><br><span class="line">&#125;)</span><br><span class="line">println(userList)</span><br><span class="line"></span><br><span class="line">=&gt; <span class="type">List</span>((<span class="type">Homeway</span>,<span class="number">23</span>,<span class="type">Male</span>), (<span class="type">Jpne</span>,<span class="number">23</span>,<span class="type">Female</span>))</span><br></pre></td></tr></table></figure></li></ul><h3 id="flatten"><a href="#flatten" class="headerlink" title="flatten"></a>flatten</h3><ul><li>flatten[B]: List[B]<br>对列表的列表进行平坦化操作 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> textFlatten = <span class="type">List</span>(<span class="string">"Homeway,23,Male"</span>,<span class="string">"Jpne,23,Female"</span>).map(_.split(<span class="string">","</span>).toList).flatten</span><br><span class="line">println(textFlatten)</span><br><span class="line"></span><br><span class="line">=&gt; <span class="type">List</span>(<span class="type">Homeway</span>, <span class="number">23</span>, <span class="type">Male</span>, <span class="type">Jpne</span>, <span class="number">23</span>, <span class="type">Female</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap"></a>flatMap</h3><ul><li>flatMap : flatMap<a href="f: (A">B</a> ⇒ GenTraversableOnce[B]): List[B]<br>map之后对结果进行flatten，定义一个变换f, 把f应用列表的每个元素中，每个f返回一个列表，最终把所有列表连结起来。<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> userFlatMap = <span class="type">List</span>(<span class="string">"Homeway,23,Male"</span>,<span class="string">"Jpne,23,Female"</span>).flatMap(_.split(<span class="string">","</span>))</span><br><span class="line">println(userFlatMap)</span><br><span class="line"></span><br><span class="line">=&gt; <span class="type">List</span>(<span class="type">Homeway</span>, <span class="number">23</span>, <span class="type">Male</span>, <span class="type">Jpne</span>, <span class="number">23</span>, <span class="type">Female</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="reduce，reduceLeft，reduceRight"><a href="#reduce，reduceLeft，reduceRight" class="headerlink" title="reduce，reduceLeft，reduceRight"></a>reduce，reduceLeft，reduceRight</h3><ul><li>reduce<a href="op: (A1, A1">A1 &gt;: A</a> ⇒ A1): A1<br>定义一个变换f, f把两个列表的元素合成一个，遍历列表，最终把列表合并成单一元素<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> sums = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).reduce((a,b) =&gt; a+b)</span><br><span class="line">println(sums)</span><br><span class="line"></span><br><span class="line">=&gt; <span class="number">10</span></span><br></pre></td></tr></table></figure></li><li>reduceLeft: reduceLeft<a href="f: (B, A">B &gt;: A</a> ⇒ B): B<br>从列表的左边往右边应用reduce函数<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reduceLeft</span></span><br><span class="line"><span class="keyword">val</span> sums1 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).reduceLeft((a,b) =&gt; &#123;</span><br><span class="line">    println((a,b))</span><br><span class="line">    a+b</span><br><span class="line">&#125;)</span><br><span class="line">println(sums1)</span><br><span class="line"></span><br><span class="line">(<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">3</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">6</span>,<span class="number">4</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></li><li>reduceRight: reduceRight<a href="op: (A, B">B &gt;: A</a> ⇒ B): B<br>从列表的右边往左边应用reduce函数<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reduceRight</span></span><br><span class="line"><span class="keyword">val</span> sums2 = <span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).reduceRight((a,b) =&gt; &#123;</span><br><span class="line">    println((a,b))</span><br><span class="line">    a+b</span><br><span class="line">&#125;)</span><br><span class="line">println(sums2)</span><br><span class="line"></span><br><span class="line">(<span class="number">3</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">7</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="number">9</span>)</span><br><span class="line"><span class="number">10</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="fold，foldleft，foldRight"><a href="#fold，foldleft，foldRight" class="headerlink" title="fold，foldleft，foldRight"></a>fold，foldleft，foldRight</h3><ul><li>fold: fold<a href="z: A1">A1 &gt;: A</a>(op: (A1, A1) ⇒ A1) A1<br>带有初始值的reduce,从一个初始值开始，从左向右将两个元素合并成一个，最终把列表合并成单一元素。<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).fold(<span class="number">-1</span>)((a,b) =&gt; &#123;</span><br><span class="line">      println(a,b)</span><br><span class="line">      a+b</span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">9</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure></li><li>foldLeft: foldLeft<a href="z: B">B</a>(f: (B, A) ⇒ B)<br>B 带有初始值的reduceLeft<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).foldLeft(<span class="number">-1</span>)((a,b) =&gt; &#123;</span><br><span class="line">      println(a,b)</span><br><span class="line">      a+b</span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">(<span class="number">-1</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="number">0</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">5</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">9</span>,<span class="number">5</span>)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure></li><li>foldRight: foldRight<a href="z: B">B</a>(op: (A, B) ⇒ B)<br>B 带有初始值的reduceRight<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).foldRight(<span class="number">-1</span>)((a,b) =&gt; &#123;</span><br><span class="line">      println(a,b)</span><br><span class="line">      a+b</span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">(<span class="number">5</span>,<span class="number">-1</span>)</span><br><span class="line">(<span class="number">4</span>,<span class="number">4</span>)</span><br><span class="line">(<span class="number">3</span>,<span class="number">8</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">11</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="number">13</span>)</span><br><span class="line"><span class="number">14</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="sortBy-sortWith-sorted"><a href="#sortBy-sortWith-sorted" class="headerlink" title="sortBy,sortWith,sorted"></a>sortBy,sortWith,sorted</h3><ul><li>sortBy: sortBy<a href="f: (A">B</a> ⇒ B)(implicit ord: math.Ordering[B]): List[A]<br>按照应用函数f之后产生的元素进行排序<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> users = <span class="type">List</span>((<span class="string">"aa"</span>,<span class="number">22</span>),(<span class="string">"bb"</span>,<span class="number">66</span>),(<span class="string">"cc"</span>,<span class="number">44</span>),(<span class="string">"dd"</span>,<span class="number">34</span>),(<span class="string">"ee"</span>,<span class="number">11</span>))</span><br><span class="line">println(users.sortBy(&#123;<span class="keyword">case</span>(name,age) =&gt; age&#125;))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>((ee,<span class="number">11</span>), (aa,<span class="number">22</span>), (dd,<span class="number">34</span>), (cc,<span class="number">44</span>), (bb,<span class="number">66</span>))</span><br></pre></td></tr></table></figure></li><li>sorted： sorted<a href="implicit ord: math.Ordering[B]">B &gt;: A</a>: List[A]<br>按照元素自身进行排序<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">2</span>,<span class="number">4</span>,<span class="number">1</span>,<span class="number">6</span>,<span class="number">-1</span>).sorted)</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">-1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></li><li>sortWith： sortWith(lt: (A, A) ⇒ Boolean): List[A]<br>使用自定义的比较函数进行排序<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(users.sortWith(&#123;<span class="keyword">case</span>(user1,user2) =&gt; user1._2 &gt; user2._2&#125;))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>((bb,<span class="number">66</span>), (cc,<span class="number">44</span>), (dd,<span class="number">34</span>), (aa,<span class="number">22</span>), (ee,<span class="number">11</span>))</span><br></pre></td></tr></table></figure></li></ul><h3 id="filter-filterNot"><a href="#filter-filterNot" class="headerlink" title="filter,filterNot"></a>filter,filterNot</h3><ul><li>filter: filter(p: (A) ⇒ Boolean): List[A]<br>保留列表中符合条件p的列表元素<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>).filter(_%<span class="number">2</span>==<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></li><li>filterNot: filterNot(p: (A) ⇒ Boolean): List[A]<br>保留列表中不符合条件p的列表元素<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>).filterNot(_%<span class="number">2</span>==<span class="number">0</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="count"><a href="#count" class="headerlink" title="count"></a>count</h3><ul><li>count(p: (A) ⇒ Boolean): Int<br>计算列表中所有满足条件p的元素的个数，等价于 filter(p).length<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>).count(_&gt;<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="number">3</span></span><br></pre></td></tr></table></figure></li></ul><h3 id="diff-union-intersect"><a href="#diff-union-intersect" class="headerlink" title="diff, union, intersect"></a>diff, union, intersect</h3><ul><li>diff:diff(that: collection.Seq[A]): List[A]<br>保存列表中那些不在另外一个列表中的元素，即从集合中减去与另外一个集合的交集<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).diff(<span class="type">List</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li>union : union(that: collection.Seq[A]): List[A]<br>与另外一个列表进行连结<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).union(<span class="type">List</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).++(<span class="type">List</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></li><li>intersect: intersect(that: collection.Seq[A]): List[A]<br>与另外一个集合的交集<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>).intersect(<span class="type">List</span>(<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct"></a>distinct</h3><ul><li>distinct: List[A]<br>保留列表中非重复的元素，相同的元素只会被保留一次<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">6</span>).distinct)</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="groupBy-grouped"><a href="#groupBy-grouped" class="headerlink" title="groupBy,grouped"></a>groupBy,grouped</h3><ul><li>groupBy : groupBy<a href="f: (A">K</a> ⇒ K): Map[K, List[A]]<br>将列表进行分组，分组的依据是应用f在元素上后产生的新元素<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>((<span class="string">"John"</span>,<span class="string">"Man"</span>),(<span class="string">"Li"</span>,<span class="string">"Feman"</span>),(<span class="string">"Fed"</span>,<span class="string">"Man"</span>),(<span class="string">"Ka"</span>,<span class="string">"Feman"</span>)).groupBy(_._2))</span><br><span class="line"></span><br><span class="line"><span class="type">Map</span>(<span class="type">Man</span> -&gt; <span class="type">List</span>((<span class="type">John</span>,<span class="type">Man</span>), (<span class="type">Fed</span>,<span class="type">Man</span>)), <span class="type">Feman</span> -&gt; <span class="type">List</span>((<span class="type">Li</span>,<span class="type">Feman</span>), (<span class="type">Ka</span>,<span class="type">Feman</span>)))</span><br></pre></td></tr></table></figure></li><li>grouped: grouped(size: Int): Iterator[List[A]]<br>按列表按照固定的大小进行分组<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>((<span class="string">"John"</span>,<span class="string">"Man"</span>),(<span class="string">"Li"</span>,<span class="string">"Feman"</span>),(<span class="string">"Fed"</span>,<span class="string">"Man"</span>),(<span class="string">"Ka"</span>,<span class="string">"Feman"</span>)).grouped(<span class="number">1</span>).foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>((<span class="type">John</span>,<span class="type">Man</span>), (<span class="type">Li</span>,<span class="type">Feman</span>))</span><br><span class="line"><span class="type">List</span>((<span class="type">Fed</span>,<span class="type">Man</span>), (<span class="type">Ka</span>,<span class="type">Feman</span>))</span><br></pre></td></tr></table></figure></li></ul><h3 id="scan，scanLeft-scanRight"><a href="#scan，scanLeft-scanRight" class="headerlink" title="scan，scanLeft,scanRight"></a>scan，scanLeft,scanRight</h3><ul><li>scan<a href="z: B">B &gt;: A, That</a>(op: (B, B) ⇒ B)(implicit cbf: CanBuildFrom[List[A], B, That]): That<br>由一个初始值开始，从左向右，进行积累的op操作，和fold函数类似，区别在于，fold的结果只有最终的累加值，而scan的结果包含每一次累加的值<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).scan(<span class="number">10</span>)((x,y)=&gt;&#123;</span><br><span class="line">      println((x,y))</span><br><span class="line">      x+y</span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">(<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">13</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">16</span>,<span class="number">4</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></li><li>scanLeft: scanLeft<a href="z: B">B, That</a>(op: (B, A) ⇒ B)(implicit bf: CanBuildFrom[List[A], B, That]): That<br>从左向右进行scan函数的操作<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).scanLeft(<span class="number">10</span>)((x,y)=&gt;&#123;</span><br><span class="line">      println((x,y))</span><br><span class="line">      x+y</span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">(<span class="number">10</span>,<span class="number">1</span>)</span><br><span class="line">(<span class="number">11</span>,<span class="number">2</span>)</span><br><span class="line">(<span class="number">13</span>,<span class="number">3</span>)</span><br><span class="line">(<span class="number">16</span>,<span class="number">4</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">10</span>, <span class="number">11</span>, <span class="number">13</span>, <span class="number">16</span>, <span class="number">20</span>)</span><br></pre></td></tr></table></figure></li><li>scanRight: scanRight<a href="z: B">B, That</a>(op: (A, B) ⇒ B)(implicit bf: CanBuildFrom[List[A], B, That]): That<br>从右向左进行scan函数的操作<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).scanRight(<span class="number">10</span>)((x,y)=&gt;&#123;</span><br><span class="line">      println((x,y))</span><br><span class="line">      x+y</span><br><span class="line">    &#125;))</span><br><span class="line"></span><br><span class="line">(<span class="number">4</span>,<span class="number">10</span>)</span><br><span class="line">(<span class="number">3</span>,<span class="number">14</span>)</span><br><span class="line">(<span class="number">2</span>,<span class="number">17</span>)</span><br><span class="line">(<span class="number">1</span>,<span class="number">19</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">20</span>, <span class="number">19</span>, <span class="number">17</span>, <span class="number">14</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="take-takeRight-takeWhile"><a href="#take-takeRight-takeWhile" class="headerlink" title="take,takeRight,takeWhile"></a>take,takeRight,takeWhile</h3><ul><li>take : take(n: Int): List[A]<br>提取列表的前n个元素 <figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).take(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li><li>takeRight: takeRight(n: Int): List[A]<br>提取列表的最后n个元素<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).takeRight(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li><li>takeWhile: takeWhile(p: (A) ⇒ Boolean): List[A]<br>从左向右提取列表的元素，直到条件p不成立(遍历过程只要遇到一个不成立就停止)<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).takeWhile(_ &lt; <span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="drop-dropRight-dropWhile"><a href="#drop-dropRight-dropWhile" class="headerlink" title="drop,dropRight,dropWhile"></a>drop,dropRight,dropWhile</h3><ul><li>drop: drop(n: Int): List[A]<br>丢弃前n个元素，返回剩下的元素<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).drop(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>)</span><br></pre></td></tr></table></figure></li><li>dropRight: dropRight(n: Int): List[A]<br>丢弃最后n个元素，返回剩下的元素<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).dropRight(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br></pre></td></tr></table></figure></li><li>dropWhile: dropWhile(p: (A) ⇒ Boolean): List[A]<br>从左向右丢弃元素，直到条件p不成立<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>).dropWhile(_&lt;<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="span-splitAt-partition"><a href="#span-splitAt-partition" class="headerlink" title="span,splitAt,partition"></a>span,splitAt,partition</h3><ul><li>span : span(p: (A) ⇒ Boolean): (List[A], List[A])<br>从左向右应用条件p进行判断，直到条件p不成立(只要遇到一个不成立就停止)，此时将列表分为两个列表<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">1</span>).span(_==<span class="number">1</span>))</span><br><span class="line"></span><br><span class="line">(<span class="type">List</span>(<span class="number">1</span>, <span class="number">1</span>),<span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">1</span>))</span><br></pre></td></tr></table></figure></li><li>splitAt: splitAt(n: Int): (List[A], List[A])<br>将列表分为前n个，与，剩下的部分<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>).splitAt(<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line">(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),<span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>))</span><br></pre></td></tr></table></figure></li><li>partition: partition(p: (A) ⇒ Boolean): (List[A], List[A])<br>将列表分为两部分，第一部分为满足条件p的元素，第二部分为不满足条件p的元素，注意和span的区别，partition会对每个元素应用判断条件<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">4</span>,<span class="number">2</span>).partition(_==<span class="number">2</span>))</span><br><span class="line"></span><br><span class="line">(<span class="type">List</span>(<span class="number">2</span>, <span class="number">2</span>),<span class="type">List</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>))</span><br></pre></td></tr></table></figure></li></ul><h3 id="padTo"><a href="#padTo" class="headerlink" title="padTo"></a>padTo</h3><ul><li>padTo(len: Int, elem: A): List[A]<br>将列表扩展到指定长度，长度不够的时候，使用elem进行填充，否则不做任何操作。<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).padTo(<span class="number">7</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">10</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="combinations-permutations"><a href="#combinations-permutations" class="headerlink" title="combinations,permutations"></a>combinations,permutations</h3><ul><li>combinations: combinations(n: Int): Iterator[List[A]]<br>取列表中的n个元素进行组合，返回<strong>不重复</strong>的组合列表，结果一个迭代器<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>).combinations(<span class="number">2</span>).foreach(println)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>).combinations(<span class="number">3</span>).foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br></pre></td></tr></table></figure></li><li>permutations: permutations: Iterator[List[A]]<br>对列表中的元素进行排列，返回<strong>不重复</strong>的排列列表，结果是一个迭代器<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">List</span>(<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>,<span class="number">4</span>).permutations.foreach(println)</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">4</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">3</span>, <span class="number">1</span>, <span class="number">4</span>, <span class="number">1</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">3</span>, <span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">3</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">4</span>, <span class="number">1</span>, <span class="number">3</span>, <span class="number">1</span>)</span><br><span class="line"><span class="type">List</span>(<span class="number">4</span>, <span class="number">3</span>, <span class="number">1</span>, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="zip-zipAll-zipWithIndex-unzip-unzip3"><a href="#zip-zipAll-zipWithIndex-unzip-unzip3" class="headerlink" title="zip, zipAll, zipWithIndex, unzip,unzip3"></a>zip, zipAll, zipWithIndex, unzip,unzip3</h3><ul><li>zip: zip<a href="that: GenIterable[B]">B</a>: List[(A, B)]<br>与另外一个列表进行拉链操作，将对应位置的元素组成一个pair，返回的列表长度为两个列表中短的那个<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).zip(<span class="type">List</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>)))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>((<span class="number">1</span>,a), (<span class="number">2</span>,b), (<span class="number">3</span>,c), (<span class="number">4</span>,d))</span><br></pre></td></tr></table></figure></li><li>zipAll: zipAll<a href="that: collection.Iterable[B], thisElem: A, thatElem: B">B</a>: List[(A, B)]<br>与另外一个列表进行拉链操作，将对应位置的元素组成一个pair，若列表长度不一致，自身列表比较短的话使用thisElem进行填充，对方列表较短的话使用thatElem进行填充<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).zipAll(<span class="type">List</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>,<span class="string">"d"</span>,<span class="string">"e"</span>),<span class="number">0</span>,<span class="string">"y"</span>))</span><br><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>).zipAll(<span class="type">List</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>),<span class="number">0</span>,<span class="string">"y"</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>((<span class="number">1</span>,a), (<span class="number">2</span>,b), (<span class="number">3</span>,c), (<span class="number">4</span>,d), (<span class="number">0</span>,e))</span><br><span class="line"><span class="type">List</span>((<span class="number">1</span>,a), (<span class="number">2</span>,b), (<span class="number">3</span>,c), (<span class="number">4</span>,y))</span><br></pre></td></tr></table></figure></li><li>zipWithIndex：zipWithIndex: List[(A, Int)]<br>将列表元素与其索引进行拉链操作，组成一个pair<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="string">"a"</span>,<span class="string">"b"</span>,<span class="string">"c"</span>).zipWithIndex)</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>((a,<span class="number">0</span>), (b,<span class="number">1</span>), (c,<span class="number">2</span>))</span><br></pre></td></tr></table></figure></li><li>unzip: unzip<a href="implicit asPair: (A">A1, A2</a> ⇒ (A1, A2)): (List[A1], List[A2])<br>解开拉链操作<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>((<span class="number">1</span>,<span class="string">"a"</span>),(<span class="number">2</span>,<span class="string">"b"</span>),(<span class="number">3</span>,<span class="string">"c"</span>)).unzip)</span><br><span class="line"></span><br><span class="line">(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),<span class="type">List</span>(a, b, c))</span><br></pre></td></tr></table></figure></li><li>unzip3: unzip3<a href="implicit asTriple: (A">A1, A2, A3</a> ⇒ (A1, A2, A3)): (List[A1], List[A2], List[A3])<br>3个元素的解拉链操作<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>((<span class="number">1</span>,<span class="string">"a"</span>,<span class="string">"x"</span>),(<span class="number">2</span>,<span class="string">"b"</span>,<span class="string">"y"</span>),(<span class="number">3</span>,<span class="string">"c"</span>,<span class="string">"z"</span>)).unzip3)</span><br><span class="line"></span><br><span class="line">(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>),<span class="type">List</span>(a, b, c),<span class="type">List</span>(x, y, z))</span><br></pre></td></tr></table></figure></li></ul><h3 id="slice"><a href="#slice" class="headerlink" title="slice"></a>slice</h3><ul><li>slice(from: Int, until: Int): List[A]<br>提取列表中从位置from到位置until(不含该位置)的元素列表<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>).slice(<span class="number">1</span>,<span class="number">3</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure></li></ul><h3 id="sliding"><a href="#sliding" class="headerlink" title="sliding"></a>sliding</h3><ul><li>sliding(size: Int, step: Int): Iterator[List[A]]<br>将列表按照固定大小size进行分组，步进为step，step默认为1,返回结果为迭代器<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>).sliding(<span class="number">2</span>,<span class="number">3</span>).toList)</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>), <span class="type">List</span>(<span class="number">4</span>, <span class="number">5</span>), <span class="type">List</span>(<span class="number">7</span>, <span class="number">8</span>))</span><br></pre></td></tr></table></figure></li></ul><h3 id="updated"><a href="#updated" class="headerlink" title="updated"></a>updated</h3><ul><li>updated(index: Int, elem: A): List[A]<br>对列表中的某个元素进行更新操作<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">println(<span class="type">List</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>).updated(<span class="number">2</span>,<span class="number">10</span>))</span><br><span class="line"></span><br><span class="line"><span class="type">List</span>(<span class="number">1</span>, <span class="number">2</span>, <span class="number">10</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>)</span><br></pre></td></tr></table></figure></li></ul><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br>《Scala 编程实战》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 之 Unsafe 类解析</title>
      <link href="/java/java-unsafe/"/>
      <url>/java/java-unsafe/</url>
      
        <content type="html"><![CDATA[<h1 id="Unsafe-类解析"><a href="#Unsafe-类解析" class="headerlink" title="Unsafe 类解析"></a>Unsafe 类解析</h1><h2 id="1-CAS-操作"><a href="#1-CAS-操作" class="headerlink" title="1. CAS 操作"></a>1. CAS 操作</h2><p>&emsp;Java中的锁提供给我们一种创建原子操作的方法，但是会导致线程上下文的切换和重新调度开销。Java 提供了非阻塞的 volatile 关键字来解决共享变量的可见性问题,这在一定程度上弥补了锁带来的开销问题,但是 volatile 只能保证共享变量的可见性,不能解决读改一写等的原子性问题。<br>&emsp;CAS 即 Compare and Swap,其是 JDK 提供的非阻塞原子性操作,它通过<strong>硬件</strong>保证了比较更新操作的原子性。JDK 里面的 Unsafe 类提供了一系列的 compareAndSwap<em>方法,下面以 compareAndSwapLong 方法为例进行简单介绍：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">compareAndSwapLong</span><span class="params">(Object obj, <span class="keyword">long</span> valueOffset, <span class="keyword">long</span> expect, <span class="keyword">long</span> update)</span></span>;</span><br></pre></td></tr></table></figure><br>&emsp;compareAndSwap 的意思是比较并交换。CAS 有四个操作数,分别为:对象内存位置、对象中的变量的偏移量、变量预期值和新的值。其操作含义是,如果对象 obj 中内存偏移量为 valueOffset 的变量值为 expect ,则 使用新的值 update 替换旧的值 expect。这是处理器提供的一个<strong>原子性</strong>指令。<br>&emsp;由于在调用 compareAndSwapLong 之前我们需要先获取变量的原有值，这中间就产生了一个时间窗口，会引发CAS操作中经典的<em>*ABA</em></em>问题。举例来说:假如线程 I 使用 CAS 修改初始值为 A 的变量X,那么线程 I 会首先去获取当前变量 X 的值(为 A〕,然后使用 CAS 操作尝试修改 X 的值为 B , 如果使用 CAS 操作成功了, 那么程序运行一定是正确的吗 ?其实未必,这是因为有可能在线程 I 获取变量 X 的值 A 后,在执行 CAS 前,线程 II 使用 CAS 修改了 变量 X 的值为 B ,然后又使用 CAS 修改了变量 X 的值为 A 。所以虽然线程 I 执行CAS时 X 的值是 A , 但是这个 A 己经不是线程 I 获取时的 A 了。这就是ABA问题 。ABA 问题的产生是因为变量的状态值产生了环形转换,就是变量的值可以从A到B,然后再从B到A。如果变量的值只能朝着一个方向转换 ,比如A到B,B到C, 不构成环形,就不会存在问题。JDK 中的 AtomicStampedReference 类给每个变量的状态值都配备了一个时间戳, 从而避免了 ABA 问题的产生。更多关于ABA 问题的详细介绍可以参考文章<a href="http://zhoujiapeng.top/java/java-aba-question">《Java 并发编程 之 ABA 问题》</a>。</p><h2 id="2-Unsafe-类"><a href="#2-Unsafe-类" class="headerlink" title="2. Unsafe 类"></a>2. Unsafe 类</h2><h3 id="2-1-Unsafe-类中的重要方法"><a href="#2-1-Unsafe-类中的重要方法" class="headerlink" title="2.1 Unsafe 类中的重要方法"></a>2.1 Unsafe 类中的重要方法</h3><p>&emsp;JDK 的 rt.jar 包中的 Unsafe 类提供了<strong>硬件级别的原子性操作</strong>,Unsafe 类中的方法都是 native 方法 ,它们使用 JNI 的方式访问本地 C++实现库。下面我们来了解一下 Unsafe 提供的几个主要的方法以及编程时如何使用 Unsafe 类做一些事情。</p><ul><li>public native long objectFieldOffset(Field field): 返回指定的变量在所属类中的内存偏移地址,该偏移地址仅仅在该 Unsafe 函数中访问指定字段时使用。如下代码使用 Unsafe 类获取变量 value 在AtomicLong 对象中的内存偏移:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Unsafe unsafe = sun.misc.Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        long valueOffset = unsafe.objectFieldOffset(AtomicLong.class.getDeclaredField("value"));    </span><br><span class="line">    &#125;<span class="keyword">catch</span> (Exception ex)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li>int arrayBaseOffset(Class&lt;?&gt; arrayClass): 获取数组中第一个元素的地址。</li><li>int arrayIndexScale(Class&lt;?&gt; arrayClass)：获取数组中一个元素占用的字节。</li><li>boolean compareAndSwapLong(Object obj, long valueOffset, long expect, long update)：比较对象 obj 中内存偏移量为 valueOffset 的变量值是否与 expect 相等,相等则使用新的值 update 替换旧的值 expect，然后返回true，否则返回false。</li><li>long getLongVolatile(Object obj, long offset)：获取对象 obj 中偏移量为 offset 的变量对应 volatile 语义的值。</li><li>void putLongVolatile(Object obj, long offset, long value)：设置 obj 对象中 offset偏移的类型为 long 的 field 的值为 value ,支持 volatile 语义。</li><li>void putOrderedLong(Object obj,long offset,long value)：设置 obj 对象中 offset偏移地址对应的 long 型 field 的值为 value。这是一个有延迟的 putLongvolatile 方法,并且不保证值修改对其他线程立刻可见。只有在变量使用 volatile 修饰并且预计会被意外修改时才使用该方法 。</li><li>void park(boolean isAbsoulte,long time)：阻塞当前线程（这个方法在AQS中的使对象等待时会使用到）。isAbsoulte的为是否是绝对时间，如果isAbsoulte为false，其中time为大于0，那么当前线程会在等待time后唤醒。如果isAbsolute为false，其中time为0，那么线程为无限等待。如果isAbosult为true，那么time就是指的是绝对时间也就是换算为ms后的绝对时间。另外，当其他线程调用了当前阻塞线程的<strong>interrupt</strong>方法而中断了当前线程时，当前线程也会返回，而其他线程调用<strong>unPark</strong>方法并且把当前线程作为参数时也会返回。</li><li>void unpark(Object thread)：唤醒调用park线程的线程</li><li>long getAndSetLong(Object obj,long offset,long update)：获取对象obj中偏移量为offset的变量volatile语义的当前值，并设置变量volatile语义的值为update,这里使用了CAS自旋的方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSetLong</span><span class="params">(Object obj,<span class="keyword">long</span> offset , <span class="keyword">long</span> update)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        l = getLongVolatile(obj,offset); <span class="comment">//（1）</span></span><br><span class="line">    &#125;<span class="keyword">while</span>(!compareAndSwapLong(obj,offset,l,update));</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&emsp;由以上代码可知 ,首先 (I) 处的 getLongvolatile 获取当前变量的值 ,然后使用CAS 原子操作设置新值。这里使用 while 循环是考虑到,在多个线程同时调用的情况下 CAS 失败时需要重试。</li><li>long getAndAddLong(Object obj,long offset,long add)方法：设置原始值为val+add。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">long</span> <span class="title">getAndSetLong</span><span class="params">(Object obj,<span class="keyword">long</span> offset , <span class="keyword">long</span> add)</span></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> l;</span><br><span class="line">    <span class="keyword">do</span>&#123;</span><br><span class="line">        l = getLongVolatile(obj,offset);</span><br><span class="line">    &#125;<span class="keyword">while</span>(!compareAndSwapLong(obj,offset,l,l+add));</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="2-2-如何使用-Unsafe-类"><a href="#2-2-如何使用-Unsafe-类" class="headerlink" title="2.2 如何使用 Unsafe 类"></a>2.2 如何使用 Unsafe 类</h3><p>&emsp;我们可以看到 AtomicLong 等类其类是这样使用 Unsafe 类的：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Unsafe unsafe = Unsafe.getUnsafe();</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> valueOffset;</span><br><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            valueOffset = unsafe.objectFieldOffset</span><br><span class="line">                (AtomicLong.class.getDeclaredField("value"));</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception ex) &#123; <span class="keyword">throw</span> <span class="keyword">new</span> Error(ex); &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;但是如果我们在自己写的类中同样使用这种方式，会报错：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Caused by: java.lang.SecurityException: Unsafe</span><br><span class="line">at sun.misc.Unsafe.getUnsafe(Unsafe.java:90)</span><br><span class="line">at Unsafe.TestUnsafe.&lt;clinit&gt;(TestUnsafe.java:12)</span><br></pre></td></tr></table></figure><br>&emsp;为了找出原因，我们查看一下 Unsafe.getUnsafe 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@CallerSensitive</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Unsafe <span class="title">getUnsafe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Class localClass = Reflection.getCallerClass();</span><br><span class="line">        <span class="keyword">if</span> (!VM.isSystemDomainLoader(localClass.getClassLoader())) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> SecurityException(<span class="string">"Unsafe"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> theUnsafe;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//判断paramClassLoader是不是Bootstrap类加载器</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isSystemDomainLoader</span><span class="params">(ClassLoader paramClassLoader)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> paramClassLoader == <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;getUnsafe 中 Reflection.getCallerClass() 获取的是用户的TestUnsafe类，TestUnsafe 是由 AppClassLoader 加载的，所以这里抛出了异常。<br>&emsp;我们的启动 main 函数所在 的类是使用 AppClassLoader 加载的,所以在 main 函数里面加载 Unsafe 类的时候,根据委托机制, 会委托 Bootstrap 类加载器加载。<br>&emsp;Unsafe 类是 rt.jar 包提供的，rt.jar 里面的类是 Bootstrap 类加载器加载的，如果没有加载器的限制，那么我们的应用程序就可以随意使用 Unsafe，而 Unsafe 可以直接操作内存，这是不安全的，所以限制了只能在 rt.jar 包里面的核心类使用 Unsafe 功能。<br>&emsp;如果真的想实例化Unsafe类，我们可以通过反射机制来实现：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">TestUnsafe</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> Unsafe unsafe;</span><br><span class="line">    <span class="comment">//记录变量unsafe在类TestUnsafe中的偏移量</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">long</span> stateOffset;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">long</span> state = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> &#123;</span><br><span class="line">        <span class="keyword">try</span>&#123;</span><br><span class="line">            <span class="comment">//使用反射机制绕过安全检查获取unsafe</span></span><br><span class="line">            Field field = Unsafe.class.getDeclaredField("theUnsafe");</span><br><span class="line">            <span class="comment">//设置为可存取</span></span><br><span class="line">            field.setAccessible(<span class="keyword">true</span>);</span><br><span class="line">            <span class="comment">//获取值</span></span><br><span class="line">            unsafe = (Unsafe)field.get(<span class="keyword">null</span>);</span><br><span class="line">            stateOffset = unsafe.objectFieldOffset(TestUnsafe.class.getDeclaredField("state"));</span><br><span class="line"></span><br><span class="line">        &#125;<span class="keyword">catch</span> (Exception e)&#123;</span><br><span class="line">            System.out.println(e.getLocalizedMessage());</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> Error(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        TestUnsafe test = <span class="keyword">new</span> TestUnsafe();</span><br><span class="line">        Boolean success = unsafe.compareAndSwapInt(test,stateOffset,<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line">        System.out.println(success);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考资料：<br>《Java并发编程之美》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 并发编程 之 ABA 问题</title>
      <link href="/java/java-aba-question/"/>
      <url>/java/java-aba-question/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-并发编程-之-ABA-问题"><a href="#Java-并发编程-之-ABA-问题" class="headerlink" title="Java 并发编程 之 ABA 问题"></a>Java 并发编程 之 ABA 问题</h1><h2 id="1-基本的ABA问题"><a href="#1-基本的ABA问题" class="headerlink" title="1. 基本的ABA问题"></a>1. 基本的ABA问题</h2><p>&emsp;在CAS算法中，需要取出内存中某时刻的数据(由用户完成)，在下一时刻比较并交换(CPU保证原子操作)，这个时间差会导致数据的变化。假设有以下顺序事件：</p><ol><li>线程1从内存位置V中取出A</li><li>线程2从内存位置V中取出A</li><li>线程2进行了写操作，将B写入内存位置V</li><li>线程2将A再次写入内存位置V</li><li>线程1进行CAS操作，发现V中仍然是A，交换成功</li></ol><p>&emsp;尽管线程1的CAS操作成功，但线程1并不知道内存位置V的数据发生过改变。</p><h2 id="2-ABA问题模拟"><a href="#2-ABA问题模拟" class="headerlink" title="2. ABA问题模拟"></a>2. ABA问题模拟</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicReference&lt;Integer&gt; atomicReference = <span class="keyword">new</span> AtomicReference&lt;Integer&gt;(<span class="number">100</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>);</span><br><span class="line">            atomicReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>);</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(atomicReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>) + <span class="string">"\t修改后的值:"</span> + atomicReference.get());</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;初始值为100，线程t1将100改成101，然后又将101改回100，线程t2先睡眠1秒，等待t1操作完成，然后t2线程将值改成2019，可以看到，线程2修改成功:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">true    修改后的值:2019</span><br></pre></td></tr></table></figure></p><h2 id="3-ABA问题的严重后果"><a href="#3-ABA问题的严重后果" class="headerlink" title="3. ABA问题的严重后果"></a>3. ABA问题的严重后果</h2><p>&emsp;上面的Demo不会产生太大的影响，但有时候，ABA造成的后果很严重。我们再来看一下另外一个例子，在《Java并发实战》一书的第15章中有一个用原子变量实现的并发栈，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String item;</span><br><span class="line"><span class="keyword">public</span> Node next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.item = item;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentStack</span> </span>&#123;</span><br><span class="line">AtomicReference&lt;Node&gt; top = <span class="keyword">new</span> AtomicReference&lt;Node&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line">Node newTop = <span class="keyword">new</span> Node(item);</span><br><span class="line">Node oldTop;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">oldTop = top.get();</span><br><span class="line">newTop.next = oldTop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!top.compareAndSet(oldTop, newTop));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">pop</span><span class="params">()</span></span>&#123;</span><br><span class="line">Node newTop;</span><br><span class="line">Node oldTop;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">oldTop = top.get();</span><br><span class="line"><span class="keyword">if</span>(oldTop == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">newTop = oldTop.next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!top.compareAndSet(oldTop, newTop));</span><br><span class="line"><span class="keyword">return</span> oldTop.item;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;这个例子并不会引发ABA问题，至于为什么不会，后面再讲解，下面将并发栈的例子修改一下，看看ABA会造成什么问题：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span> </span>&#123;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> String item;</span><br><span class="line"><span class="keyword">public</span> Node next;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">Node</span><span class="params">(String item)</span></span>&#123;</span><br><span class="line"><span class="keyword">this</span>.item = item;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConcurrentStack</span> </span>&#123;</span><br><span class="line">AtomicReference&lt;Node&gt; top = <span class="keyword">new</span> AtomicReference&lt;Node&gt;();</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(Node node)</span></span>&#123;</span><br><span class="line">Node oldTop;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">oldTop = top.get();</span><br><span class="line">node.next = oldTop;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!top.compareAndSet(oldTop, node));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> Node <span class="title">pop</span><span class="params">(<span class="keyword">int</span> time)</span></span>&#123;</span><br><span class="line">Node newTop;</span><br><span class="line">Node oldTop;</span><br><span class="line"><span class="keyword">do</span>&#123;</span><br><span class="line">oldTop = top.get();</span><br><span class="line"><span class="keyword">if</span>(oldTop == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">newTop = oldTop.next;</span><br><span class="line">TimeUnit.SECONDS.sleep(time);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span>(!top.compareAndSet(oldTop, newTop));</span><br><span class="line"><span class="keyword">return</span> oldTop;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里只是简单做了一点修改：</p><ol><li>push方法：原来是使用内容构造Node，现在直接传入Node，这样就符合了“在算法中的节点可以被循环使用”这个要求；</li><li>pop方法的sleep，这是模拟线程的执行情况，以便观察结果；</li></ol><p>&emsp;下面是main方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        ConcurrentStack stack = <span class="keyword">new</span> ConcurrentStack();</span><br><span class="line">        stack.push(<span class="keyword">new</span> Node(<span class="string">"B"</span>));</span><br><span class="line">        stack.push(<span class="keyword">new</span> Node(<span class="string">"A"</span>));</span><br><span class="line"></span><br><span class="line">        <span class="comment">//让B出栈</span></span><br><span class="line">        Thread threadA = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    stack.pop(<span class="number">3</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//先然NodeA和NodeB出栈，然后让NodeD，NodeC，NodeA入栈（NodeA在栈顶）</span></span><br><span class="line">        Thread threadB = <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                Node A = <span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    A = stack.pop(<span class="number">0</span>);</span><br><span class="line">                    stack.pop(<span class="number">0</span>);</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Node(<span class="string">"D"</span>));</span><br><span class="line">                    stack.push(<span class="keyword">new</span> Node(<span class="string">"C"</span>));</span><br><span class="line">                    stack.push(A);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        threadA.start();</span><br><span class="line">        threadB.start();</span><br><span class="line"></span><br><span class="line">        <span class="comment">//按照想法，执行之后stack里面应该会有CD</span></span><br><span class="line">        <span class="comment">// 但是实际执行之后，stack里面之后B</span></span><br><span class="line">        threadA.join();</span><br><span class="line">        threadB.join();</span><br><span class="line">        Node top = stack.pop(<span class="number">0</span>); <span class="comment">//第一次有数据</span></span><br><span class="line">        <span class="keyword">if</span>(top!=<span class="keyword">null</span>) </span><br><span class="line">            System.out.println(top.item); </span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"the stack is empty"</span>);</span><br><span class="line">        top = stack.pop(<span class="number">0</span>); <span class="comment">//第二次没数据</span></span><br><span class="line">        <span class="keyword">if</span>(top!=<span class="keyword">null</span>)</span><br><span class="line">            System.out.println(top.item);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"the stack is empty"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;按照想法，执行之后stack里面应该会有CD，但是实际执行之后，stack里面只有B。</p><p>&emsp;我们来分析一下这个过程。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/ABA-1.png" alt="ABA-1"></p><p>&emsp;线程A调用<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">oldTop = top.get();</span><br><span class="line"><span class="keyword">if</span>(oldTop == <span class="keyword">null</span>)&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">&#125;</span><br><span class="line">newTop = oldTop.next;</span><br></pre></td></tr></table></figure><br>&emsp;此时 oldTop 对应A，newTop对应B，接下来准备调用 compareAndSet(oldTop, newTop) 将栈顶设置为B，但在这之前 sleep 了3秒，此时A还未真正出栈。<br>&emsp;在线程A sleep 的时候，线程B介入，将A、B出栈，再pushD、C、A，此时堆栈结构如下图，而对象B此时处于游离状态，栈顶仍然为NodeA：</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/ABA-2.png" alt="ABA-2"></p><p>&emsp;此时轮到线程A执行CAS操作，检测发现栈顶仍为A，所以CAS成功，栈顶变为B，但实际上B.next为null，所以此时的情况变为：</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/ABA-3.png" alt="ABA-3"></p><p>&emsp;所以这时候栈中只有B一个元素，C和D组成的链表不再存在于堆栈中，平白无故就把C、D丢掉了。以上就是由于ABA问题带来的隐患。<br>&emsp;我们再回过头来看一下修改之前的并发栈例子，push的时候传入的是一个item，在push函数内部会根据item构造Node，compareAndSet函数比较的是Node，对于新的Node，compareAndSet会失败，而修改之后的例子里面，push函数传入的是Node，线程B将NodeA出栈，后面又将NodeA重新入栈，重复利用原来的Node，compareAndSet才能执行成功，这也导致了ABA问题的产生。</p><h2 id="4-ABA问题的解决"><a href="#4-ABA问题的解决" class="headerlink" title="4. ABA问题的解决"></a>4. ABA问题的解决</h2><p>&emsp;要解决ABA问题，可以增加一个版本号，当内存位置V的值每次被修改后，版本号都加1。Java中提供了AtomicStampedReference和AtomicMarkableReference来解决ABA问题。</p><h3 id="4-1-AtomicStampedReference"><a href="#4-1-AtomicStampedReference" class="headerlink" title="4.1 AtomicStampedReference"></a>4.1 AtomicStampedReference</h3><p>&emsp;AtomicStampedReference内部维护了对象值和版本号，在创建AtomicStampedReference对象时，需要传入初始值和初始版本号，当AtomicStampedReference设置对象值时，对象值以及状态戳都必须满足期望值，写入才会成功。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicStampedReference&lt;Integer&gt; atomicStampedReference = <span class="keyword">new</span> AtomicStampedReference&lt;Integer&gt;(<span class="number">100</span>,<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1拿到的初始版本号:"</span> + atomicStampedReference.getStamp());</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//睡眠1秒，是为了让t2线程也拿到同样的初始版本号</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">            atomicStampedReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>,atomicStampedReference.getStamp(),atomicStampedReference.getStamp()+<span class="number">1</span>);</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">int</span> stamp = atomicStampedReference.getStamp();</span><br><span class="line">            System.out.println(<span class="string">"t2拿到的初始版本号:"</span> + stamp);</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//睡眠3秒，是为了让t1线程完成ABA操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"最新版本号:"</span> + atomicStampedReference.getStamp());</span><br><span class="line">            System.out.println(atomicStampedReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>,stamp,atomicStampedReference.getStamp() + <span class="number">1</span>) + <span class="string">"\t当前 值:"</span> + atomicStampedReference.getReference());</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1拿到的初始版本号:1</span><br><span class="line">t2拿到的初始版本号:1</span><br><span class="line">最新版本号:3</span><br><span class="line">false当前 值:100</span><br></pre></td></tr></table></figure><br>&emsp;分析过程：</p><ol><li>初始值100，初始版本号1</li><li>线程t1和t2拿到一样的初始版本号</li><li>线程t1完成ABA操作，版本号递增到3</li><li>线程t2完成CAS操作，最新版本号已经变成3，跟线程t2之前拿到的版本号1不相等，操作失败</li></ol><h3 id="4-2-AtomicMarkableReference"><a href="#4-2-AtomicMarkableReference" class="headerlink" title="4.2 AtomicMarkableReference"></a>4.2 AtomicMarkableReference</h3><p>&emsp;AtomicStampedReference可以给引用加上版本号，追踪引用的整个变化过程，如：A -&gt; B -&gt; C -&gt; D - &gt; A，通过AtomicStampedReference，我们可以知道，引用变量中途被更改了3次。但是，有时候，我们并不关心引用变量更改了几次，只是单纯的关心是否更改过，所以就有了AtomicMarkableReference。AtomicMarkableReference的唯一区别就是不再用int标识引用，而是使用boolean变量——表示引用变量是否被更改过。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ABADemo2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> AtomicMarkableReference&lt;Integer&gt; atomicMarkableReference = <span class="keyword">new</span> AtomicMarkableReference&lt;Integer&gt;(<span class="number">100</span>,<span class="keyword">false</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            System.out.println(<span class="string">"t1版本号是否被更改:"</span> + atomicMarkableReference.isMarked());</span><br><span class="line"></span><br><span class="line">            <span class="comment">//睡眠1秒，是为了让t2线程也拿到同样的初始版本号</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">1</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">101</span>,atomicMarkableReference.isMarked(),<span class="keyword">true</span>);</span><br><span class="line">            atomicMarkableReference.compareAndSet(<span class="number">101</span>, <span class="number">100</span>,atomicMarkableReference.isMarked(),<span class="keyword">true</span>);</span><br><span class="line">        &#125;,<span class="string">"t1"</span>).start();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">            <span class="keyword">boolean</span> isMarked = atomicMarkableReference.isMarked();</span><br><span class="line">            System.out.println(<span class="string">"t2版本号是否被更改:"</span> + isMarked);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//睡眠3秒，是为了让t1线程完成ABA操作</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                TimeUnit.SECONDS.sleep(<span class="number">3</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">            System.out.println(<span class="string">"是否更改过:"</span> + atomicMarkableReference.isMarked());</span><br><span class="line">            System.out.println(atomicMarkableReference.compareAndSet(<span class="number">100</span>, <span class="number">2019</span>,isMarked,<span class="keyword">true</span>) + <span class="string">"\t当前 值:"</span> + atomicMarkableReference.getReference());</span><br><span class="line">        &#125;,<span class="string">"t2"</span>).start();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;输出结果：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">t1版本号是否被更改:false</span><br><span class="line">t2版本号是否被更改:false</span><br><span class="line">是否更改过:true</span><br><span class="line">false当前 值:100</span><br></pre></td></tr></table></figure><br>&emsp;分析过程：</p><ol><li>初始值100，初始版本号未被修改 false</li><li>线程t1和t2拿到一样的初始版本号都未被修改 false</li><li>线程t1完成ABA操作，版本号被修改 true</li><li>线程t2完成CAS操作，版本号已经变成true，跟线程t2之前拿到的版本号false不相等，操作失败</li></ol><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.cnblogs.com/lmj612/p/10836912.html" target="_blank" rel="noopener">https://www.cnblogs.com/lmj612/p/10836912.html</a><br><a href="https://www.jb51.net/article/132977.htm" target="_blank" rel="noopener">https://www.jb51.net/article/132977.htm</a><br><a href="https://www.cnblogs.com/john8169/p/9780574.html" target="_blank" rel="noopener">https://www.cnblogs.com/john8169/p/9780574.html</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 内存模型</title>
      <link href="/java/java-memoryModel/"/>
      <url>/java/java-memoryModel/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-内存模型"><a href="#Java-内存模型" class="headerlink" title="Java 内存模型"></a>Java 内存模型</h1><h1 id="1-硬件的效率与一致性"><a href="#1-硬件的效率与一致性" class="headerlink" title="1. 硬件的效率与一致性"></a>1. 硬件的效率与一致性</h1><p>&emsp;Java 内存模型的设计关键的一点在于处理并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现有相当大的参考意义。<br>&emsp;由于计算机的储存设备与处理器的运算速度有几个数量级的差距，所以现代计算机不得不加上一层读写速度尽可能接近处理器的<strong>高速缓存（cache）</strong>来作为内存和处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能够快速进行，当运算结束之后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。<br>&emsp;基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：<strong>缓存一致性</strong>。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/cache.png" alt="cache"></p><p>&emsp;如图所示，在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，那同步回主内存的数据应该以谁的缓存数据为准？针对这个问题，需要有某种缓存一致性协议。Java 中的内存模型，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的抽象过程。<br>&emsp;除了增加高速缓存之外，为了使得处理器内部的运算单元能够尽量被充分利用，处理器可能会对输入的代码进行<strong>乱序执行优化</strong>，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个结算任务的中间结果，那么其顺序性不能靠代码的先后顺序来保证，与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有类似的<strong>指令重排序优化</strong>。</p><h1 id="2-Java-内存模型"><a href="#2-Java-内存模型" class="headerlink" title="2. Java 内存模型"></a>2. Java 内存模型</h1><h2 id="2-1-主内存与工作内存"><a href="#2-1-主内存与工作内存" class="headerlink" title="2.1 主内存与工作内存"></a>2.1 主内存与工作内存</h2><p>&emsp;Java 内存模型的主要目标是定义程序中各个变量的访问规则，即虚拟机将变量储存到内存和从内存中取出变量这样的底层细节。这里的变量和Java编程中所说的变量有所区别，它包括了实例字段，静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，不存在竞争问题。<br>&emsp;Java 内存模型规定了<strong>所有的变量都储存在主内存中</strong>。每个线程还有自己的工作内存，线程的工作内存保存了该线程被使用到的变量的主内存<strong>副本</strong>拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间无法直接访问对方工作内存的变量，线程间变量值的传递均需要通过主内存来完成。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/java-memory-model.png?raw=true" alt="java-memory-model"></p><h2 id="2-2-内存间交互操作"><a href="#2-2-内存间交互操作" class="headerlink" title="2.2 内存间交互操作"></a>2.2 内存间交互操作</h2><p>&emsp;关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类的实现细节，java内存模型中定义了8种操作来完成，虚拟机实现时必须保证这8种操作都是原子的、不可分割的(对于long和double类型的变量来说，load、store、read跟write在某些平台上允许例外)。<br>8种基本操作：</p><ul><li>lock(锁定):所用于主内存变量，它把一个变量标识为一条线程独占的状态。</li><li>unlock(解锁):解锁后的变量才能被其他线程锁定。</li><li>read(读取):所用于主内存变量，它把一个主内存变量的值，读取到工作内存中。</li><li>load(载入):所用于工作内存变量，它把read读取的值，放到工作内存的变量副本中。</li><li>use(使用):作用于工作内存变量，它把工作内存变量的值传递给执行引擎，当JVM遇到一个变量读取指令就会执行这个操作。</li><li>assign(赋值):作用于工作内存变量，它把一个从执行引擎接收到的值赋值给工作内存变量。</li><li>store(存储):作用域工作内存变量，它把工作内存变量值传送到主内存中。</li><li>write(写入):作用于主内存变量，它把store从工作内存中得到的变量值写入到主内存变量中<br>&emsp;java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：</li><li>不允许read和load、store和write操作之一单独出现，即不允许加载或同步工作到一半。</li><li>不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后，必须吧改变化同步回主内存。</li><li>不允许一个线程无原因地（无assign操作）把数据从工作内存同步到主内存中。</li><li>一个新的变量只能在主内存中诞生。</li><li>一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，，多次lock之后必须要执行相同次数的unlock操作，变量才会解锁。</li><li>如果对一个对象进行lock操作，那会清空工作内存变量中的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。</li><li>如果一个变量事先没有被lock，就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁住的变量。</li><li>对一个变量执行unlock操作之前，必须将此变量同步回主内存中（执行store、write）。<br>&emsp;有如上8种内存访问操作以及规则限定，再加上对volatile的一些特殊规定，就已经完全确定了java程序中哪些内存访问操作是在并发下安全的。</li></ul><h2 id="2-3-内存可见性问题"><a href="#2-3-内存可见性问题" class="headerlink" title="2.3 内存可见性问题"></a>2.3 内存可见性问题</h2><p>&emsp;Java 内存模型规定,将所有的变量都存放在主内存中,当线程使用变量时,会把主内存里面的变量复制到自己的工作空间或者叫作工作内存,线程读写变量时操作的是自己工作内存中的变量 。<br>&emsp;当一个线程操作共享变量时,它首先从主内存复制共享变量到自己的工作内存,然后对工作内存里的变量进行处理,处理完后将变量值更新到主内存。那么假如线程A和线程B同时处理 一个共享变量,会出现什么情况?<br>&emsp;假设线程 A 和线程 B 使用不同CPU执行,并且当前两级 Cache 都为空,那么这时候由于Cache的存在,将会导致内存不可见问 题, 具体看下面的分析。</p><ul><li>线程 A 首先获取共享变量 X 的值,由于两级 Cache 都没有命中 ,所以加载主内存中 X 的值,假如为0。然后把X=0的值缓存到两级缓存,线程 A 修改 X 的值为1,然后将其写入两级 Cache,并且刷新到主内存。线程 A 操作完毕后,线程 A 所在的CPU的两级 Cache 内和主内存里面的 X 的值都是l。</li><li>线程 B 获取 X 的值,首先一级缓存没有命中,然后看二级缓存,二级缓存命中了,所以返回 X= 1;到这里一切都是正常的,因为这时候主内存中也是X= l。然后线程 B 修改X的值为 2 ,并将其存放到线程 2 所在的一级 Cache 和共享二级 Cache 中,最后更新主内存中 X 的值为 2,到这里一切都是好的 。</li><li>线程 A 这次又需要修改 X 的值,获取时一级缓存命中,并且 X= l ,到这里问题就出现了,明明线程 B 已经把X的值修改为了 2 ,为何线程 A 获取的还是 l 呢? 这<br>就是共享变量的内存不可见问题 , 也就是线程 B 写入的值对线程 A 不可见。<br>&emsp;使用 Java 中的 volatile 关键字就可以解决内存不可见问题。</li></ul><h2 id="2-4-伪共享"><a href="#2-4-伪共享" class="headerlink" title="2.4 伪共享"></a>2.4 伪共享</h2><h3 id="2-4-1-什么是伪共享"><a href="#2-4-1-什么是伪共享" class="headerlink" title="2.4.1 什么是伪共享"></a>2.4.1 什么是伪共享</h3><p>&emsp;为了解决计算机系统中主内存与 CPU 之间运行速度差问题,会在 CPU 与主内存之间添加一级或者多级高速缓冲存储器( Cache )。这个 Cache 一般是被集成到 CPU 内部的,所以也叫 CPU Cache,下图所示是两级 Cache 结构。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/cache.png?raw=true" alt="cache"></p><p>&emsp;在 Cache 内部是按行存储的,其中每一行称为一个 Cache 行。 <strong>Cache 行</strong>是 Cache 与主内存进行数据交换的单位, Cache 行的大小一般为2的幂次数字节。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/cacheline.png?raw=true" alt="cacheline"></p><p>&emsp;当 CPU 访问某个变量时,首先会去看 CPU Cache 内是否有该变量,如果有则直接从中获取,否则就去主内存里面获取该变量,然后把<strong>该变量所在内存区域的一个 Cache 行</strong>大小的内存复制到 Cache 中。由于存放到  Cache 行的是内存块而不是单个变量,所以可能会把多个变量存放到一个 Cache 行中 。 当多个线程同时修改一个缓存行里面的多个变量时,由于同时只能有一个线程操作同一个缓存行（缓存一致性协议）,所以相比将每个变量放到 一个缓存行,性能会有所下降,这就是<strong>伪共享</strong>。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/jvm/cachelineshare.png?raw=true" alt="cachelineshare"></p><p>&emsp;在该图中,变量 x 和 y 同时被放到了 CPU 的一级和二级缓存 ,当线程 l 使用 CPUl 对变量 x 进行更新时 ,首先会修改 CPUl 的一级缓存变量 x 所在的缓存行,这时候在缓存一致性协议下, CPU2 中变量 x 对应的缓存行失效 。那么线程 2 在写入变量 x 时就只能去二级缓存里查找,这就破坏了 一 级缓存。而一级缓存比二级缓存更快 ,这也说明了多个线程不可能 同时去修改自己所使用的 CPU 中相同缓存行里面的变量。更坏的情况是 ,如果CPU 只有一级缓存,则会导致频繁地访问主内存。</p><h3 id="2-4-2-为何会出现伪共享"><a href="#2-4-2-为何会出现伪共享" class="headerlink" title="2.4.2 为何会出现伪共享"></a>2.4.2 为何会出现伪共享</h3><p>&emsp;伪共享的产生是因为<strong>多个变量被放入了一个缓存行中,并且多个线程同时去写入缓存行中不同的变量</strong> 。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> a;</span><br><span class="line"><span class="keyword">long</span> b;</span><br><span class="line"><span class="keyword">long</span> c;</span><br><span class="line"><span class="keyword">long</span> d;</span><br></pre></td></tr></table></figure><br>&emsp;如上代码声明了四个 long 变量,假设缓存行的大小为 32 字节,那么当 CPU 访问变量 a 时 , 发现该变量没有在缓存中,就会去主内存把变量 a 以及内存地址附近的 b、c、d放入缓存行,也就是<strong>地址连续的多个变量才有可能会被放到一个缓存行中</strong>。当创建数组时,数组里面的多个元素就会被放入同一个缓存行。<br>&emsp;根据程序执行的局部性原理，提前将可能需要的数据放入缓存中，能够加快程序执行速度。一个典型的例子是：一个二维数组，按行遍历能够比按列遍历快。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">long</span> [][] array = <span class="keyword">new</span> <span class="keyword">long</span> [LINE_NUM][COLUM_NUM];</span><br><span class="line"><span class="comment">//按行遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;LINE_NUM;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;COLUM_NUM;j++)&#123;</span><br><span class="line">        array[i][j] = i*<span class="number">2</span>+j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//按列遍历</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;COLUM_NUM;i++)&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;LINE_NUM;j++)&#123;</span><br><span class="line">        array[i][j] = i*<span class="number">2</span>+j</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;这是因为数组内数组元素的内存地址是连续的,当访问数组第一个元素时,会把第一个元素后的若干元素一块放入缓存行,这样顺序访问数组元素时会在缓存中直接命中,因而就不会去主内存读取了,后续<br>访问也是这样。而按列访问是跳跃式访问数组元素的,不是顺序的,这破坏了程序访问的局部性原则,并且缓存是有容量控制的,当缓存满了时会根据一定淘汰算法替换缓存行,这会导致从内存置换过来的缓存行的元素还没等到被读取就被替换掉了。</p><h3 id="2-4-3-如何避免伪共享"><a href="#2-4-3-如何避免伪共享" class="headerlink" title="2.4.3 如何避免伪共享"></a>2.4.3 如何避免伪共享</h3><p>&emsp;在 JDK8 之前一般都是通过<strong>字节填充</strong>的方式来避免该问题,也就是创建一个变量时使用填充字段填充该变量所在的缓存行,这样就避免了将多个变量存放在同一个缓存行中,例如如下代码:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">long</span> p1,p2,p3,p4,p5,p6;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;假如缓存行为 64 字节,那么我们在 FilledLong 类里面填充了 6 个 long 类型的变量,每个 long 类型变量占用 8 字节,加上 value 变量的 8 字节总共 56 字节。另外,这里FilledLong 是一个类对象, 而类对象的字节码的对象头占用 8 字节,所以一个 FilledLong对象实际会占用 64 字节的内存,这正好可以放入一个缓存行 。<br>&emsp;JDK 8 提供了一个 <strong>sun.misc.Contended</strong> 注解,用来解决伪共享问题，可以修饰类或变量。将上面代码修改为如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@sun</span>.misc.Contended</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">FilledLong</span></span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">volatile</span> <span class="keyword">long</span> value = <span class="number">0L</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;需要注意的是,在默认情况下,@Contended 注解只用于Java核心类, 比如rt包下的类。如果用户类路径下的类需要使用这个注解, 则需要添加JVM参数:-XX:-RestrictContended,填充的宽度默认为 128 ,要自定义宽度则可以设置 -XX:ContendPaddingWidth 参数。</p><h2 id="2-5-原子性、可见性和有序性"><a href="#2-5-原子性、可见性和有序性" class="headerlink" title="2.5 原子性、可见性和有序性"></a>2.5 原子性、可见性和有序性</h2><p>&emsp;Java内存模型是围绕着并发过程中如何处理<strong>原子性、可见性、有序性</strong>这3个特征来建立的，我们逐个来看一下哪些操作实现了这三个特性。</p><h3 id="2-5-1-原子性"><a href="#2-5-1-原子性" class="headerlink" title="2.5.1 原子性"></a>2.5.1 原子性</h3><p>&emsp;由内存模型直接保证原子性变量操作包括read、load、assign、use、store、write，我们大致可以认为<strong>基本数据类型的访问读写是具备原子性</strong>的（例外就是long和double的非原子性协定，可以参考文章《Java 一些变量类型的特殊规则》）。<br>&emsp;如果需要一个更大范围的原子性保证，Java内存模型还提供了lock和unlock操作来满足这种需求，尽管虚拟机没有把lock和unlock直接开放给用户，但是却提供了更高层次的字节码指令<strong>monitorenter和monitorexit</strong>来隐式使用这两个操作，这两个字节码指令反映到Java代码中就是同步块—-<strong>synchronized</strong>关键字，因此在synchronized块之间的操作也具备原子性。</p><h3 id="2-5-2-可见性"><a href="#2-5-2-可见性" class="headerlink" title="2.5.2 可见性"></a>2.5.2 可见性</h3><p>&emsp;可见性是指当一个线程修改了共享变量的值，其它线程能够立即得知这个修改。例如对于<strong>volatile</strong>变量，Java内存模型是通过在变量修改后将新值同步回主内存，在变量读取前从主内存刷性变量值这种依赖主内存作为传递媒介的方式来实现可见性。普通变量与volatile变量的区别是：volatile的特殊规则保证新值能立即同步到主内存，以及每次使用前立即从主内存刷新，所以说volatile保证了多线程操作时变量的可见性。<br>&emsp;除了volatile之外，Java还有两个关键字能实现可见性，即<strong>synchronized和final</strong>。synchronized的可见性是由“对一个变量执行unlock操作之前，必须把此变量同步回主内存中(执行store、write)”这条规则获得的。而final关键字的可见性是指：被final修饰的字段在构造器中一旦初始化完成，并且构造器没有把“this”引用传递出去（this引用逃逸），那么在其它线程中就能看见final字段的值。</p><h3 id="2-5-3-有序性"><a href="#2-5-3-有序性" class="headerlink" title="2.5.3 有序性"></a>2.5.3 有序性</h3><p>&emsp;前面我们说到，为了使得处理器内部的运算单元能够尽量被充分利用，处理器可能会对输入的代码进行<strong>乱序执行优化</strong>，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有类似的<strong>指令重排序优化</strong>。Java程序中天然的有序性可以总结为一句话：如果在本线程内观察，所有操作都是有序的；如果在一个线程观察另外一个线程，所有操作都是无序的。后半句是指“指令重排序“现象和”工作内存与主内存同步延迟“现象。<br>&emsp;Java提供了volaile和synchronized两个关键字来保证线程之间操作的有序性，volaile关键字本身就包含了禁止指令重排序的语义(可以参考文章《Java 一些变量类型的特殊规则》），而synchronized则是由”一个变量在同一时刻只允许一条线程对其进行lock操作“这条规则获得的，这条规则决定了持有同一个锁的两个同步块只能串行地进入。</p><h2 id="3-volatile-的语义"><a href="#3-volatile-的语义" class="headerlink" title="3. volatile 的语义"></a>3. volatile 的语义</h2><p><a href="http://zhoujiapeng.top/java/java-special-variable">《volatile 的特殊规则和 long&amp;&amp;double 的非原子协定》</a></p><h2 id="4-long-amp-amp-double-的非原子协定"><a href="#4-long-amp-amp-double-的非原子协定" class="headerlink" title="4. long&amp;&amp;double 的非原子协定"></a>4. long&amp;&amp;double 的非原子协定</h2><p><a href="http://zhoujiapeng.top/java/java-special-variable">《volatile 的特殊规则和 long&amp;&amp;double 的非原子协定》</a></p><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br>《深入理解Java虚拟机》<br>《Java并发编程之美》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jvm </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池 之 ThreadPoolExecutor 状态控制</title>
      <link href="/java/java-threadPoolExecutor-statusControl/"/>
      <url>/java/java-threadPoolExecutor-statusControl/</url>
      
        <content type="html"><![CDATA[<h1 id="线程池-之-ThreadPoolExecutor-状态控制"><a href="#线程池-之-ThreadPoolExecutor-状态控制" class="headerlink" title="线程池 之 ThreadPoolExecutor 状态控制"></a>线程池 之 ThreadPoolExecutor 状态控制</h1><p>&emsp;ThreadPoolExecutor 内部使用了大量位运算，以下是ThreadPoolExecutor状态控制的主要变量和方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ThreadPoolExecutor.java</span></span><br><span class="line">    <span class="comment">//原子状态控制数</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger ctl = <span class="keyword">new</span> AtomicInteger(ctlOf(RUNNING, <span class="number">0</span>));</span><br><span class="line">    <span class="comment">//29比特位</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> COUNT_BITS = Integer.SIZE - <span class="number">3</span>;</span><br><span class="line">    <span class="comment">//实际容量 2^29-1</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> CAPACITY   = (<span class="number">1</span> &lt;&lt; COUNT_BITS) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// runState is stored in the high-order bits</span></span><br><span class="line">    <span class="comment">// runState存储在高位中</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> RUNNING    = -<span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> SHUTDOWN   =  <span class="number">0</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> STOP       =  <span class="number">1</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TIDYING    =  <span class="number">2</span> &lt;&lt; COUNT_BITS;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> TERMINATED =  <span class="number">3</span> &lt;&lt; COUNT_BITS;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Packing and unpacking ctl 打包和解压ctl</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解压runState</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">runStateOf</span><span class="params">(<span class="keyword">int</span> c)</span>     </span>&#123; <span class="keyword">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class="line">    <span class="comment">// 解压workerCount</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">workerCountOf</span><span class="params">(<span class="keyword">int</span> c)</span>  </span>&#123; <span class="keyword">return</span> c &amp; CAPACITY; &#125;</span><br><span class="line">    <span class="comment">// 打包ctl</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">int</span> <span class="title">ctlOf</span><span class="params">(<span class="keyword">int</span> rs, <span class="keyword">int</span> wc)</span> </span>&#123; <span class="keyword">return</span> rs | wc; &#125;</span><br></pre></td></tr></table></figure><br>&emsp;<strong>线程池使用一个AtomicInteger的ctl变量将 workerCount（工作线程数量）和 runState（运行状态）两个字段压缩在一起</strong>，这种做法在在java源码里经常有出现，如在 ReentrantReadWriteLock 里就将一个int分成高16位和底16位，分别表示读锁状态和写锁状态。ThreadPoolExecutor里也是使用了同样的思想，表现得更加复杂。<br>&emsp;ThreadPoolExecutor用ctl的最高3个比特位表示runState， 低29个比特位表示workerCount。因此这里需要特别说明的是：</p><blockquote><p>确切的说，当最大线程数量配置为Integer.MXA_VAULE时，ThreadPoolExecutor的线程最大数量依然是2^29-1。</p></blockquote><p>&emsp;目前来看这是完全够用的，但随着计算机的不断发展，真的到了不够用的时候可以改变为AtomicLong。这如同32位系统时间戳会在2038年01月19日03时14分07秒耗尽一样，当以后我们的系统线程能够超过2^29-1时，这些代码就需要调整了。对于未来，无限可能。</p><p>&emsp;思考一下为什么是29：3呢？<br>这是因为我们的运营状态有5种，向上取2次方数，2^3 = 8。所以必须要3个比特位来表示各种状态。</p><p>&emsp;运行状态解释：<br>| 状态 | 解释 |<br>| —— | —- |<br>|RUNNING |运行态，可处理新任务并执行队列中的任务 |<br>|SHUTDOW |关闭态，不接受新任务，但处理队列中的任务 |<br>|STOP |停止态，不接受新任务，不处理队列中任务，且打断运行中任务 |<br>|TIDYING |整理态，所有任务已经结束，workerCount = 0，将执行terminated()方法 |<br>|TERMINATED |结束态，terminated() 方法已完成 |</p><p>&emsp;整个ctl的状态，会在线程池的不同运行阶段进行CAS转换。</p><p>线程池运行状态的转换如下：</p><ol><li>线程池在RUNNING状态下调用shutdown()方法会进入到SHUTDOWN状态，（finalize()方法也会调用shutdownNow()）。</li><li>在RUNNING和SHUTDOWN状态下调用 shutdownNow() 方法会进入到STOP状态。</li><li>在SHUTDOWN状态下，当阻塞队列为空且线程数为0时进入TIDYING状态；在STOP状态下，当线程数为0时进入TIDYING状态。</li><li>在TIDYING状态，调用terminated()方法完成后进入TERMINATED状态。</li></ol><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/threadpoolexecutor-status.png?raw=true" alt="staus"></p><p>&emsp;另外，可以通过线程池的以下属性监控线程池的当前状态：</p><ul><li>getTaskCount：返回曾计划执行的近似任务总数。因为在计算期间任务和线程的状态可能动态改变，所以返回值只是一个近似值。</li><li>getCompletedTaskCount：返回已完成执行的近似任务总数。因为在计算期间任务和线程的状态可能动态改变，所以返回值只是一个近似值，但是该值在整个连续调用过程中不会减少。</li><li>getLargestPoolSize：线程池曾经创建过的最大线程数量，通过这个数据可以知道线程池是否满过。如等于线程池的最大大小，则表示线程池曾经满了。</li><li>getPoolSize：线程池的线程数量。</li><li>getActiveCount：返回主动执行任务的近似线程数。</li></ul><p>&emsp;通过扩展线程池进行监控：继承线程池并重写线程池的beforeExecute()，afterExecute()和terminated()方法，可以在任务执行前、后和线程池关闭前自定义行为。如监控任务的平均执行时间，最大执行时间和最小执行时间等。</p><p>&emsp;使用ThreadPoolExecutor直接创建线程池时，可以使用第三方的ThreadFactory，或者自己实现ThreadFactory接口，拓展更多的属性，例如设置线程名称、执行开始时间、优先级等等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">PausableThreadPoolExecutor</span> <span class="keyword">extends</span> <span class="title">ThreadPoolExecutor</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">boolean</span> isPaused;    <span class="comment">//标志是否被暂停</span></span><br><span class="line">    <span class="keyword">private</span> ReentrantLock pauseLock = <span class="keyword">new</span> ReentrantLock();    <span class="comment">//访问isPaused时需要加锁，保证线程安全</span></span><br><span class="line">    <span class="keyword">private</span> Condition unpaused = pauseLock.newCondition();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">PausableThreadPoolExecutor</span><span class="params">(...)</span> </span>&#123; <span class="keyword">super</span>(...); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//beforeExecute为ThreadPoolExecutor提供的hood方法</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isPaused) </span><br><span class="line">                unpaused.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span>(InterruptedException ie) &#123;</span><br><span class="line">            t.interrupt();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//暂停</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//取消暂停</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">resume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        pauseLock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            isPaused = <span class="keyword">false</span>;</span><br><span class="line">            unpaused.signalAll();</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            pauseLock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.jianshu.com/p/18065a78178b" target="_blank" rel="noopener">https://www.jianshu.com/p/18065a78178b</a><br><a href="https://blog.csdn.net/wtopps/article/details/80682267" target="_blank" rel="noopener">https://blog.csdn.net/wtopps/article/details/80682267</a><br><a href="https://www.cnblogs.com/zaizhoumo/p/7794818.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaizhoumo/p/7794818.html</a></p><p>(文章只做学习记录，非商业用途。如有侵权,请联系删除！)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池 之 ThreadPoolExecutor 执行原理</title>
      <link href="/java/java-threadPoolExecutor-executorAnalyze/"/>
      <url>/java/java-threadPoolExecutor-executorAnalyze/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadPoolExecutor-执行原理"><a href="#ThreadPoolExecutor-执行原理" class="headerlink" title="ThreadPoolExecutor 执行原理"></a>ThreadPoolExecutor 执行原理</h1><p>&emsp;ThreadPoolExecutor 的实现实际是一个生产消费模型，当用户添加任务到任务池时相当于生产者生产元素，workers线程工作集中的线程直接执行任务或者从任务队列里面获取任务时则相当于消费者消费元素。<br>&emsp;用户线程提交任务时的execute方法如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable command)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (command == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">// 1、工作线程 &lt; 核心线程 ，创建线程执行</span></span><br><span class="line">        <span class="keyword">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class="line">            <span class="keyword">if</span> (addWorker(command, <span class="keyword">true</span>))</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            c = ctl.get();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 2、运行态，并尝试将任务加入队列</span></span><br><span class="line">        <span class="keyword">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class="line">            <span class="comment">//二次检查</span></span><br><span class="line">            <span class="keyword">int</span> recheck = ctl.get();</span><br><span class="line">            <span class="comment">//如果不是RUNNING则从队列中删除任务，并执行拒绝策略</span></span><br><span class="line">            <span class="keyword">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class="line">                reject(command);</span><br><span class="line">            <span class="comment">//如果当前线程池为空，则添加一个线程</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (workerCountOf(recheck) == <span class="number">0</span>)</span><br><span class="line">                addWorker(<span class="keyword">null</span>, <span class="keyword">false</span>);</span><br><span class="line">        &#125; <span class="comment">// 3、队列已满，新增线程使用尝试使用最大线程运行</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!addWorker(command, <span class="keyword">false</span>))</span><br><span class="line">            reject(command);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;execute 的判断逻辑可用下图表示:<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/thread-process-task.png?raw=true" alt="线程任务处理流程"></p><ol><li>如果当前线程池任务线程数量小于核心线程池数量，会向 wokers 里面新增一个核心线程执行该任务。</li><li>如果当前线程池任务线程数量大于核心线程池数量，如果处于 RUNNING 状态，则尝试将任务添加到任务队列，这里需要重新判断线程池状态是因为这里 exexute 不是原子操作，此时可能已经处于非 RUNNING 状态，如果处于非 RUNNING 状态则需要抛弃该新任务，将任务从队列中移出。</li><li>如果当前线程池任务线程数量大于核心线程池数量，且任务队列已满，将会创建一个新的任务线程，直到超出 maximumPoolSize，如果超出 maximumPoolSize，则任务将会被拒绝，通过设定的拒绝策略来处理。</li></ol><p>&emsp;在execute方法中，用到了double-check的思想，我们看到上述代码中并没有同步控制，都是基于乐观的check，如果任务可以创建则进入addWorker(Runnable firstTask, boolean core)方法，注意上述代码中的三种传参方式：</p><ul><li>addWorker(command, true)： 创建核心线程执行任务；</li><li>addWorker(command, false)：创建非核心线程执行任务；</li><li>addWorker(null, false)： 创建非核心线程，当前任务为空(会从任务队列去取)；</li></ul><p>&emsp;addWorker的返回值是boolean，不保证操作成功。下面详看addWorker方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">addWorker</span><span class="params">(Runnable firstTask, <span class="keyword">boolean</span> core)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 第一部分：自旋、CAS、重读ctl 等结合，直到确定是否可以创建worker，</span></span><br><span class="line">    <span class="comment">// 可以则跳出循环继续操作，否则返回false</span></span><br><span class="line">    retry:</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="comment">//获取当前状态  c由runState和workercount组成</span></span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Check if queue empty only if necessary.</span></span><br><span class="line">        <span class="comment">//非 running，非running状态都不接受新任务</span></span><br><span class="line">        <span class="comment">//SHUTDOWN可以处理队列中的任务</span></span><br><span class="line">        <span class="comment">//代码(1)</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//代码(2)</span></span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line">            <span class="keyword">if</span> (wc &gt;= CAPACITY ||</span><br><span class="line">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">            <span class="comment">//CAS增加线程数量</span></span><br><span class="line">            <span class="keyword">if</span> (compareAndIncrementWorkerCount(c)) <span class="comment">// CAS增长workerCount，成功则跳出循环</span></span><br><span class="line">                <span class="keyword">break</span> retry;</span><br><span class="line">            c = ctl.get();  <span class="comment">// Re-read ctl 重新获取ctl</span></span><br><span class="line">            <span class="comment">//代码2.1  判断线程池状态是否发生变化</span></span><br><span class="line">            <span class="keyword">if</span> (runStateOf(c) != rs) <span class="comment">// 状态改变则继续外层循环，否则在内层循环</span></span><br><span class="line">                <span class="keyword">continue</span> retry;</span><br><span class="line">            <span class="comment">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 第二部分：创建worker，这部分使用ReentrantLock锁</span></span><br><span class="line">    <span class="keyword">boolean</span> workerStarted = <span class="keyword">false</span>; <span class="comment">// 线程启动标志位</span></span><br><span class="line">    <span class="keyword">boolean</span> workerAdded = <span class="keyword">false</span>;  <span class="comment">// 线程是否加入workers 标志位</span></span><br><span class="line">    Worker w = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        w = <span class="keyword">new</span> Worker(firstTask); <span class="comment">//创建worker</span></span><br><span class="line">        <span class="keyword">final</span> Thread t = w.thread;</span><br><span class="line">        <span class="keyword">if</span> (t != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">final</span> ReentrantLock mainLock = <span class="keyword">this</span>.mainLock;</span><br><span class="line">            mainLock.lock();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">// 获取到锁以后仍需检查ctl，可能在上一个获取到锁处理的线程可能会改变runState</span></span><br><span class="line">                <span class="comment">// 如 ThreadFactory 创建失败 或线程池被 shut down等</span></span><br><span class="line">                <span class="keyword">int</span> rs = runStateOf(ctl.get());</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (rs &lt; SHUTDOWN ||</span><br><span class="line">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class="keyword">null</span>)) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (t.isAlive())</span><br><span class="line">                        <span class="keyword">throw</span> <span class="keyword">new</span> IllegalThreadStateException();</span><br><span class="line">                    workers.add(w);</span><br><span class="line">                    <span class="keyword">int</span> s = workers.size();</span><br><span class="line">                    <span class="keyword">if</span> (s &gt; largestPoolSize)</span><br><span class="line">                        largestPoolSize = s;</span><br><span class="line">                    workerAdded = <span class="keyword">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                mainLock.unlock();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (workerAdded) &#123;</span><br><span class="line">                t.start(); <span class="comment">// 启动线程</span></span><br><span class="line">                workerStarted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (! workerStarted)</span><br><span class="line">            addWorkerFailed(w); <span class="comment">// 失败操作</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> workerStarted;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;addWorker的工作可分为两个部分：</p><ul><li>第一部分：原子操作，判断是否可以创建worker。通过自旋、CAS、ctl 等操作，判断继续创建还是返回false，自旋周期一般很短。</li><li>第二部分：同步创建workder，并启动线程。</li></ul><p>&emsp;我们看一下第一部分的一段代码(1)：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class="line">               firstTask == <span class="keyword">null</span> &amp;&amp;</span><br><span class="line">               ! workQueue.isEmpty()))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><br>&emsp;这个判断条件比较复杂，可以转换一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class="line">            (rs != SHUTDOWN ||</span><br><span class="line">            firstTask != <span class="keyword">null</span> ||</span><br><span class="line">            workQueue.isEmpty()))</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br></pre></td></tr></table></figure><br>&emsp;也就是代码(1)在下面三种情况会返回false（对应 || 的三种情况）：</p><ul><li>(1) 当前线程池状态为 STOP、TIDYING和TERMINATED。</li><li>(2) 当前线程池为 SHUTDOWN 并且有了第一个任务。</li><li>(3) 当前线程池为 SHUTDOWN 并且任务队列为空。</li></ul><p>&emsp;代码(2)的循环的作用是使用CAS操作增加线程数量，成功则退出循环，进入第二部分。注意这里需要判断线程池的状态是否发生变化(代码2.1)，如果变了，需要回到第一部分的开头重新获取线程池状态。</p><p>&emsp;执行到第二部分，说明已经使用SCAS成功增加了线程数量，接下来使用全局的独占锁来控制把新增的 Worker 添加到工作集 workers 中。如果添加成功，则调用  t.start() 启动工作线程。<br>&emsp;addWorker(Runnable firstTask, boolean core) 参数中 core 指明了线程数量限制，true 对应 corePoolSize，false 对应 maximumPoolSize。另外，这里的 firstTask 参数可能为 null，这并不影响，也不需要在这里增加额外的判断，Worker 在 run 的时候，如果判断 firstTask 为 null，则会调用 getTask() 方法从任务队列中获取新任务，后面会详细介绍。</p><p>&emsp;理清 addWorker 之后，我们来看一下 Worker 类：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/Worker.png?raw=true" alt="Worker类图"></p><p>&emsp;Worker是ThreadPoolExecutor的内部类，实现了 AbstractQueuedSynchronizer 并继承了 Runnable。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Worker</span> <span class="keyword">extends</span> <span class="title">AbstractQueuedSynchronizer</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br><span class="line"><span class="class"></span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = <span class="number">6138294804551838833L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 每个worker有自己的内部线程，ThreadFactory创建失败时是null */</span></span><br><span class="line">    <span class="keyword">final</span> Thread thread;</span><br><span class="line">    <span class="comment">/** 初始化任务，可能是null */</span></span><br><span class="line">    Runnable firstTask;</span><br><span class="line">    <span class="comment">/** 每个worker的完成任务数 */</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="keyword">long</span> completedTasks;</span><br><span class="line"></span><br><span class="line">    Worker(Runnable firstTask) &#123;</span><br><span class="line">        setState(-<span class="number">1</span>); <span class="comment">// 禁止线程在启动前被打断</span></span><br><span class="line">        <span class="keyword">this</span>.firstTask = firstTask;</span><br><span class="line">        <span class="keyword">this</span>.thread = getThreadFactory().newThread(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** 重要的执行方法  */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        runWorker(<span class="keyword">this</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// state = 0 代表未锁；state = 1 代表已锁</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">isHeldExclusively</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getState() != <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryAcquire</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (compareAndSetState(<span class="number">0</span>, <span class="number">1</span>)) &#123;</span><br><span class="line">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">boolean</span> <span class="title">tryRelease</span><span class="params">(<span class="keyword">int</span> unused)</span> </span>&#123;</span><br><span class="line">        setExclusiveOwnerThread(<span class="keyword">null</span>);</span><br><span class="line">        setState(<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">()</span>        </span>&#123; acquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">tryLock</span><span class="params">()</span>  </span>&#123; <span class="keyword">return</span> tryAcquire(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">()</span>      </span>&#123; release(<span class="number">1</span>); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isLocked</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> isHeldExclusively(); &#125;</span><br><span class="line">    <span class="comment">// interrupt已启动线程</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">interruptIfStarted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread t;</span><br><span class="line">        <span class="comment">// 初始化是 state = -1，不会被interrupt</span></span><br><span class="line">        <span class="keyword">if</span> (getState() &gt;= <span class="number">0</span> &amp;&amp; (t = thread) != <span class="keyword">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                t.interrupt();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (SecurityException ignore) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;在构造函数内首先设置 Woker 状态为 -1，这是为了避免在调用 runWorker 方法前被打断（当其它线程调用了线程池的shutdownNow方法时，如果Worker状态&gt;=-1则会中断该线程）。<br>&emsp;Worker 实现了简单的 非重入互斥锁，互斥容易理解，非重入是为了避免线程池的一些控制方法获得重入锁，比如setCorePoolSize操作。注意 Worker 实现锁的目的与传统锁的意义不太一样。其主要是为了控制线程是否可interrupt，以及其他的监控，如线程是否 active（正在执行任务）。</p><blockquote><p>线程池里线程是否处于运行状态与普通线程不一样，普通线程可以调用 Thread.currentThread().isAlive() 方法来判断，而线程池，在run方法中可能在等待获取新任务，这期间线程线程是 alive 但是却不是 active。</p></blockquote><p>&emsp;Worker 的 run 方法调用了 runWorker，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">void</span> <span class="title">runWorker</span><span class="params">(Worker w)</span> </span>&#123;</span><br><span class="line">        Thread wt = Thread.currentThread();</span><br><span class="line">        Runnable task = w.firstTask;</span><br><span class="line">        w.firstTask = <span class="keyword">null</span>;</span><br><span class="line">        <span class="comment">//Worker初始化时同步状态置为-1，此处进行解锁操作目的是将同步状态置为0，允许中断。</span></span><br><span class="line">        w.unlock(); </span><br><span class="line">        <span class="keyword">boolean</span> completedAbruptly = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">// loop 直至 task = null （线程池关闭、超时等）</span></span><br><span class="line">            <span class="comment">// 注意这里的getTask()方法，我们配置的阻塞队列会在这里起作用</span></span><br><span class="line">            <span class="keyword">while</span> (task != <span class="keyword">null</span> || (task = getTask()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">                w.lock();  <span class="comment">// 执行任务前上锁</span></span><br><span class="line">                <span class="comment">// 如果线程池停止，确保线程中断; 如果没有，确保线程不中断。这需要在第二种情况下进行重新获取ctl，以便在清除中断时处理shutdownNow竞争</span></span><br><span class="line">                <span class="keyword">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class="line">                     (Thread.interrupted() &amp;&amp;</span><br><span class="line">                      runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class="line">                    !wt.isInterrupted())</span><br><span class="line">                    wt.interrupt();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    beforeExecute(wt, task); <span class="comment">// 扩展点</span></span><br><span class="line">                    Throwable thrown = <span class="keyword">null</span>;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        task.run(); <span class="comment">// 真正执行run方法</span></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (RuntimeException x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Error x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> x;</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable x) &#123;</span><br><span class="line">                        thrown = x; <span class="keyword">throw</span> <span class="keyword">new</span> Error(x);</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        afterExecute(task, thrown); <span class="comment">// 扩展点</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    task = <span class="keyword">null</span>;</span><br><span class="line">                    w.completedTasks++;</span><br><span class="line">                    w.unlock();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            completedAbruptly = <span class="keyword">false</span>;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            processWorkerExit(w, completedAbruptly); <span class="comment">// 线程退出工作</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;runWorker的主要任务就是一直loop循环，来一个任务处理一个任务，没有任务就去getTask()，getTask()可能会阻塞，代码如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Runnable <span class="title">getTask</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">boolean</span> timedOut = <span class="keyword">false</span>; <span class="comment">// 上一次 poll() 是否超时</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">int</span> c = ctl.get();</span><br><span class="line">        <span class="keyword">int</span> rs = runStateOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否继续处理任务 可以参见上一篇的状态控制</span></span><br><span class="line">        <span class="comment">//两种情况：</span></span><br><span class="line">        <span class="comment">//rs &gt;= SHUTDOWN &amp;&amp; rs &gt;= STOP  STOP以上，不处理任务</span></span><br><span class="line">        <span class="comment">//rs &gt;= SHUTDOWN &amp;&amp; workQueue.isEmpty()  SHUTDOWN态不接收新任务，会处理队列中的任务，但此时队列为空</span></span><br><span class="line">        <span class="comment">//代码1</span></span><br><span class="line">        <span class="keyword">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class="line">            decrementWorkerCount();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> wc = workerCountOf(c);</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 是否允许超时</span></span><br><span class="line">        <span class="keyword">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class="line">            &amp;&amp; (wc &gt; <span class="number">1</span> || workQueue.isEmpty())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class="line">                <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Runnable r = timed ?</span><br><span class="line">                <span class="comment">//代码2</span></span><br><span class="line">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class="line">                workQueue.take();</span><br><span class="line">            <span class="keyword">if</span> (r != <span class="keyword">null</span>)</span><br><span class="line">                <span class="keyword">return</span> r;</span><br><span class="line">            timedOut = <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException retry) &#123;</span><br><span class="line">            timedOut = <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;代码1处指明了两种情况无法获取到新task：</p><ul><li>rs &gt;= SHUTDOWN &amp;&amp; rs &gt;= STOP  线程池状态为STOP、TIDYING或TERMINATED，不处理任何任务，包括任务队列中的任务</li><li>rs &gt;= SHUTDOWN &amp;&amp; workQueue.isEmpty()  SHUTDOWN态不接收新任务，会处理队列中的任务，但此时队列为空，没有新任务 </li></ul><p>&emsp;getTask()方法里面主要用我们配置的workQueue来工作，其阻塞原理与超时原理基于阻塞队列实现，这里不做详解。代码2处 workQueue.poll 方法是一个阻塞方法。</p><p>&emsp;总结，ThreadPoolExecutor的执行主要围绕Worker，Worker 实现了 AbstractQueuedSynchronizer 并继承了 Runnable，其对锁的妙运用，值得思考。</p><p>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.jianshu.com/p/23cb8b903d2c" target="_blank" rel="noopener">https://www.jianshu.com/p/23cb8b903d2c</a><br><a href="https://www.cnblogs.com/zaizhoumo/p/7794818.html" target="_blank" rel="noopener">https://www.cnblogs.com/zaizhoumo/p/7794818.html</a><br>《Java并发编程之美》</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池 之 ScheduledThreadPoolExecutor 概述</title>
      <link href="/java/java-scheduledthreadPoolExecutor/"/>
      <url>/java/java-scheduledthreadPoolExecutor/</url>
      
        <content type="html"><![CDATA[<h1 id="ScheduledThreadPoolExecutor-概述"><a href="#ScheduledThreadPoolExecutor-概述" class="headerlink" title="ScheduledThreadPoolExecutor 概述"></a>ScheduledThreadPoolExecutor 概述</h1><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h2><p>&emsp;ScheduledThreadPoolExecutor 与其他线程池的概念有些区别，它是一个支持任务周期性调度的线程池。ScheduledThreadPoolExecutor 继承 ThreadPoolExecutor，同时通过实现 ScheduledExecutorSerivce 来扩展基础线程池的功能，使其拥有了调度能力。其整个调度的核心在于内部类 DelayedWorkQueue ，一个有序的延时队列。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/java/ScheduledThreadPoolExecutor.png?raw=true" alt="ScheduledThreadPoolExecutor类图"></p><p>&emsp;ScheduledThreadPoolExecutor 的出现，很好的弥补了传统 Timer 的不足，具体对比看下表：</p><div class="table-container"><table><thead><tr><th></th><th>Timer</th><th>ScheduledThreadPoolExecutor</th></tr></thead><tbody><tr><td>线程</td><td>单线程</td><td>多线程</td></tr><tr><td>多任务</td><td>任务之间相互影响</td><td>任务之间不影响</td></tr><tr><td>调度时间</td><td>绝对时间</td><td>相对时间</td></tr><tr><td>异常</td><td>单任务异常，后续任务受影响</td><td>无影响</td></tr></tbody></table></div><h2 id="2-构造方法"><a href="#2-构造方法" class="headerlink" title="2. 构造方法"></a>2. 构造方法</h2><p>&emsp;ScheduledThreadPoolExecutor有三个构造形式：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                    ThreadFactory threadFactory)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), handler);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ScheduledThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">super</span>(corePoolSize, Integer.MAX_VALUE, <span class="number">0</span>, NANOSECONDS,</span><br><span class="line">          <span class="keyword">new</span> DelayedWorkQueue(), threadFactory, handler);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;关于父类的构造可参考文章<a href="http://zhoujiapeng.top/java/java-threadPoolExecutor-overview">《线程池 之 ThreadPoolExecutor 概述》</a>。我们也可以使用工具类Executors的newScheduledThreadPool的方法，快速创建。注意这里使用的<strong>DelayedWorkQueue</strong>。<br>&emsp;ScheduledThreadPoolExecutor没有提供带有最大线程数的构造函数的，默认是Integer.MAX_VALUE，说明其可以<strong>无限制的开启任意线程执行任务</strong>，在大量任务系统，应注意这一点，避免<strong>内存溢出</strong>。</p><h2 id="3-核心方法"><a href="#3-核心方法" class="headerlink" title="3. 核心方法"></a>3. 核心方法</h2><p>&emsp;核心方法主要介绍ScheduledThreadPoolExecutor的调度方法，其他方法与 ThreadPoolExecutor 一致。调度方法均由 ScheduledExecutorService 接口定义：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">ScheduledExecutorService</span> <span class="keyword">extends</span> <span class="title">ExecutorService</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 特定时间延时后执行一次Runnable</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; schedule(Runnable command,</span><br><span class="line">                                       <span class="keyword">long</span> delay, TimeUnit unit);</span><br><span class="line">    <span class="comment">// 特定时间延时后执行一次Callable</span></span><br><span class="line">    <span class="keyword">public</span> &lt;V&gt; <span class="function">ScheduledFuture&lt;V&gt; <span class="title">schedule</span><span class="params">(Callable&lt;V&gt; callable,</span></span></span><br><span class="line"><span class="function"><span class="params">                                           <span class="keyword">long</span> delay, TimeUnit unit)</span></span>;</span><br><span class="line">    <span class="comment">// 固定周期执行任务（与任务执行时间无关，周期是固定的）</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command,</span><br><span class="line">                                                  <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                  <span class="keyword">long</span> period,</span><br><span class="line">                                                  TimeUnit unit);</span><br><span class="line">     <span class="comment">// 固定延时执行任务（与任务执行时间有关，延时从上一次任务完成后开始）</span></span><br><span class="line">    <span class="keyword">public</span> ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command,</span><br><span class="line">                                                     <span class="keyword">long</span> initialDelay,</span><br><span class="line">                                                     <span class="keyword">long</span> delay,</span><br><span class="line">                                                     TimeUnit unit);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;代码中注释了每个方法的作用，需注意固定周期与固定延时的区别。下面分别对这些方法进行测试：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ScheduledPoolTest</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> SimpleDateFormat FORMAT = <span class="keyword">new</span> SimpleDateFormat(<span class="string">"hh:mm:ss"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> Random RANDOM = <span class="keyword">new</span> Random();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出：</span></span><br><span class="line"><span class="comment">     *  11:04:32</span></span><br><span class="line"><span class="comment">        11:04:35</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">schedule</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        printTime();</span><br><span class="line">        scheduledExecutorService.schedule(<span class="keyword">new</span> Task(), <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出：</span></span><br><span class="line"><span class="comment">     *  11:05:34</span></span><br><span class="line"><span class="comment">        11:05:36</span></span><br><span class="line"><span class="comment">        11:05:46</span></span><br><span class="line"><span class="comment">        11:05:56</span></span><br><span class="line"><span class="comment">        11:06:06</span></span><br><span class="line"><span class="comment">        11:06:16</span></span><br><span class="line"><span class="comment">        ......</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        printTime();</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Task(), <span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 输出：</span></span><br><span class="line"><span class="comment">     *  11:07:39</span></span><br><span class="line"><span class="comment">        11:07:41</span></span><br><span class="line"><span class="comment">        11:07:54</span></span><br><span class="line"><span class="comment">        11:08:08</span></span><br><span class="line"><span class="comment">        11:08:22</span></span><br><span class="line"><span class="comment">        11:08:33</span></span><br><span class="line"><span class="comment">        ......</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleWithFixedDelay</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        printTime();</span><br><span class="line">        scheduledExecutorService.scheduleWithFixedDelay(<span class="keyword">new</span> Task(), <span class="number">2</span>, <span class="number">10</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            printTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                Thread.sleep(RANDOM.nextInt(<span class="number">5</span>) * <span class="number">1000</span>);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">printTime</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Date date = <span class="keyword">new</span> Date();</span><br><span class="line">        System.out.println(FORMAT.format(date));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;为了体现scheduleAtFixedRate和scheduleWithFixedDelay的差别，在代码中我们加入了随机睡眠时间，使任务执行不确定。从注释中的输出我们可以看到scheduleAtFixedRate的任务运行周期不受任务执行时间的影响，而scheduleWithFixedDelay的任务运行周期受任务执行时间影响较大。</p><p>&emsp;但需注意，如果任务的执行时间超过任务调度周期，比如任务执行需要10s，而给定执行时间间隔是5s的话，任务的调度是在任务10s执行完之后立即重新执行，而不是5s的周期。例如将Task中休眠时间改为固定5秒，scheduleAtFixedRate 的频率改为1秒，则执行结果为每个任务执行5秒之后结束才会触发下一个任务启动，而不是每1秒启动一个任务：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">scheduleAtFixedRate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ScheduledExecutorService scheduledExecutorService = Executors.newScheduledThreadPool(<span class="number">1</span>);</span><br><span class="line">        printTime();</span><br><span class="line">        scheduledExecutorService.scheduleAtFixedRate(<span class="keyword">new</span> Task(), <span class="number">2</span>, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Task</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            printTime();</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="comment">//Thread.sleep(random.nextInt(5)*1000);</span></span><br><span class="line">                Thread.sleep(<span class="number">5000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h1 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h1><p>&emsp;ScheduledThreadPoolExecutor 在 ThreadPoolExecutor 的基础上扩展了线程周期调度功能，使用时应注意控制其调度的时间点。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>文章来源：<a href="https://www.jianshu.com/p/5d994ee6d4ff" target="_blank" rel="noopener">https://www.jianshu.com/p/5d994ee6d4ff</a><br>(文章仅做学习记录，如有侵权，请联系删除！)</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池 之 ThreadPoolExecutor 使用</title>
      <link href="/java/java-threadPoolExecutor-use/"/>
      <url>/java/java-threadPoolExecutor-use/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadPoolExecutor-使用"><a href="#ThreadPoolExecutor-使用" class="headerlink" title="ThreadPoolExecutor 使用"></a>ThreadPoolExecutor 使用</h1><h2 id="1-构造"><a href="#1-构造" class="headerlink" title="1. 构造"></a>1. 构造</h2><p>&emsp;ThreadPoolExecutor提供了四个构造方法：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/ThreadpoolExecutorConstructor.png?raw=true" alt="ThreadPoolExecutor构造方法"></p><p>&emsp;我们以最后一个构造方法（参数最多的那个），对其参数进行解释：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (corePoolSize &lt; <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt;= <span class="number">0</span> ||</span><br><span class="line">            maximumPoolSize &lt; corePoolSize ||</span><br><span class="line">            keepAliveTime &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException();</span><br><span class="line">        <span class="keyword">if</span> (workQueue == <span class="keyword">null</span> || threadFactory == <span class="keyword">null</span> || handler == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        <span class="keyword">this</span>.acc = System.getSecurityManager() == <span class="keyword">null</span> ?</span><br><span class="line">                <span class="keyword">null</span> :</span><br><span class="line">                AccessController.getContext();</span><br><span class="line">        <span class="keyword">this</span>.corePoolSize = corePoolSize;</span><br><span class="line">        <span class="keyword">this</span>.maximumPoolSize = maximumPoolSize;</span><br><span class="line">        <span class="keyword">this</span>.workQueue = workQueue;</span><br><span class="line">        <span class="keyword">this</span>.keepAliveTime = unit.toNanos(keepAliveTime);</span><br><span class="line">        <span class="keyword">this</span>.threadFactory = threadFactory;</span><br><span class="line">        <span class="keyword">this</span>.handler = handler;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>|  序号   | 名称  |      类型   | 含义  |<br>|  ——  | ——  |——  |——  |<br>| 1 | corePoolSize | int                    | 核心线程数量  |<br>| 2 | maximumPoolSize | int                    | 最大线程池大小  |<br>| 3 | keepAliveTime   | long                   | 线程最大空闲时间|<br>| 4 | unit            | TimeUnit               | 时间单位       |<br>| 5 | workQueue       | BlockingQueue<Runnable>| 线程等待队列    |<br>| 6 | threadFactory   | ThreadFactory          |线程创建工厂     |</p><p>&emsp;如果对这些参数作用有疑惑的请看 <a href="http://zhoujiapeng.top/java/java-threadPoolExecutor-overview/">ThreadPoolExecutor</a> 概述。知道了各个参数的作用后，我们开始构造符合我们期待的线程池。接下来我们看一下JDK预定义的几种线程池。</p><h2 id="2-预定义线程池"><a href="#2-预定义线程池" class="headerlink" title="2. 预定义线程池"></a>2. 预定义线程池</h2><h3 id="2-1-FixedThreadPool"><a href="#2-1-FixedThreadPool" class="headerlink" title="2.1 FixedThreadPool"></a>2.1 FixedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newFixedThreadPool</span><span class="params">(<span class="keyword">int</span> nThreads)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(nThreads, nThreads,</span><br><span class="line">                                      <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize与maximumPoolSize相等，即其线程全为核心线程，是一个<strong>固定大小</strong>的线程池，是其优势；</li><li>keepAliveTime = 0 该参数默认对核心线程无效，而FixedThreadPool<strong>全部为核心线程</strong>；</li><li>workQueue 为LinkedBlockingQueue（<strong>无界</strong>阻塞队列），队列最大值为Integer.MAX_VALUE。如果任务提交速度持续大余任务处理速度，会造成队列大量阻塞。因为队列很大，很有可能在拒绝策略前，内存溢出。是其劣势；</li><li>FixedThreadPool的任务执行是<strong>无序</strong>的；</li></ul><blockquote><p>适用场景：可用于Web服务瞬时削峰，但需注意长时间持续高峰情况造成的队列阻塞。</p></blockquote><p>&emsp;下面是一个简单的例子。创建一个可重用固定线程数的线程池，以共享的无界队列方式来运行这些线程。在任意点，在大多数 nThreads 线程会处于处理任务的活动状态。如果在所有线程处于活动状态时提交附加任务，则在有可用线程之前，附加任务将在队列中等待。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">**</span><br><span class="line">     * 创建固定大小的线程池</span><br><span class="line">     */</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createFixedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService fixedThreadPool = Executors.newFixedThreadPool(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> currentIndex = i;</span><br><span class="line">            fixedThreadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">", currentIndex is : "</span> + currentIndex);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"全部线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-2-CachedThreadPool"><a href="#2-2-CachedThreadPool" class="headerlink" title="2.2 CachedThreadPool"></a>2.2 CachedThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ThreadPoolExecutor(<span class="number">0</span>, Integer.MAX_VALUE,</span><br><span class="line">                                      <span class="number">60L</span>, TimeUnit.SECONDS,</span><br><span class="line">                                      <span class="keyword">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>corePoolSize = 0，maximumPoolSize = Integer.MAX_VALUE，即<strong>线程数量几乎无限制</strong>；</li><li>keepAliveTime = 60s，线程空闲60s后自动结束。</li><li>workQueue 为 SynchronousQueue 同步队列，这个队列类似于一个接力棒，入队出队必须<strong>同时传递</strong>，因为CachedThreadPool线程创建无限制，不会有队列等待，所以使用SynchronousQueue；</li></ul><blockquote><p>适用场景：快速处理大量耗时较短的任务，如Netty的NIO接受请求时，可使用CachedThreadPool。</p></blockquote><p>&emsp;下面是一个简单的例子。创建一个可缓存的无界线程池，该方法无参数。当线程池中的线程空闲时间超过60s则会自动回收该线程，当任务超过线程池的线程数则创建新线程。线程池的大小上限为Integer.MAX_VALUE，可看做是无限大。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建无边界大小的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createCachedThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService cachedThreadPool = Executors.newCachedThreadPool();</span><br><span class="line">        <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">int</span> currentIndex = i;</span><br><span class="line">            cachedThreadPool.execute(() -&gt; &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">", currentIndex is : "</span> + currentIndex);</span><br><span class="line">                countDownLatch.countDown();</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            countDownLatch.await();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"全部线程执行完毕"</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-3-SingleThreadExecutor"><a href="#2-3-SingleThreadExecutor" class="headerlink" title="2.3 SingleThreadExecutor"></a>2.3 SingleThreadExecutor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ExecutorService <span class="title">newSingleThreadExecutor</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> FinalizableDelegatedExecutorService</span><br><span class="line">            (<span class="keyword">new</span> ThreadPoolExecutor(<span class="number">1</span>, <span class="number">1</span>,</span><br><span class="line">                                    <span class="number">0L</span>, TimeUnit.MILLISECONDS,</span><br><span class="line">                                    <span class="keyword">new</span> LinkedBlockingQueue&lt;Runnable&gt;()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><ul><li>单线程 (corePoolSize\==maximumPoolSize==1)</li><li>无界队列 (LinkedBlockingQueue)</li></ul><p>&emsp;这里使用了newFixedThreadPool(1)，但是多了一层 FinalizableDelegatedExecutorService 包装，这一层有什么用呢，写个dome来解释一下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ExecutorService fixedExecutorService = Executors.newFixedThreadPool(<span class="number">1</span>);</span><br><span class="line">        ThreadPoolExecutor threadPoolExecutor = (ThreadPoolExecutor) fixedExecutorService;</span><br><span class="line">        System.out.println(threadPoolExecutor.getMaximumPoolSize());</span><br><span class="line">        threadPoolExecutor.setCorePoolSize(<span class="number">8</span>);</span><br><span class="line">        </span><br><span class="line">        ExecutorService singleExecutorService = Executors.newSingleThreadExecutor();</span><br><span class="line"><span class="comment">//      运行时异常 java.lang.ClassCastException</span></span><br><span class="line"><span class="comment">//      ThreadPoolExecutor threadPoolExecutor2 = (ThreadPoolExecutor) singleExecutorService;</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;对比可以看出，FixedThreadPool可以向下转型为ThreadPoolExecutor，并对其线程池进行配置，而SingleThreadExecutor被包装后，无法成功向下转型。因此，SingleThreadExecutor被确定以后，无法修改，做到了真正的Single。看一下它们的继承关系可能会更加清晰：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">graph LR;</span><br><span class="line">    ThreadPoolExecutor &#x3D;&#x3D;&gt; AbstractExecutorService</span><br><span class="line">    AbstractExecutorService &#x3D;&#x3D;&gt; ExecutorService</span><br><span class="line">    FinalizableDelegatedExecutorService &#x3D;&#x3D;&gt; DelegatedExecutorService</span><br><span class="line">    DelegatedExecutorService &#x3D;&#x3D;&gt; AbstractExecutorService</span><br></pre></td></tr></table></figure><p>&emsp;可以看到 ThreadPoolExecutor 和 FinalizableDelegatedExecutorService 之间并没有继承关系，因此无法直接相互转换。</p><p>&emsp;下面是一个简单的例子。创建一个单线程的线程池，以无界队列方式来运行该线程。当多个任务提交到单线程线程池中，线程池将逐个去进行执行，未执行的任务将放入无界队列进行等待。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建单线程的线程池</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createSingleThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        ExecutorService singleThreadPool = Executors.newSingleThreadExecutor();</span><br><span class="line">        singleThreadPool.execute(()-&gt; System.out.println(Thread.currentThread().getName()));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-4-ScheduledThreadPool"><a href="#2-4-ScheduledThreadPool" class="headerlink" title="2.4 ScheduledThreadPool"></a>2.4 ScheduledThreadPool</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> ScheduledExecutorService <span class="title">newScheduledThreadPool</span><span class="params">(<span class="keyword">int</span> corePoolSize)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> ScheduledThreadPoolExecutor(corePoolSize);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>&emsp;newScheduledThreadPool调用的是ScheduledThreadPoolExecutor的构造方法，而ScheduledThreadPoolExecutor继承了ThreadPoolExecutor，构造是还是调用了其父类的构造方法。<br>&emsp;更多关于 ScheduledThreadPoolExecutor 的介绍可以参考文章<a href="http://zhoujiapeng.top/java/java-scheduledthreadPoolExecutor/">《线程池 之 ScheduledThreadPoolExecutor概述》</a>。</p><p>&emsp;下面是一个简单的例子。创建一个线程池，它可安排在给定延迟后运行命令或者定期地执行。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * 创建给定延迟后运行命令或者定期地执行的线程池</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">createScheduledThreadPool</span><span class="params">()</span> </span>&#123;</span><br><span class="line">       ScheduledExecutorService scheduledThreadPool = Executors.newScheduledThreadPool(<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">final</span> CountDownLatch countDownLatch = <span class="keyword">new</span> CountDownLatch(<span class="number">5</span>);</span><br><span class="line">       <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">final</span> <span class="keyword">int</span> currentIndex = i;</span><br><span class="line">           <span class="comment">//定时执行一次的任务，延迟1s后执行</span></span><br><span class="line">           scheduledThreadPool.schedule(() -&gt; &#123;</span><br><span class="line">               System.out.println(Thread.currentThread().getName() + <span class="string">", currentIndex is : "</span> + currentIndex);</span><br><span class="line">               countDownLatch.countDown();</span><br><span class="line">           &#125;, <span class="number">1</span>, TimeUnit.SECONDS);</span><br><span class="line">           <span class="comment">//周期性地执行任务，延迟2s后，每3s一次地周期性执行任务</span></span><br><span class="line">           scheduledThreadPool.scheduleAtFixedRate(() -&gt; System.out.println(Thread.currentThread().getName() + <span class="string">"every 3s"</span>), <span class="number">2</span>, <span class="number">3</span>, TimeUnit.SECONDS);</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-5-四种线程池对比"><a href="#2-5-四种线程池对比" class="headerlink" title="2.5 四种线程池对比"></a>2.5 四种线程池对比</h3><div class="table-container"><table><thead><tr><th>线程池方法</th><th>初始化线程池数</th><th>最大线程池数</th><th>线程池中线程存活时间</th><th>时间单位</th><th>工作队列</th></tr></thead><tbody><tr><td>newCachedThreadPool</td><td>0</td><td>Integer.MAX_VALUE</td><td>60</td><td>秒</td><td>SynchronousQueue</td></tr><tr><td>newFixedThreadPool</td><td>入参指定大小</td><td>入参指定大小</td><td>0</td><td>毫秒</td><td>LinkedBlockingQueue</td></tr><tr><td>newScheduledThreadPool</td><td>入参指定大小</td><td>Integer.MAX_VALUE</td><td>0</td><td>微秒</td><td>DelayedWorkQueue</td></tr><tr><td>newSingleThreadExecutor</td><td>1</td><td>1</td><td>0</td><td>毫秒</td><td>LinkedBlockingQueue</td></tr></tbody></table></div><h2 id="3-自定义线程池"><a href="#3-自定义线程池" class="headerlink" title="3. 自定义线程池"></a>3. 自定义线程池</h2><p>&emsp;ThreadPoolExecutor的构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><br>&emsp;各个参数的含义为：</p><ul><li>corePoolSize - 池中所保存的线程数，包括空闲线程，必须大于或等于0。</li><li>maximumPoolSize - 池中允许的最大线程数，必须大于或等于corePoolSize。</li><li>keepAliveTime - 线程存活时间，当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</li><li>unit - keepAliveTime 参数的时间单位，必须大于或等于0。</li><li>workQueue - 工作队列，执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。</li><li>threadFactory - 执行程序创建新线程时使用的工厂，默认为DefaultThreadFactory类。</li><li>handler - 拒绝策略，由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序，默认策略为ThreadPoolExecutor.AbortPolicy。</li></ul><p>&emsp;下面是自定义的线程池，使用了有界队列，自定义ThreadFactory和拒绝策略：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomizeThreadPool</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自定义ThreadFactory</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyThreadFactory</span> <span class="keyword">implements</span> <span class="title">ThreadFactory</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">final</span> AtomicInteger mThreadNum = <span class="keyword">new</span> AtomicInteger(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> Thread <span class="title">newThread</span><span class="params">(Runnable r)</span> </span>&#123;</span><br><span class="line">            Thread t = <span class="keyword">new</span> Thread(r,<span class="string">"my-thread-"</span> + mThreadNum.getAndIncrement());</span><br><span class="line">            System.out.println(t.getName() + <span class="string">" has been created!"</span>);</span><br><span class="line">            <span class="keyword">return</span> t;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//自定义拒绝策略</span></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyIgnorePolicy</span> <span class="keyword">implements</span> <span class="title">RejectedExecutionHandler</span></span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">rejectedExecution</span><span class="params">(Runnable r, ThreadPoolExecutor executor)</span> </span>&#123;</span><br><span class="line">            doLog(r,executor);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doLog</span><span class="params">(Runnable r,ThreadPoolExecutor e)</span></span>&#123;</span><br><span class="line">            System.out.println(r.toString() + <span class="string">" rejected!"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MyTask</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">MyTask</span><span class="params">(String name)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.name = name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                System.out.println(<span class="keyword">this</span>.toString() + <span class="string">" is running on "</span> + Thread.currentThread().getName());</span><br><span class="line">                Thread.sleep(<span class="number">3000</span>);</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e)&#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> name;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"MyTask [name = "</span> + name + <span class="string">" ]"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> corePoolSize = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">int</span> maximumPoolSize = <span class="number">4</span>;</span><br><span class="line">        <span class="keyword">long</span> keepAliveTime = <span class="number">10</span>;</span><br><span class="line">        TimeUnit unit = TimeUnit.SECONDS;</span><br><span class="line">        BlockingQueue&lt;Runnable&gt; workQueue = <span class="keyword">new</span> ArrayBlockingQueue&lt;&gt;(<span class="number">2</span>);</span><br><span class="line">        ThreadFactory threadFactory = <span class="keyword">new</span> MyThreadFactory();</span><br><span class="line">        RejectedExecutionHandler handler = <span class="keyword">new</span> MyIgnorePolicy();</span><br><span class="line">        ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,</span><br><span class="line">                unit,workQueue,threadFactory,handler)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.terminated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">        <span class="comment">//预启动所有核心线程</span></span><br><span class="line">        executor.prestartAllCoreThreads();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;<span class="number">10</span>;i++)&#123;</span><br><span class="line">            MyTask task = <span class="keyword">new</span> MyTask(String.valueOf(i));</span><br><span class="line">            executor.execute(task);</span><br><span class="line">        &#125;</span><br><span class="line">        System.in.read(); <span class="comment">//阻塞主线程</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;执行结果为：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">my-thread-1 has been created!</span><br><span class="line">my-thread-2 has been created!</span><br><span class="line">my-thread-3 has been created!</span><br><span class="line">MyTask [name &#x3D; 1 ] is running on my-thread-1</span><br><span class="line">MyTask [name &#x3D; 2 ] is running on my-thread-2</span><br><span class="line">my-thread-4 has been created!</span><br><span class="line">MyTask [name &#x3D; 3 ] is running on my-thread-3</span><br><span class="line">MyTask [name &#x3D; 7 ] rejected!</span><br><span class="line">MyTask [name &#x3D; 6 ] is running on my-thread-4</span><br><span class="line">MyTask [name &#x3D; 8 ] rejected!</span><br><span class="line">MyTask [name &#x3D; 9 ] rejected!</span><br><span class="line">MyTask [name &#x3D; 4 ] is running on my-thread-2</span><br><span class="line">MyTask [name &#x3D; 5 ] is running on my-thread-1</span><br></pre></td></tr></table></figure><br>&emsp;corePoolSize为2，一开始会依次创建两个线程执行task1和task2，接下来task3和task4会进入队列，task5和task6进来之后，由于maximumPoolSize为4，因此继续会创建两个线程，之后线程数量达到了maximumPoolSize，并且任务队列也满了，因此task7、8、9会被拒绝。<br>&emsp;通过自定义线程池，我们可以更好的让线程池为我们所用，更加适应我的实际场景。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考：<br><a href="https://www.jianshu.com/p/f030aa5d7a28" target="_blank" rel="noopener">https://www.jianshu.com/p/f030aa5d7a28</a><br><a href="https://blog.csdn.net/wtopps/article/details/80682267" target="_blank" rel="noopener">https://blog.csdn.net/wtopps/article/details/80682267</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线程池 之 ThreadPoolExecutor 概述</title>
      <link href="/java/java-threadPoolExecutor-overview/"/>
      <url>/java/java-threadPoolExecutor-overview/</url>
      
        <content type="html"><![CDATA[<h1 id="ThreadPoolExecutor-概述"><a href="#ThreadPoolExecutor-概述" class="headerlink" title="ThreadPoolExecutor 概述"></a>ThreadPoolExecutor 概述</h1><p>&emsp;合理利用线程池能够带来三个好处。第一：降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。第二：提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。第三：提高线程的可管理性。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。但是要做到合理的利用线程池，必须对其原理了如指掌。</p><h2 id="1-创建线程池"><a href="#1-创建线程池" class="headerlink" title="1. 创建线程池"></a>1. 创建线程池</h2><p>&emsp;查看源码，我们可以知道 ThreadPoolExecutor 的继承关系如图。<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/ThreadPoolExecutor.png?raw=true" alt="ThreadPoolExecutor"></p><p>&emsp;ExecutorService（ThreadPoolExecutor的顶层接口）使用线程池中的线程执行每个提交的任务，通常我们使用Executors的工厂方法来创建ExecutorService。<br>&emsp;线程池解决了两个不同的问题：</p><ul><li>提升性能：它们通常在执行大量异步任务时，由于减少了每个任务的调用开销，并且它们提供了一种限制和管理资源（包括线程）的方法，使得性能提升明显；</li><li>统计信息：每个ThreadPoolExecutor保持一些基本的统计信息，例如完成的任务数量。</li></ul><p>&emsp;为了在广泛的上下文中有用，此类提供了许多可调参数和可扩展性钩子。 java 源码中预配置了几种线程池，可以通过 Executors 的工厂方法直接使用。</p><ul><li>Executors.newCachedThreadPool（无界线程池，自动线程回收）</li><li>Executors.newFixedThreadPool（固定大小的线程池）；</li><li>Executors.newSingleThreadExecutor（单一后台线程）；</li><li>Executors.newScheduledThreadPool（创建定时任务）；</li></ul><h2 id="2-自定义线程池"><a href="#2-自定义线程池" class="headerlink" title="2. 自定义线程池"></a>2. 自定义线程池</h2><p>&emsp;我们可以通过 ThreadPoolExecutor 来自定义线程池，下面是它的构造方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">ThreadPoolExecutor</span><span class="params">(<span class="keyword">int</span> corePoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">int</span> maximumPoolSize,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">long</span> keepAliveTime,</span></span></span><br><span class="line"><span class="function"><span class="params">                              TimeUnit unit,</span></span></span><br><span class="line"><span class="function"><span class="params">                              BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class="line"><span class="function"><span class="params">                              ThreadFactory threadFactory,</span></span></span><br><span class="line"><span class="function"><span class="params">                              RejectedExecutionHandler handler)</span></span></span><br></pre></td></tr></table></figure><br>&emsp;各个参数的含义:</p><ul><li>corePoolSize - 池中所保存的线程数，包括空闲线程，必须大于或等于0。</li><li>maximumPoolSize - 池中允许的最大线程数，必须大于或等于corePoolSize。</li><li>keepAliveTime - 线程存活时间，当线程数大于核心时，此为终止前多余的空闲线程等待新任务的最长时间。</li><li>unit - keepAliveTime 参数的时间单位，必须大于或等于0。</li><li>workQueue - 工作队列，执行前用于保持任务的队列。此队列仅保持由 execute 方法提交的 Runnable 任务。</li><li>threadFactory - 执行程序创建新线程时使用的工厂，默认为DefaultThreadFactory类。</li><li>handler - 拒绝策略，由于超出线程范围和队列容量而使执行被阻塞时所使用的处理程序，默认策略为ThreadPoolExecutor.AbortPolicy。</li></ul><h3 id="2-1-corePoolSize-和-maximumPoolSize"><a href="#2-1-corePoolSize-和-maximumPoolSize" class="headerlink" title="2.1 corePoolSize 和 maximumPoolSize"></a>2.1 corePoolSize 和 maximumPoolSize</h3><div class="table-container"><table><thead><tr><th>参数</th><th>翻译</th></tr></thead><tbody><tr><td>corePoolSize</td><td>核心线程池数量</td></tr><tr><td>maximumPoolSize</td><td>最大线程池数量</td></tr></tbody></table></div><p>&emsp;ThreadPoolExecutor 将会根据corePoolSize和maximumPoolSize自动地调整线程池大小。</p><p>&emsp;当使用 execute(Runnable) 方法中提交新任务并且少于 corePoolSize 线程正在运行时，即使其他工作线程处于空闲状态，也会创建一个新线程来处理该请求。 如果有多于corePoolSize 但小于 maximumPoolSize 线程正在运行，则仅当队列已满时才会创建新线程。 通过设置 corePoolSize 和 maximumPoolSize 相同，可以创建一个固定大小的线程池。 通过将 maximumPoolSize 设置为基本上无界的值，例如 Integer.MAX_VALUE，可以允许池容纳任意数量的并发任务。 通常，核心和最大池大小仅在构建时设置，但也可以使用 setCorePoolSize 和 setMaximumPoolSize 进行动态更改。</p><p>&emsp;这段话详细了描述了线程池对任务的处理流程，这里用个图总结一下:<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/thread-process-task.png?raw=true" alt="线程任务处理流程"></p><h3 id="2-2-prestartCoreThread-核心线程预启动"><a href="#2-2-prestartCoreThread-核心线程预启动" class="headerlink" title="2.2 prestartCoreThread 核心线程预启动"></a>2.2 prestartCoreThread 核心线程预启动</h3><p>&emsp;在默认情况下，只有当新任务到达时，才开始创建和启动核心线程，但是我们可以使用 prestartCoreThread() 和 prestartAllCoreThreads() 方法动态调整。<br>&emsp;如果使用非空队列构建池，则可能需要预先启动线程。<br>|  方法   | 作用  |<br>|  ——  | ——  |<br>| prestartCoreThread()  | 创建一个空闲任务线程等待任务的到达 |<br>| prestartAllCoreThreads()  | 创建核心线程池数量的空闲任务线程等待任务的到达 |</p><h3 id="2-3-ThreadFactory-线程工厂"><a href="#2-3-ThreadFactory-线程工厂" class="headerlink" title="2.3 ThreadFactory 线程工厂"></a>2.3 ThreadFactory 线程工厂</h3><p>&emsp;新线程使用 ThreadFactory 创建。 如果未另行指定，则使用 Executors.defaultThreadFactory 默认工厂，使其全部位于同一个 ThreadGroup 中，并且具有相同的NORM_PRIORITY 优先级和非守护进程状态。</p><p>&emsp;通过自定义的 ThreadFactory，我们可以更改线程的名称，线程组，优先级，守护进程状态等。如果 ThreadFactory 的 newThread 方法返回 null，executor 会继续运行，但可能无法执行任何任务。</p><h3 id="2-4-Keep-alive-times-线程存活时间"><a href="#2-4-Keep-alive-times-线程存活时间" class="headerlink" title="2.4 Keep-alive times 线程存活时间"></a>2.4 Keep-alive times 线程存活时间</h3><p>&emsp;如果线程池当前拥有超过 corePoolSize 的线程，那么多余的线程在空闲时间超过 keepAliveTime 时会被终止。这提供了一种在线程池不活跃时减少资源消耗的方法。<br>&emsp;如果线程池变得更加活跃，则应构建新线程。 也可以使用方法 setKeepAliveTime(long，TimeUnit) 的方法进行动态调整。为了防止空闲线程在关闭之前终止，可以使用如下方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">setKeepAliveTime(Long.MAX_VALUE，TimeUnit.NANOSECONDS);</span><br></pre></td></tr></table></figure><br>&emsp;默认情况下，keep-alive 策略仅适用于存在超过 corePoolSize 线程的情况。 但是，只要 keepAliveTime 值不为零，方法 allowCoreThreadTimeOut(boolean) 也可用于将此超时策略应用于核心线程。</p><h3 id="2-5-Queuing-队列"><a href="#2-5-Queuing-队列" class="headerlink" title="2.5 Queuing 队列"></a>2.5 Queuing 队列</h3><p>&emsp;workQueue 的类型是 BlockingQueue<Runnable>，用于存放提交的任务，队列的实际容量与线程池大小相关联。</p><ul><li>如果当前线程池任务线程数量小于核心线程池数量，执行器总是优先创建一个任务线程，而不是从线程队列中取一个空闲线程。</li><li>如果当前线程池任务线程数量大于核心线程池数量，执行器总是优先从线程队列中取一个空闲线程，而不是创建一个任务线程。</li><li>如果当前线程池任务线程数量大于核心线程池数量，且队列中无空闲任务线程，将会创建一个任务线程，直到超出 maximumPoolSize，如果超出 maximumPoolSize，则任务将会被拒绝。通过设定的拒绝策略来处理。</li></ul><p>这个过程参考2.1中的线程任务处理流程图。</p><p>&emsp;主要有三种队列策略：</p><ul><li><p>Direct handoffs 直接握手队列<br>&emsp;Direct handoffs 工作队列的默认选项是<strong>SynchronousQueue</strong>，它将任务直接提交给线程而不保持它们。在此，如果不存在可用于立即运行任务的线程，则试图把任务加入队列将失败，因此会构造一个新的线程。此策略可以避免在处理可能具有内部依赖性的请求集时出现锁。直接提交通常要求无界 maximumPoolSizes以避免拒绝新提交的任务(<strong>线程数量足够多</strong>)。当命令以超过队列所能处理的平均数连续到达时，此策略允许无界线程具有增长的可能性。</p></li><li><p>Unbounded queues 无界队列<br>&emsp;使用无界队列（例如，不具有预定义容量的<strong>LinkedBlockingQueue</strong>）将导致在所有 corePoolSize 线程都忙时新任务在队列中等待。这样，<strong>创建的线程就不会超过 corePoolSize</strong>。（因此，maximumPoolSize 的值也就无效了。）当每个任务完全独立于其他任务，即任务执行互不影响时，适合于使用无界队列；例如，在 Web 页服务器中。这种排队可用于处理瞬态突发请求，当命令以超过队列所能处理的平均数连续到达时，此策略允许<strong>无界线程</strong>具有增长的可能性。</p></li><li><p>Bounded queues 有界队列<br>&emsp;一个有界的队列（例如<strong>ArrayBlockingQueue</strong>）配置有限的 maximumPoolSizes 配置有助于防止资源耗尽，但是难以控制。队列大小和 maximumPoolSizes 需要相互权衡：<br>&emsp;使用大队列和较小的 maximumPoolSizes 可以最大限度地减少CPU使用率，操作系统资源和上下文切换开销，但会导致人为的低吞吐量。如果任务经常被阻塞（比如I/O限制），那么我们可能需要配置更多的线程提供给系统调用；<br>&emsp;使用小队列通常需要较大的 maximumPoolSizes，这会使得CPU更繁忙，产生大量的调度开销，这也会降低吞吐量。</p></li></ul><h3 id="2-6-Rejected-tasks-拒绝任务策略"><a href="#2-6-Rejected-tasks-拒绝任务策略" class="headerlink" title="2.6 Rejected tasks 拒绝任务策略"></a>2.6 Rejected tasks 拒绝任务策略</h3><p>&emsp;拒绝策略通过RejectedExecutionHandler参数配置。拒绝任务有两种情况：1. 线程池已经被关闭；2. 任务队列已满且 maximumPoolSizes 已满；<br>无论哪种情况，都会调用RejectedExecutionHandler的rejectedExecution方法。预定义了四种处理策略：</p><ul><li>AbortPolicy：默认的饱和策略，直接抛出RejectedExecutionException异常。</li><li>CallerRunsPolicy：用调用者所在的线程来执行任务，此策略提供简单的反馈控制机制，能够减缓新任务的提交速度。</li><li>DiscardPolicy：直接丢弃新提交的任务；</li><li>DiscardOldestPolicy：如果执行程序尚未关闭，则丢弃阻塞队列中最靠前的任务，然后重试执行新任务（如果再次失败，则重复此过程）。</li></ul><p>&emsp;我们可以自己定义RejectedExecutionHandler，以适应特殊的容量和队列策略场景中,但需要非常小心，尤其是当策略仅用于特定容量或排队策略时。</p><p>&emsp;关于阻塞队列的更多介绍可以参考文章<a href="http://zhoujiapeng.top/java/java-blockingQueue/">《Java 阻塞队列》</a>。</p><h3 id="2-7-Hook-methods-钩子方法"><a href="#2-7-Hook-methods-钩子方法" class="headerlink" title="2.7 Hook methods 钩子方法"></a>2.7 Hook methods 钩子方法</h3><p>&emsp;ThreadPoolExecutor为提供了每个任务执行前后提供了钩子方法，重写beforeExecute(Thread，Runnable)和afterExecute(Runnable，Throwable)方法来操纵执行环境； 例如，重新初始化ThreadLocals，收集统计信息或记录日志等。此外，terminated()在Executor完全终止后需要完成后会被调用，可以重写此方法，以执行任殊处理。</p><blockquote><p>注意：如果hook或回调方法抛出异常，内部的任务线程将会失败并结束。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">ThreadPoolExecutor executor = <span class="keyword">new</span> ThreadPoolExecutor(corePoolSize,maximumPoolSize,keepAliveTime,</span><br><span class="line">                unit,workQueue,threadFactory,handler)&#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">beforeExecute</span><span class="params">(Thread t, Runnable r)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.beforeExecute(t, r);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">afterExecute</span><span class="params">(Runnable r, Throwable t)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.afterExecute(r, t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">terminated</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">super</span>.terminated();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p></blockquote><h3 id="2-8-Queue-maintenance-维护队列"><a href="#2-8-Queue-maintenance-维护队列" class="headerlink" title="2.8 Queue maintenance 维护队列"></a>2.8 Queue maintenance 维护队列</h3><p>&emsp;getQueue()方法可以访问任务队列，一般用于监控和调试。绝不建议将这个方法用于其他目的。当在大量的队列任务被取消时，remove()和purge()方法可用于回收空间。</p><h3 id="2-9-Finalization-关闭"><a href="#2-9-Finalization-关闭" class="headerlink" title="2.9 Finalization 关闭"></a>2.9 Finalization 关闭</h3><p>&emsp;如果程序中不再持有线程池的引用，并且线程池中没有线程时，线程池将会自动关闭。如果希望确保即使用户忘记调用 shutdown()方法也可以回收未引用的线程池，那么必须通过设置适当的 keep-alive times 并设置allowCoreThreadTimeOut(boolean)。一般情况下，线程池启动后建议手动调用shutdown()关闭。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>参考 :<br>ThreadPoolExecutor.java 源码注释<br><a href="https://www.jianshu.com/p/c41e942bcd64" target="_blank" rel="noopener">https://www.jianshu.com/p/c41e942bcd64</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> 并发 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java 自动装箱的陷阱</title>
      <link href="/java/java-risk-of-autoboxing/"/>
      <url>/java/java-risk-of-autoboxing/</url>
      
        <content type="html"><![CDATA[<h1 id="Java-自动装箱的陷阱"><a href="#Java-自动装箱的陷阱" class="headerlink" title="Java 自动装箱的陷阱"></a>Java 自动装箱的陷阱</h1><h2 id="1-自动装箱"><a href="#1-自动装箱" class="headerlink" title="1. 自动装箱"></a>1. 自动装箱</h2><p>&emsp;自动装箱、拆箱是Java语言中使用的最多的语法糖之一。装箱就是自动将基本数据类型转换为包装器类型；拆箱就是自动将包装器类型转换为基本数据类型。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//自动装箱</span></span><br><span class="line">    Integer total = <span class="number">99</span>;</span><br><span class="line">    <span class="comment">//自定拆箱</span></span><br><span class="line">    <span class="keyword">int</span> totalprim = total;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;下面看一下需要装箱拆箱的类型有哪些：<br><img src="https://gitee.com/JP6907/Pic/raw/master/java/java-auto-boxing-type" alt="java-auto-boxing-type"></p><h2 id="2-自动装箱的过程"><a href="#2-自动装箱的过程" class="headerlink" title="2. 自动装箱的过程"></a>2. 自动装箱的过程</h2><p>&emsp;下面我们看一下自动装箱、拆箱的具体过程。执行下面语句，查看 main 函数的字节码<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">javac AutoBoxing.java</span><br><span class="line">javap -verbose AutoBoxing</span><br></pre></td></tr></table></figure><br>&emsp;下面是 main 函数的字节码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">public static void main(java.lang.String[]);</span><br><span class="line">    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V</span><br><span class="line">            flags: ACC_PUBLIC, ACC_STATIC</span><br><span class="line">            Code:</span><br><span class="line">            stack&#x3D;1, locals&#x3D;3, args_size&#x3D;1</span><br><span class="line">            0: bipush        99</span><br><span class="line">            2: invokestatic  #2                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Integer.valueOf:(I)Ljava&#x2F;lang&#x2F;Integer;</span><br><span class="line">            5: astore_1</span><br><span class="line">            6: aload_1</span><br><span class="line">            7: invokevirtual #3                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Integer.intValue:()I</span><br><span class="line">            10: istore_2</span><br><span class="line">            11: return</span><br><span class="line">            LineNumberTable:</span><br><span class="line">            line 7: 0</span><br><span class="line">            line 9: 6</span><br><span class="line">            line 10: 11</span><br></pre></td></tr></table></figure><br>&emsp;bipush 将 99 放到栈顶，接下来使用 invokestatic，这里会调用了 Integer.valueOf 的静态方法，栈顶的数据作为参数，即这里实际执行的是 Integer.valueOf(99) 语句，这就是自动装箱的过程。接下来 astore_1 将 total 的引用放到栈顶，aload_1 将栈顶total的引用加载到了 slot1，接下来 invokevirtual 会调用 Integer.intValue 方法，即 total.intValue() 方法，istore_2 将该值放到了 slot2，即赋值给了totalprim，这里就完成了拆箱的过程。</p><h2 id="3-自动装箱的陷阱"><a href="#3-自动装箱的陷阱" class="headerlink" title="3. 自动装箱的陷阱"></a>3. 自动装箱的陷阱</h2><p>&emsp;自动装箱、拆箱这些语法糖看似很简单，但这里面有很多我们需要注意的地方，下面代码演示了自动装箱的一些错误用法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span></span>&#123;</span><br><span class="line">        Integer a = <span class="number">1</span>;  </span><br><span class="line">        Integer b = <span class="number">2</span>;  </span><br><span class="line">        Integer c = <span class="number">3</span>;  </span><br><span class="line">        Integer d = <span class="number">3</span>;  </span><br><span class="line">        Integer e = <span class="number">128</span>; </span><br><span class="line">        Integer f = <span class="number">128</span>;  </span><br><span class="line">        Long g = <span class="number">3L</span>;</span><br><span class="line">        System.out.println(c == d); <span class="comment">//true  </span></span><br><span class="line">        System.out.println(e == f); <span class="comment">//false  </span></span><br><span class="line">        System.out.println(c == (a+b)); <span class="comment">//true  </span></span><br><span class="line">        System.out.println(c.equals(a+b)); <span class="comment">//true  </span></span><br><span class="line">        System.out.println(g == (a+b)); <span class="comment">//true </span></span><br><span class="line">        System.out.println(g.equals(a+b)); <span class="comment">//false </span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这样的答案可能会出乎很多人的意料，接下来一一分析。<br>&emsp;首先明确一下 “\==” 和 equals 方法的用法。<br>&emsp;”\==”：如果是基本数据类型，则直接对值进行比较，如果是引用数据类型，则是对他们的地址进行比较（但是只能比较相同类型的对象，或者比较父类对象和子类对象。类型不同的两个对象不能使用==）。<br>&emsp;equals：装箱类型重写了 equals 方法，比较规则为：如果两个对象的类型一致，并且内容一致，则返回true。以 Integer 为例：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">equals</span><span class="params">(Object obj)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (obj <span class="keyword">instanceof</span> Integer) &#123;</span><br><span class="line">            <span class="keyword">return</span> value == ((Integer)obj).intValue();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;由前面分析可知，自动装箱的时候实际调用了 Integer.valueOf 方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Integer.java</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Integer <span class="title">valueOf</span><span class="params">(<span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)</span><br><span class="line">            <span class="keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Integer(i);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;IntegerCache 是 Integer 内部定义的一个私有静态内部类：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">IntegerCache</span> </span>&#123;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> low = -<span class="number">128</span>;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> high;</span><br><span class="line">        <span class="keyword">static</span> <span class="keyword">final</span> Integer cache[];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">static</span> &#123;</span><br><span class="line">            <span class="comment">// high value may be configured by property</span></span><br><span class="line">            <span class="keyword">int</span> h = <span class="number">127</span>;</span><br><span class="line">            String integerCacheHighPropValue =</span><br><span class="line">                sun.misc.VM.getSavedProperty(<span class="string">"java.lang.Integer.IntegerCache.high"</span>);</span><br><span class="line">            <span class="keyword">if</span> (integerCacheHighPropValue != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = parseInt(integerCacheHighPropValue);</span><br><span class="line">                    i = Math.max(i, <span class="number">127</span>);</span><br><span class="line">                    <span class="comment">// Maximum array size is Integer.MAX_VALUE</span></span><br><span class="line">                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="number">1</span>);</span><br><span class="line">                &#125; <span class="keyword">catch</span>( NumberFormatException nfe) &#123;</span><br><span class="line">                    <span class="comment">// If the property cannot be parsed into an int, ignore it.</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            high = h;</span><br><span class="line"></span><br><span class="line">            cache = <span class="keyword">new</span> Integer[(high - low) + <span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> j = low;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; cache.length; k++)</span><br><span class="line">                cache[k] = <span class="keyword">new</span> Integer(j++);</span><br><span class="line"></span><br><span class="line">            <span class="comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span></span><br><span class="line">            <span class="keyword">assert</span> IntegerCache.high &gt;= <span class="number">127</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="title">IntegerCache</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;通过观察上面的代码我们可以发现，Integer使用一个内部静态类中的一个静态数组（Integer cache[]）保存了-128-127范围内的数据，静态数组在类加载以后是存在方法区的，并不是什么常量池。在自动装箱的时候，首先判断要装箱的数字的范围，如果在-128-127的范围则直接返回缓存中已有的对象，否则new一个新的对象。其他的包装类也有类似的实现方式。<br>&emsp;需要注意几点：</p><ul><li>包装类的 == 运算在不遇到算术运算的情况下不会自动拆箱</li><li>类之间 == 比较的是地址</li><li>包装类的 equals 方法不处理数据转型的关系</li></ul><p>&emsp;因此，我们有以下分析：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Integer a = <span class="number">1</span>;  <span class="comment">//直接获取IntegerCache内部的对象</span></span><br><span class="line">Integer b = <span class="number">2</span>;  <span class="comment">//直接获取IntegerCache内部的对象</span></span><br><span class="line">Integer c = <span class="number">3</span>;  <span class="comment">//直接获取IntegerCache内部的对象</span></span><br><span class="line">Integer d = <span class="number">3</span>;  <span class="comment">//直接获取IntegerCache内部的对象</span></span><br><span class="line">Integer e = <span class="number">128</span>; <span class="comment">//new一个新的对象</span></span><br><span class="line">Integer f = <span class="number">128</span>;  <span class="comment">//new一个新的对象</span></span><br><span class="line">Long g = <span class="number">3L</span>;</span><br></pre></td></tr></table></figure><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(c == d); <span class="comment">//true  是同一个对象</span></span><br></pre></td></tr></table></figure><br>c 和 d 指向的是 IntegerCache 内部同一个对象，地址一样，== 比较的是地址。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(e == f); <span class="comment">//false   //128开始就false，不同的对象</span></span><br></pre></td></tr></table></figure><br>e 和 f 大于127，都是 new 生成的新对象，值相同，但是对应不同的内存地址。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(c == (a+b)); <span class="comment">//true  //拆箱变成基本类型</span></span><br></pre></td></tr></table></figure><br>(a+b) 触发自动拆箱，自动拆箱后是基本类型，它们的值是相等的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(c.equals(a+b)); <span class="comment">//true  //Integer和Integer类型一致，数值也一样</span></span><br></pre></td></tr></table></figure><br>equals 的参数是 Object，(a+b)会触发自动拆箱，结果变成基本类型，传进 equals 方法的时候会执行自动装箱，结果和 c 的值相同，而且类型相同，返回true。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(g == (a+b)); <span class="comment">//true  //拆箱子</span></span><br></pre></td></tr></table></figure><br>(a+b) 触发自动拆箱，自动拆箱后是基本类型，它们的值是相等的。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">System.out.println(g.equals(a+b)); <span class="comment">//false  //Long和Integer类型不一样</span></span><br></pre></td></tr></table></figure><br>(a+b)传进 equals 方法，自动装箱变成 Integer，值相同但是类型不同，返回false。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h2><p>&emsp;鉴于包装类的“\==”运算在不遇到算数运算的情况下不会自动拆箱，以及它们的equals方法不处理数据转型的关系，我们在实际编码的时候应该尽量避免这样使用自动装箱与拆箱。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/java/java-risk-of-autoboxing/">http://zhoujiapeng.top/java/java-risk-of-autoboxing/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> java </tag>
            
            <tag> 编程语言 </tag>
            
            <tag> jvm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>scala 尾递归优化</title>
      <link href="/scala/scala-tailrec/"/>
      <url>/scala/scala-tailrec/</url>
      
        <content type="html"><![CDATA[<h1 id="scala-尾递归优化"><a href="#scala-尾递归优化" class="headerlink" title="scala 尾递归优化"></a>scala 尾递归优化</h1><h2 id="1-递归"><a href="#1-递归" class="headerlink" title="1. 递归"></a>1. 递归</h2><h3 id="1-1-递归的定义"><a href="#1-1-递归的定义" class="headerlink" title="1.1 递归的定义"></a>1.1 递归的定义</h3><p>&emsp;一个函数直接或间接的调用它自己本身，就是递归。它通常把一个大型复杂的问题层层转化为一个与原问题相似的规模较小的问题来求解，递归策略只需少量的代码就可以执行多次重复的计算。</p><h3 id="1-2-递归的条件"><a href="#1-2-递归的条件" class="headerlink" title="1.2 递归的条件"></a>1.2 递归的条件</h3><p>&emsp;一般来说，递归需要有边界条件、递归前进段和递归返回段。当边界条件不满足时，递归前进；当边界条件满足时，递归返回。<br>&emsp;以递归方式实现阶乘函数的实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n:<span class="type">Int</span>): <span class="type">Long</span> =&#123;</span><br><span class="line">    <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> n * factorial(n<span class="number">-1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>if(n &lt;= 0) 1是递归返回段，else后面部分是递归前进段。它的调用过程大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">factorial(5)</span><br><span class="line">5 * factorial(4)</span><br><span class="line">5 * (4 * factorial(3))</span><br><span class="line">5 * (4 * (3 * factorial(2)))</span><br><span class="line">5 * (4 * (3 * (2 * factorial(1))))</span><br><span class="line">5 * (4 * (3 * (2 * 1)))</span><br></pre></td></tr></table></figure></p><h3 id="1-3-递归的缺点"><a href="#1-3-递归的缺点" class="headerlink" title="1.3 递归的缺点"></a>1.3 递归的缺点</h3><ul><li>需要保持调用堆栈,如代码1-1,每一次递归都要保存n*factorial(n-1)栈帧信息。如果调用次数太多，可能会导致栈溢出。</li><li>效率会比较低，递归就是不断的调用自己本身，如果方法本身比较复杂，每次调用自己效率会较低。</li></ul><h2 id="2-尾递归"><a href="#2-尾递归" class="headerlink" title="2. 尾递归"></a>2. 尾递归</h2><h3 id="2-1-定义"><a href="#2-1-定义" class="headerlink" title="2.1 定义"></a>2.1 定义</h3><p>&emsp;尾递归是指递归调用是函数的最后一个语句，而且其结果被直接返回，这是一类特殊的递归调用。由于递归结果总是直接返回，尾递归比较方便转换为循环，因此编译器容易对它进行优化。现在很多编译器都对尾递归有优化，程序员们不必再手动将它们改写为循环。<br>&emsp;我们可以这样理解尾递归</p><ul><li>所有递归形式的调用都出现在函数的末尾。</li><li>递归调用是整个函数体中最后执行的语句且它的返回值不属于表达式的一部分。</li></ul><p>&emsp;1.2中代码最后递归调用 factorial(n-1) ,但它是整个函数返回值表达式{n * factorial(n-1)} 的一部分，因此它不是尾递归。<br>&emsp;我们可以使用尾递归来实现上面的阶乘：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n:<span class="type">Int</span>):<span class="type">Long</span> = &#123;</span><br><span class="line">    <span class="meta">@tailrec</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">factorial</span></span>(n:<span class="type">Int</span>,aggr:<span class="type">Int</span>): <span class="type">Long</span> =&#123;</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">0</span>) aggr</span><br><span class="line">        <span class="keyword">else</span> factorial(n<span class="number">-1</span>,n*aggr)</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   factorial(n,<span class="number">1</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;调用过程大致如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">factorialTailrec(5, 1)</span><br><span class="line">factorialTailrec(4, 5)  &#x2F;&#x2F; 1 * 5 &#x3D; 5</span><br><span class="line">factorialTailrec(3, 20) &#x2F;&#x2F; 5 * 4 &#x3D; 20</span><br><span class="line">factorialTailrec(3, 60) &#x2F;&#x2F; 20 * 3 &#x3D; 60</span><br><span class="line">factorialTailrec(2, 120) &#x2F;&#x2F; 60 * 2 &#x3D; 120</span><br><span class="line">factorialTailrec(1, 120) &#x2F;&#x2F; 120 * 1 &#x3D; 120120</span><br></pre></td></tr></table></figure><br>&emsp;以上的调用，由于调用结果都是直接返回，所以之前的递归调用留在堆栈中的数据可以丢弃，只需要保留最后一次的数据，这就是尾递归容易优化的原因所在。<br>&emsp;尾递归的核心思想是通过参数来传递每一次的调用结果，达到不压栈。它维护着一个迭代器和一个累加器。</p><h3 id="2-2-循环"><a href="#2-2-循环" class="headerlink" title="2.2 循环"></a>2.2 循环</h3><p>&emsp;事实上，scala都是将尾递归直接编译成循环模式的。所以我们可以大胆的说，所有的循环模式都能改写为尾递归的写法模式。我们可以看一下阶乘算法的递归版本<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibfor</span></span>(n:<span class="type">Int</span>): <span class="type">Int</span> =&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> (i &lt;- <span class="number">1</span> to n) &#123;</span><br><span class="line">        m = m * i</span><br><span class="line">    &#125;</span><br><span class="line">    m</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-2-普通递归转化为尾递归"><a href="#2-2-普通递归转化为尾递归" class="headerlink" title="2.2 普通递归转化为尾递归"></a>2.2 普通递归转化为尾递归</h3><p>&emsp;尾递归会维护一个或多个累计值(aggregate)参数和一个迭代参数。</p><ul><li>累计值参数aggregate将每次循环产生的结果进行累计，然后传到下一次的调用中。</li><li>迭代器，和普通递归或循环一样，每次递归或循环后，改变一次。(如for(i=0;i&lt;1-;i++)里面的i)。<br>&emsp;将普通的递归改写为尾递归，关键在于找到合适的累加器。下面我们以斐波那契数列为例，看看如何找到累加器。斐波那契数列，前两项为1，从第三项起，每一项都是它之前的两项和。这个定义就是天然的递归算法，如下:<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="number">1</span></span><br><span class="line">  <span class="keyword">else</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&emsp;调用过程为：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fibonacci(<span class="number">5</span>)</span><br><span class="line">fibonacci(<span class="number">4</span>) + fibonacci(<span class="number">3</span>)</span><br><span class="line">(fibonacci(<span class="number">3</span>) + fibonacci(<span class="number">2</span>)) + (fibonacci(<span class="number">2</span>) + fibonacci(<span class="number">1</span>))</span><br><span class="line">((fibonacci(<span class="number">2</span>) + fibonacci(<span class="number">1</span>)) + <span class="number">1</span>) + (<span class="number">1</span> + <span class="number">1</span>)</span><br><span class="line">((<span class="number">1</span> + <span class="number">1</span>) + <span class="number">1</span>) + <span class="number">2</span></span><br></pre></td></tr></table></figure>&emsp;上面显然不是尾递归，如何找到累加器将它改造为尾递归？因为需要前两项的和，所以这里需要两个累加器，假设较小的一个为acc1，较大的一个为acc2，需要计算下一项时，将acc2的值赋给acc1，而（acc1+acc2)赋值给acc2，这样，调用堆栈中旧有的数据即可丢弃。<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacciTailrec</span></span>(n: <span class="type">Int</span>, acc1: <span class="type">Int</span>, acc2: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">  <span class="keyword">if</span> (n &lt; <span class="number">2</span>) acc2</span><br><span class="line">  <span class="keyword">else</span> fibonacciTailrec(n - <span class="number">1</span>, acc2, acc1 + acc2)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>&emsp;调用过程为：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fibonacciTailrec(<span class="number">5</span>,<span class="number">0</span>,<span class="number">1</span>)</span><br><span class="line">fibonacciTailrec(<span class="number">4</span>,<span class="number">1</span>,<span class="number">1</span>)</span><br><span class="line">fibonacciTailrec(<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>)</span><br><span class="line">fibonacciTailrec(<span class="number">2</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line">fibonacciTailrec(<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>)</span><br></pre></td></tr></table></figure></li></ul><h2 id="3-Scala对尾递归的支持"><a href="#3-Scala对尾递归的支持" class="headerlink" title="3. Scala对尾递归的支持"></a>3. Scala对尾递归的支持</h2><h3 id="3-1-使用方法"><a href="#3-1-使用方法" class="headerlink" title="3.1 使用方法"></a>3.1 使用方法</h3><p>&emsp;Scala对形式上严格的尾递归进行了优化，对于严格的尾递归，可以放心使用，不必担心性能问题。对于是否是严格尾递归，若不能自行判断， 可使用Scala提供的尾递归标注@scala.annotation.tailrec，这个符号除了可以标识尾递归外，更重要的是编译器会检查该函数是否真的尾递归，若不是，会导致如下编译错误:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">could not optimize @tailrec annotated method fibonacci: it contains a recursive call not in tail position</span><br></pre></td></tr></table></figure></p><h3 id="3-2-编译器对尾递归的优化"><a href="#3-2-编译器对尾递归的优化" class="headerlink" title="3.2 编译器对尾递归的优化"></a>3.2 编译器对尾递归的优化</h3><p>&emsp;当编译器检测到一个函数调用是尾递归的时候，它就覆盖当前的活动记录而不是在栈中去创建一个新的。scala编译器会察觉到尾递归，并对其进行优化，将它编译成循环的模式。</p><h3 id="3-3-Scala尾递归的限制"><a href="#3-3-Scala尾递归的限制" class="headerlink" title="3.3 Scala尾递归的限制"></a>3.3 Scala尾递归的限制</h3><ul><li>尾递归有严格的要求，就是最后一个语句是递归调用，因此写法比较严格。</li><li>尾递归最后调用的必须是它本身，间接的赋值它本身的函数也无法进行优化。</li></ul><h2 id="4-性能测试"><a href="#4-性能测试" class="headerlink" title="4. 性能测试"></a>4. 性能测试</h2><p>&emsp;下面进行fibonacci算法的普通递归和尾递归时间测试对比：<br>&emsp;测试代码：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> n = <span class="number">20</span></span><br><span class="line"></span><br><span class="line">    println(<span class="string">s"n = <span class="subst">$n</span>"</span>)</span><br><span class="line">    <span class="keyword">var</span> startTime = <span class="type">System</span>.nanoTime              <span class="comment">//系统纳米时间</span></span><br><span class="line">    println(fibonacci(n))</span><br><span class="line">    <span class="keyword">var</span> endTime =  <span class="type">System</span>.nanoTime</span><br><span class="line">    println(<span class="string">s"fibonacci time:<span class="subst">$&#123;(endTime - startTime)/1000000d&#125;</span>ms"</span>)</span><br><span class="line"></span><br><span class="line">    startTime = <span class="type">System</span>.nanoTime</span><br><span class="line">    println(fibonacciTailrec(n,<span class="number">0</span>,<span class="number">1</span>))</span><br><span class="line">    endTime =  <span class="type">System</span>.nanoTime</span><br><span class="line">    println(<span class="string">s"fibonacciTailrec time:<span class="subst">$&#123;(endTime - startTime)/1000000d&#125;</span>ms"</span>)</span><br><span class="line">    </span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span></span>(n: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= <span class="number">2</span>) <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="meta">@tailrec</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">fibonacciTailrec</span></span>(n: <span class="type">Int</span>, acc1: <span class="type">Int</span>, acc2: <span class="type">Int</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (n &lt; <span class="number">2</span>) acc2</span><br><span class="line">    <span class="keyword">else</span> fibonacciTailrec(n - <span class="number">1</span>, acc2, acc1 + acc2)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;测试结果：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">=========</span><br><span class="line">n = <span class="number">20</span></span><br><span class="line"><span class="number">6765</span></span><br><span class="line">fibonacci time:<span class="number">0.611397</span>ms</span><br><span class="line"><span class="number">6765</span></span><br><span class="line">fibonacciTailrec time:<span class="number">0.025869</span>ms</span><br><span class="line">=========</span><br><span class="line">n = <span class="number">30</span></span><br><span class="line"><span class="number">832040</span></span><br><span class="line">fibonacci time:<span class="number">5.091809</span>ms</span><br><span class="line"><span class="number">832040</span></span><br><span class="line">fibonacciTailrec time:<span class="number">0.023307</span>ms</span><br><span class="line">=========</span><br><span class="line">n = <span class="number">40</span></span><br><span class="line"><span class="number">102334155</span></span><br><span class="line">fibonacci time:<span class="number">300.614119</span>ms</span><br><span class="line"><span class="number">102334155</span></span><br><span class="line">fibonacciTailrec time:<span class="number">0.027578</span>ms</span><br><span class="line">=========</span><br></pre></td></tr></table></figure><br>&emsp;可以看到，随着n的增大，尾递归带来的性能优化是非常明显的。</p><h2 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h2><p>&emsp;循环调用都是一个累计器和一个迭代器的作用。同理，尾递归也是如此，它也是通过累加和迭代将结果赋值给新一轮的调用，使用好尾递归能够给我们的程序带来很大性能上的优化。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/scala/scala-tailrec/">http://zhoujiapeng.top/scala/scala-tailrec/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> scala </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> scala </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark 源码阅读 之 部署模式</title>
      <link href="/Spark/spark-deploy-mode/"/>
      <url>/Spark/spark-deploy-mode/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-部署模式"><a href="#Spark-部署模式" class="headerlink" title="Spark 部署模式"></a>Spark 部署模式</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1. 概述"></a>1. 概述</h2><p>&emsp;Spark 支持多种集群运行模式：</p><ul><li>Local - 本地模式，也可以使用伪分布式模式</li><li><a href="http://spark.apache.org/docs/2.4.0/spark-standalone.html" target="_blank" rel="noopener">Standalone</a> - Spark自身提供的集群资源管理器</li><li><a href="http://spark.apache.org/docs/2.4.0/running-on-mesos.html" target="_blank" rel="noopener">Mesos</a> - 外部集群资源管理器</li><li><a href="http://spark.apache.org/docs/2.4.0/running-on-yarn.html" target="_blank" rel="noopener">Yarn</a> - 外部集群资源管理器</li><li><a href="http://spark.apache.org/docs/2.4.0/running-on-kubernetes.html" target="_blank" rel="noopener">Kubernetes</a> - 外部集群资源管理器</li></ul><p>&emsp;下图表示 Spark 的基本工作流程架构图：<br><img src="https://gitee.com/JP6907/Pic/raw/master/spark/cluster-overview.png?raw=true" alt="cluster-overview"><br>&emsp;其中的 Cluster Manager 集群管理器是可插拔的，也就是本文的介绍重点。</p><p>&emsp;我们可以在调用 spark-submit 脚本的时候通过参数指定集群的运行模式。spark-submit 脚本会调用 SparkSubmit 类，通过反射启动指定的 mainClass，mainClass 中会创建 SparkContext，在 SprkContext 调用 createTaskScheduler 就会创建我们需要的资源调度器。关于 SparkSubmit 的详细介绍可以参考文章<a href="http://zhoujiapeng.top/Spark/spark-application/#2sparksubmit-1">《Spark Application 提交》</a>，这里不再多加赘述。具体集群运行模式的匹配是在 SparkContext 的 createTaskScheduler 方法中，我们看一下这个方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SparkContext.createTaskScheduler</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createTaskScheduler</span></span>(</span><br><span class="line">      sc: <span class="type">SparkContext</span>,</span><br><span class="line">      master: <span class="type">String</span>,</span><br><span class="line">      deployMode: <span class="type">String</span>): (<span class="type">SchedulerBackend</span>, <span class="type">TaskScheduler</span>) = &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">SparkMasterRegex</span>._</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When running locally, don't try to re-execute tasks on failure.</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">MAX_LOCAL_TASK_FAILURES</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    master <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"local"</span> =&gt;</span><br><span class="line">        <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc, <span class="type">MAX_LOCAL_TASK_FAILURES</span>, isLocal = <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">LocalSchedulerBackend</span>(sc.getConf, scheduler, <span class="number">1</span>)</span><br><span class="line">        scheduler.initialize(backend)</span><br><span class="line">        (backend, scheduler)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">LOCAL_N_REGEX</span>(threads) =&gt;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">localCpuCount</span></span>: <span class="type">Int</span> = <span class="type">Runtime</span>.getRuntime.availableProcessors()</span><br><span class="line">        <span class="comment">// local[*] estimates the number of cores on the machine; local[N] uses exactly N threads.</span></span><br><span class="line">        <span class="keyword">val</span> threadCount = <span class="keyword">if</span> (threads == <span class="string">"*"</span>) localCpuCount <span class="keyword">else</span> threads.toInt</span><br><span class="line">        <span class="keyword">if</span> (threadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s"Asked to run locally with <span class="subst">$threadCount</span> threads"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc, <span class="type">MAX_LOCAL_TASK_FAILURES</span>, isLocal = <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">LocalSchedulerBackend</span>(sc.getConf, scheduler, threadCount)</span><br><span class="line">        scheduler.initialize(backend)</span><br><span class="line">        (backend, scheduler)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">LOCAL_N_FAILURES_REGEX</span>(threads, maxFailures) =&gt;</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">localCpuCount</span></span>: <span class="type">Int</span> = <span class="type">Runtime</span>.getRuntime.availableProcessors()</span><br><span class="line">        <span class="comment">// local[*, M] means the number of cores on the computer with M failures</span></span><br><span class="line">        <span class="comment">// local[N, M] means exactly N threads with M failures</span></span><br><span class="line">        <span class="keyword">val</span> threadCount = <span class="keyword">if</span> (threads == <span class="string">"*"</span>) localCpuCount <span class="keyword">else</span> threads.toInt</span><br><span class="line">        <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc, maxFailures.toInt, isLocal = <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">LocalSchedulerBackend</span>(sc.getConf, scheduler, threadCount)</span><br><span class="line">        scheduler.initialize(backend)</span><br><span class="line">        (backend, scheduler)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">SPARK_REGEX</span>(sparkUrl) =&gt;</span><br><span class="line">        <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc)</span><br><span class="line">        <span class="keyword">val</span> masterUrls = sparkUrl.split(<span class="string">","</span>).map(<span class="string">"spark://"</span> + _)</span><br><span class="line">        <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">StandaloneSchedulerBackend</span>(scheduler, sc, masterUrls)</span><br><span class="line">        scheduler.initialize(backend)</span><br><span class="line">        (backend, scheduler)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">LOCAL_CLUSTER_REGEX</span>(numSlaves, coresPerSlave, memoryPerSlave) =&gt;</span><br><span class="line">        <span class="comment">// Check to make sure memory requested &lt;= memoryPerSlave. Otherwise Spark will just hang.</span></span><br><span class="line">        <span class="keyword">val</span> memoryPerSlaveInt = memoryPerSlave.toInt</span><br><span class="line">        <span class="keyword">if</span> (sc.executorMemory &gt; memoryPerSlaveInt) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(</span><br><span class="line">            <span class="string">"Asked to launch cluster with %d MB RAM / worker but requested %d MB/worker"</span>.format(</span><br><span class="line">              memoryPerSlaveInt, sc.executorMemory))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc)</span><br><span class="line">        <span class="keyword">val</span> localCluster = <span class="keyword">new</span> <span class="type">LocalSparkCluster</span>(</span><br><span class="line">          numSlaves.toInt, coresPerSlave.toInt, memoryPerSlaveInt, sc.conf)</span><br><span class="line">        <span class="keyword">val</span> masterUrls = localCluster.start()</span><br><span class="line">        <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">StandaloneSchedulerBackend</span>(scheduler, sc, masterUrls)</span><br><span class="line">        scheduler.initialize(backend)</span><br><span class="line">        backend.shutdownCallback = (backend: <span class="type">StandaloneSchedulerBackend</span>) =&gt; &#123;</span><br><span class="line">          localCluster.stop()</span><br><span class="line">        &#125;</span><br><span class="line">        (backend, scheduler)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> masterUrl =&gt;</span><br><span class="line">        <span class="keyword">val</span> cm = getClusterManager(masterUrl) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(clusterMgr) =&gt; clusterMgr</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"Could not parse Master URL: '"</span> + master + <span class="string">"'"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> scheduler = cm.createTaskScheduler(sc, masterUrl)</span><br><span class="line">          <span class="keyword">val</span> backend = cm.createSchedulerBackend(sc, masterUrl, scheduler)</span><br><span class="line">          cm.initialize(scheduler, backend)</span><br><span class="line">          (backend, scheduler)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> se: <span class="type">SparkException</span> =&gt; <span class="keyword">throw</span> se</span><br><span class="line">          <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"External scheduler cannot be instantiated"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里通过正则表达式来确定具体指定的集群部署模式，下面我们详细看一下其中的各种模式。</p><h1 id="2-各种部署模式"><a href="#2-各种部署模式" class="headerlink" title="2. 各种部署模式"></a>2. 各种部署模式</h1><h2 id="2-1-local"><a href="#2-1-local" class="headerlink" title="2.1 local"></a>2.1 local</h2><p>&emsp;在 local 模式下，execuor、backend、master 都运行在同一个 JVM 进程中，executor 会创建多线程来运行 tasks(单节点多线程)。local 模式最大的好处就是很方便我们在单机上调试应用程序。在 SparkContext.createTaskScheduler 方法中我们可以看到，local 模式可以有3种参数指定的方式：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> <span class="string">"local"</span> =&gt;</span><br><span class="line">  <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc, <span class="type">MAX_LOCAL_TASK_FAILURES</span>, isLocal = <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">LocalSchedulerBackend</span>(sc.getConf, scheduler, <span class="number">1</span>)</span><br><span class="line">  scheduler.initialize(backend)</span><br><span class="line">  (backend, scheduler)</span><br><span class="line"></span><br><span class="line"><span class="comment">//val LOCAL_N_REGEX = """local\[([0-9]+|\*)\]""".r</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">LOCAL_N_REGEX</span>(threads) =&gt;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">localCpuCount</span></span>: <span class="type">Int</span> = <span class="type">Runtime</span>.getRuntime.availableProcessors()</span><br><span class="line">  <span class="comment">// local[*] estimates the number of cores on the machine; local[N] uses exactly N threads.</span></span><br><span class="line">  <span class="keyword">val</span> threadCount = <span class="keyword">if</span> (threads == <span class="string">"*"</span>) localCpuCount <span class="keyword">else</span> threads.toInt</span><br><span class="line">  <span class="keyword">if</span> (threadCount &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s"Asked to run locally with <span class="subst">$threadCount</span> threads"</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc, <span class="type">MAX_LOCAL_TASK_FAILURES</span>, isLocal = <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">LocalSchedulerBackend</span>(sc.getConf, scheduler, threadCount)</span><br><span class="line">  scheduler.initialize(backend)</span><br><span class="line">  (backend, scheduler)</span><br><span class="line"></span><br><span class="line"><span class="comment">//val LOCAL_N_FAILURES_REGEX = """local\[([0-9]+|\*)\s*,\s*([0-9]+)\]""".r</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">LOCAL_N_FAILURES_REGEX</span>(threads, maxFailures) =&gt;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">localCpuCount</span></span>: <span class="type">Int</span> = <span class="type">Runtime</span>.getRuntime.availableProcessors()</span><br><span class="line">  <span class="comment">// local[*, M] means the number of cores on the computer with M failures</span></span><br><span class="line">  <span class="comment">// local[N, M] means exactly N threads with M failures</span></span><br><span class="line">  <span class="keyword">val</span> threadCount = <span class="keyword">if</span> (threads == <span class="string">"*"</span>) localCpuCount <span class="keyword">else</span> threads.toInt</span><br><span class="line">  <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc, maxFailures.toInt, isLocal = <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">LocalSchedulerBackend</span>(sc.getConf, scheduler, threadCount)</span><br><span class="line">  scheduler.initialize(backend)</span><br><span class="line">  (backend, scheduler)</span><br></pre></td></tr></table></figure><ol><li>“local” ： 这里的参数 1 指定核数，也就是说，最多只能有一个线程同时运行。<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">LocalSchedulerBackend</span>(sc.getConf, scheduler, <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li>LOCAL_N_REGEX（ “local[N]” 或 “local[*]” ） : local[N] 指定了运行 N 个线程，local[*] 创建的线程数和当前机器的核数一样。<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> threadCount = <span class="keyword">if</span> (threads == <span class="string">"*"</span>) localCpuCount <span class="keyword">else</span> threads.toInt</span><br><span class="line"><span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">LocalSchedulerBackend</span>(sc.getConf, scheduler, threadCount)</span><br></pre></td></tr></table></figure></li><li>LOCAL_N_FAILURES_REGEX（ “local[*, M]” 或 “local[N, M]” ）：local[N, M] 表示运行 N 个线程，最多允许有 M 个线程失败，local[*, M] 创建的线程数和当前机器的核数一样，最多允许有 M 个线程失败。<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> threadCount = <span class="keyword">if</span> (threads == <span class="string">"*"</span>) localCpuCount <span class="keyword">else</span> threads.toInt</span><br><span class="line"><span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">LocalSchedulerBackend</span>(sc.getConf, scheduler, threadCount)</span><br></pre></td></tr></table></figure></li></ol><p>&emsp;这三种方式都是创建了 LocalSchedulerBackend，在<a href="http://zhoujiapeng.top/Spark/spark-job/#3taskschedulertask">《Spark 作业和调度》</a>中讲到，当提交 TaskSet 给 TaskScheduler 的时候会调用 backend.reviveOffers() 进行计算资源的分配并启动 Task。我们看一下 LocalSchedulerBackend.reviveOffers() 方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LocalSchedulerBackend</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reviveOffers</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> offers = <span class="type">IndexedSeq</span>(<span class="keyword">new</span> <span class="type">WorkerOffer</span>(localExecutorId, localExecutorHostname, freeCores,</span><br><span class="line">      <span class="type">Some</span>(rpcEnv.address.hostPort)))</span><br><span class="line">    <span class="keyword">for</span> (task &lt;- scheduler.resourceOffers(offers).flatten) &#123;</span><br><span class="line">      freeCores -= scheduler.<span class="type">CPUS_PER_TASK</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//启动task</span></span><br><span class="line">      executor.launchTask(executorBackend, task)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executor = <span class="keyword">new</span> <span class="type">Executor</span>(</span><br><span class="line">    localExecutorId, localExecutorHostname, <span class="type">SparkEnv</span>.get, userClassPath, isLocal = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><br>&emsp;可以看到，所有的 task 都是由同一个 executor（意味着单进程） 调用 launchTask 来启动的。再看一下 executor.launchTask 方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launchTask</span></span>(context: <span class="type">ExecutorBackend</span>, taskDescription: <span class="type">TaskDescription</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tr = <span class="keyword">new</span> <span class="type">TaskRunner</span>(context, taskDescription)</span><br><span class="line">    runningTasks.put(taskDescription.taskId, tr)</span><br><span class="line">    threadPool.execute(tr)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里是将 task 包装成 TaskRunner，然后放进线程池里面去执行。到这里我们可以知道，</p><h2 id="2-2-local-cluster"><a href="#2-2-local-cluster" class="headerlink" title="2.2 local-cluster"></a>2.2 local-cluster</h2><p>&emsp;local-cluster，本地集群模式，也就是伪分布式模式。Driver、Master 和 Worker 在同一个 JVM 进程，可以存在多个 Worker，每个 Worker 会有多个 Executor，但这些 Executor 都独自存在一个 JVM 进程中。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//val LOCAL_CLUSTER_REGEX = """local-cluster\[\s*([0-9]+)\s*,\s*([0-9]+)\s*,\s*([0-9]+)\s*]""".r</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">LOCAL_CLUSTER_REGEX</span>(numSlaves, coresPerSlave, memoryPerSlave) =&gt;</span><br><span class="line">        <span class="comment">// Check to make sure memory requested &lt;= memoryPerSlave. Otherwise Spark will just hang.</span></span><br><span class="line">        <span class="keyword">val</span> memoryPerSlaveInt = memoryPerSlave.toInt</span><br><span class="line">        <span class="keyword">if</span> (sc.executorMemory &gt; memoryPerSlaveInt) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(</span><br><span class="line">            <span class="string">"Asked to launch cluster with %d MB RAM / worker but requested %d MB/worker"</span>.format(</span><br><span class="line">              memoryPerSlaveInt, sc.executorMemory))</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc)</span><br><span class="line">        <span class="keyword">val</span> localCluster = <span class="keyword">new</span> <span class="type">LocalSparkCluster</span>(</span><br><span class="line">          numSlaves.toInt, coresPerSlave.toInt, memoryPerSlaveInt, sc.conf)</span><br><span class="line">        <span class="keyword">val</span> masterUrls = localCluster.start()</span><br><span class="line">        <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">StandaloneSchedulerBackend</span>(scheduler, sc, masterUrls)</span><br><span class="line">        scheduler.initialize(backend)</span><br><span class="line">        backend.shutdownCallback = (backend: <span class="type">StandaloneSchedulerBackend</span>) =&gt; &#123;</span><br><span class="line">          localCluster.stop()</span><br><span class="line">        &#125;</span><br><span class="line">        (backend, scheduler)</span><br></pre></td></tr></table></figure><br>&emsp;这里先是创建了一个 LocalSparkCluster，构建一个本地 Spark 集群环境。接着创建一个 StandaloneSchedulerBackend，注意这里不是 LocalSchedulerBackend。集群环境是在本地运行还是多节点环境对于 StandaloneSchedulerBackend 是透明的。StandaloneSchedulerBackend 只需要知道 Master 节点的地址就可以了，具体的资源调度由 Master 负责就可以。Standalone 模式同样是创建 StandaloneSchedulerBackend。这里将 StandaloneSchedulerBackend 放到 Standalone 模式一起介绍。</p><h2 id="2-3-standalone"><a href="#2-3-standalone" class="headerlink" title="2.3 standalone"></a>2.3 standalone</h2><p>&emsp;local 模式只有 Driver 和 Executor，且都在一个 JVM 进程中；loca-cluster 模式下的 Driver、Master、Worker 都位于一个 JVM 进程中。所以 local 模式和 local-cluster 模式便于开发、测试，也便于源码阅读和调试，但是不适合在生产环境使用。不同于这两种模式，Standalone 部署模式有下面的特点：</p><ul><li>Driver 是单独的进程、可以存在于集群中，也可存在于集群之外，也对 Spark Application 的执行进行驱动；</li><li>Master 是单独的进程，甚至应该在单独的机器节点上。Master 可以有多个，但同时最多只有一个处于激活状态；</li><li>Worker 是单独的进程，推荐在单独的机器节点上部署。<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//val SPARK_REGEX = """spark://(.*)""".r</span></span><br><span class="line"><span class="keyword">case</span> <span class="type">SPARK_REGEX</span>(sparkUrl) =&gt;</span><br><span class="line">        <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc)</span><br><span class="line">        <span class="keyword">val</span> masterUrls = sparkUrl.split(<span class="string">","</span>).map(<span class="string">"spark://"</span> + _)</span><br><span class="line">        <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">StandaloneSchedulerBackend</span>(scheduler, sc, masterUrls)</span><br><span class="line">        scheduler.initialize(backend)</span><br><span class="line">        (backend, scheduler)</span><br></pre></td></tr></table></figure>&emsp;不同于 local-cluster 模式，Standalone 模式的 masterUrls 是由参数传入的，然后同样是创建一个 StandaloneSchedulerBackend。我们同样看一下 backend.reviveOffers() 方法。StandaloneSchedulerBackend 的 reviveOffers 是由父类 CoarseGrainedSchedulerBackend 实现的：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CoarseGrainedSchedulerBackend</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reviveOffers</span></span>() &#123;</span><br><span class="line">    driverEndpoint.send(<span class="type">ReviveOffers</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ReviveOffers</span> =&gt;</span><br><span class="line">        makeOffers()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make fake resource offers on all executors</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">makeOffers</span></span>() &#123;</span><br><span class="line">      <span class="comment">// Make sure no executor is killed while some task is launching on it</span></span><br><span class="line">      <span class="keyword">val</span> taskDescs = <span class="type">CoarseGrainedSchedulerBackend</span>.<span class="keyword">this</span>.synchronized &#123;</span><br><span class="line">        <span class="comment">// Filter out executors under killing</span></span><br><span class="line">        <span class="keyword">val</span> activeExecutors = executorDataMap.filterKeys(executorIsAlive)</span><br><span class="line">        <span class="keyword">val</span> workOffers = activeExecutors.map &#123;</span><br><span class="line">          <span class="keyword">case</span> (id, executorData) =&gt;</span><br><span class="line">            <span class="keyword">new</span> <span class="type">WorkerOffer</span>(id, executorData.executorHost, executorData.freeCores,</span><br><span class="line">              <span class="type">Some</span>(executorData.executorAddress.hostPort))</span><br><span class="line">        &#125;.toIndexedSeq</span><br><span class="line">        scheduler.resourceOffers(workOffers)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (!taskDescs.isEmpty) &#123;</span><br><span class="line">        launchTasks(taskDescs)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>&emsp;这里的 executorDataMap 是一个 HashMap，储存了所有的 Executors。makeOffers() 首先是 调用 scheduler.resourceOffers 进行计算资源的分配，然后调用 launchTasks 去启动对应的 task。我们看一下 launchTasks 方法：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Launch tasks returned by a set of resource offers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">launchTasks</span></span>(tasks: <span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">TaskDescription</span>]]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (task &lt;- tasks.flatten) &#123;</span><br><span class="line">        <span class="keyword">val</span> serializedTask = <span class="type">TaskDescription</span>.encode(task)</span><br><span class="line">        <span class="keyword">if</span> (serializedTask.limit() &gt;= maxRpcMessageSize) &#123;</span><br><span class="line">          <span class="type">Option</span>(scheduler.taskIdToTaskSetManager.get(task.taskId)).foreach &#123; taskSetMgr =&gt;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">var</span> msg = <span class="string">"Serialized task %s:%d was %d bytes, which exceeds max allowed: "</span> +</span><br><span class="line">                <span class="string">"spark.rpc.message.maxSize (%d bytes). Consider increasing "</span> +</span><br><span class="line">                <span class="string">"spark.rpc.message.maxSize or using broadcast variables for large values."</span></span><br><span class="line">              msg = msg.format(task.taskId, task.index, serializedTask.limit(), maxRpcMessageSize)</span><br><span class="line">              taskSetMgr.abort(msg)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">              <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logError(<span class="string">"Exception in error callback"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">          <span class="comment">//获取 task 的执行位置</span></span><br><span class="line">          <span class="keyword">val</span> executorData = executorDataMap(task.executorId)</span><br><span class="line">          executorData.freeCores -= scheduler.<span class="type">CPUS_PER_TASK</span></span><br><span class="line"></span><br><span class="line">          logDebug(<span class="string">s"Launching task <span class="subst">$&#123;task.taskId&#125;</span> on executor id: <span class="subst">$&#123;task.executorId&#125;</span> hostname: "</span> +</span><br><span class="line">            <span class="string">s"<span class="subst">$&#123;executorData.executorHost&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line">          <span class="comment">//启动 task</span></span><br><span class="line">          executorData.executorEndpoint.send(<span class="type">LaunchTask</span>(<span class="keyword">new</span> <span class="type">SerializableBuffer</span>(serializedTask)))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>&emsp;前面已经为所有的 task 分配好了计算资源，对于哪一个 task 会分配到哪一个 executor 上去执行已经是明确的了，并储存在 task.executorId 中。这里遍历每一个 task，然后调用直接在对应的 executor 上启动该 task。到这里就实现了将 不同的 task 分配到不同的 executor 进行中去运行。</li></ul><h2 id="2-4-Yarn"><a href="#2-4-Yarn" class="headerlink" title="2.4 Yarn"></a>2.4 Yarn</h2><p>&emsp;createTaskScheduler 方法中最后一种情况对应于所有的外部集群部署模式（yarn、k8s、Mesos）：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> masterUrl =&gt;</span><br><span class="line">        <span class="keyword">val</span> cm = getClusterManager(masterUrl) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(clusterMgr) =&gt; clusterMgr</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"Could not parse Master URL: '"</span> + master + <span class="string">"'"</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> scheduler = cm.createTaskScheduler(sc, masterUrl)</span><br><span class="line">          <span class="keyword">val</span> backend = cm.createSchedulerBackend(sc, masterUrl, scheduler)</span><br><span class="line">          cm.initialize(scheduler, backend)</span><br><span class="line">          (backend, scheduler)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> se: <span class="type">SparkException</span> =&gt; <span class="keyword">throw</span> se</span><br><span class="line">          <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"External scheduler cannot be instantiated"</span>, e)</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><br>&emsp;getClusterManager 方法返回的是一个 ExternalClusterManager 对象，即外部集群管理器。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getClusterManager</span></span>(url: <span class="type">String</span>): <span class="type">Option</span>[<span class="type">ExternalClusterManager</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> loader = <span class="type">Utils</span>.getContextOrSparkClassLoader</span><br><span class="line">    <span class="keyword">val</span> serviceLoaders =</span><br><span class="line">      <span class="type">ServiceLoader</span>.load(classOf[<span class="type">ExternalClusterManager</span>], loader).asScala.filter(_.canCreate(url))</span><br><span class="line">    <span class="keyword">if</span> (serviceLoaders.size &gt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(</span><br><span class="line">        <span class="string">s"Multiple external cluster managers registered for the url <span class="subst">$url</span>: <span class="subst">$serviceLoaders</span>"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    serviceLoaders.headOption</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;TaskScheduler 和 SchedulerBackend 是通过 ExternalClusterManager 的 createTaskScheduler 方法和 createSchedulerBackend 获得的。ExternalClusterManager 是一个特质，Yarn 模式的实现类是 YarnClusterManager。Yarn 模式根据 driver 的运行位置不同可以分为 cluster 模式和 client 模式：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//YarnClusterManager</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createTaskScheduler</span></span>(sc: <span class="type">SparkContext</span>, masterURL: <span class="type">String</span>): <span class="type">TaskScheduler</span> = &#123;</span><br><span class="line">    sc.deployMode <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"cluster"</span> =&gt; <span class="keyword">new</span> <span class="type">YarnClusterScheduler</span>(sc)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"client"</span> =&gt; <span class="keyword">new</span> <span class="type">YarnScheduler</span>(sc)</span><br><span class="line">      <span class="keyword">case</span> _ =&gt; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s"Unknown deploy mode '<span class="subst">$&#123;sc.deployMode&#125;</span>' for Yarn"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">createSchedulerBackend</span></span>(sc: <span class="type">SparkContext</span>,</span><br><span class="line">      masterURL: <span class="type">String</span>,</span><br><span class="line">      scheduler: <span class="type">TaskScheduler</span>): <span class="type">SchedulerBackend</span> = &#123;</span><br><span class="line">    sc.deployMode <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"cluster"</span> =&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">YarnClusterSchedulerBackend</span>(scheduler.asInstanceOf[<span class="type">TaskSchedulerImpl</span>], sc)</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"client"</span> =&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">YarnClientSchedulerBackend</span>(scheduler.asInstanceOf[<span class="type">TaskSchedulerImpl</span>], sc)</span><br><span class="line">      <span class="keyword">case</span>  _ =&gt;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s"Unknown deploy mode '<span class="subst">$&#123;sc.deployMode&#125;</span>' for Yarn"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;我们再看一下 SparkSubmit 的 prepareSubmitEnvironment 方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[deploy] <span class="function"><span class="keyword">def</span> <span class="title">prepareSubmitEnvironment</span></span>(</span><br><span class="line">      args: <span class="type">SparkSubmitArguments</span>,</span><br><span class="line">      conf: <span class="type">Option</span>[<span class="type">HadoopConfiguration</span>] = <span class="type">None</span>)</span><br><span class="line">      : (<span class="type">Seq</span>[<span class="type">String</span>], <span class="type">Seq</span>[<span class="type">String</span>], <span class="type">SparkConf</span>, <span class="type">String</span>) = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="comment">// In yarn-cluster mode, use yarn.Client as a wrapper around the user class</span></span><br><span class="line">    <span class="keyword">if</span> (isYarnCluster) &#123;</span><br><span class="line">      childMainClass = <span class="type">YARN_CLUSTER_SUBMIT_CLASS</span>  <span class="comment">//"org.apache.spark.deploy.yarn.YarnClusterApplication"</span></span><br><span class="line">      <span class="keyword">if</span> (args.isPython) &#123;</span><br><span class="line">        childArgs += (<span class="string">"--primary-py-file"</span>, args.primaryResource)</span><br><span class="line">        childArgs += (<span class="string">"--class"</span>, <span class="string">"org.apache.spark.deploy.PythonRunner"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (args.isR) &#123;</span><br><span class="line">        <span class="keyword">val</span> mainFile = <span class="keyword">new</span> <span class="type">Path</span>(args.primaryResource).getName</span><br><span class="line">        childArgs += (<span class="string">"--primary-r-file"</span>, mainFile)</span><br><span class="line">        childArgs += (<span class="string">"--class"</span>, <span class="string">"org.apache.spark.deploy.RRunner"</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (args.primaryResource != <span class="type">SparkLauncher</span>.<span class="type">NO_RESOURCE</span>) &#123;</span><br><span class="line">          childArgs += (<span class="string">"--jar"</span>, args.primaryResource)</span><br><span class="line">        &#125;</span><br><span class="line">        childArgs += (<span class="string">"--class"</span>, args.mainClass)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (args.childArgs != <span class="literal">null</span>) &#123;</span><br><span class="line">        args.childArgs.foreach &#123; arg =&gt; childArgs += (<span class="string">"--arg"</span>, arg) &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;可以看到，childMainClass 被设置成了 YarnClusterApplication 类，传入参数则被添加到 childArgs 中，因此 Yarn-cluster 不同于其它方式通过反射(SparkSubmit.runMain)直接运行参数指定的类，而是先创建 YarnClusterApplication，再通过它来提交 Application。<br>&emsp;Yarn-client 模式和 local 模式一样，都是通过反射直接启动运行参数(SparkSubmit.runMain)指定的类。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SparkSubmit.prepareSubmitEnvironment</span></span><br><span class="line"><span class="comment">// yarn-client 模式</span></span><br><span class="line"><span class="keyword">if</span> (deployMode == <span class="type">CLIENT</span>) &#123;</span><br><span class="line">      childMainClass = args.mainClass</span><br><span class="line">      <span class="keyword">if</span> (localPrimaryResource != <span class="literal">null</span> &amp;&amp; isUserJar(localPrimaryResource)) &#123;</span><br><span class="line">        childClasspath += localPrimaryResource</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (localJars != <span class="literal">null</span>) &#123; childClasspath ++= localJars.split(<span class="string">","</span>) &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><blockquote><p>未完待续</p></blockquote><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-deploy-mode/">http://zhoujiapeng.top/Spark/spark-deploy-mode/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark源码阅读 之 DAGScheduler 详解</title>
      <link href="/Spark/spark-dagscheduler/"/>
      <url>/Spark/spark-dagscheduler/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-DAGScheduler-详解"><a href="#Spark-DAGScheduler-详解" class="headerlink" title="Spark DAGScheduler 详解"></a>Spark DAGScheduler 详解</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><p>&emsp;DAGScheduler 是面向 Stage 的任务调度器，负责接收 Spark 应用提交的 Job，并根据 RDD 的依赖关系划分 Stage，并提交 Stage 给 TaskScheduler 调度器。本文将根据源码详细剖析 DAGScheduler 调度的完整流程。</p><h3 id="DAGScheduler"><a href="#DAGScheduler" class="headerlink" title="DAGScheduler"></a>DAGScheduler</h3><p>&emsp;DAGScheduler 会在 action 算子执行的时候被触发。action算子触发sc.runJob,经过几次调用之后，会调用：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SparkContext</span></span><br><span class="line">dagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, resultHandler, localProperties.get)</span><br></pre></td></tr></table></figure><br>&emsp;这里就是 DAGScheduler 开始执行调度的入口：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//dagScheduler.runJob</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runJob</span></span>[<span class="type">T</span>, <span class="type">U</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">      callSite: <span class="type">CallSite</span>,</span><br><span class="line">      resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>,</span><br><span class="line">      properties: <span class="type">Properties</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> start = <span class="type">System</span>.nanoTime</span><br><span class="line"></span><br><span class="line">    <span class="comment">//作业提交</span></span><br><span class="line">    <span class="keyword">val</span> waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//等待作业完成</span></span><br><span class="line">    <span class="type">ThreadUtils</span>.awaitReady(waiter.completionFuture, <span class="type">Duration</span>.<span class="type">Inf</span>)</span><br><span class="line">    waiter.completionFuture.value.get <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> scala.util.<span class="type">Success</span>(_) =&gt;</span><br><span class="line">        logInfo(<span class="string">"Job %d finished: %s, took %f s"</span>.format</span><br><span class="line">          (waiter.jobId, callSite.shortForm, (<span class="type">System</span>.nanoTime - start) / <span class="number">1e9</span>))</span><br><span class="line">      <span class="keyword">case</span> scala.util.<span class="type">Failure</span>(exception) =&gt;</span><br><span class="line">        logInfo(<span class="string">"Job %d failed: %s, took %f s"</span>.format</span><br><span class="line">          (waiter.jobId, callSite.shortForm, (<span class="type">System</span>.nanoTime - start) / <span class="number">1e9</span>))</span><br><span class="line">        <span class="comment">// SPARK-8644: Include user stack trace in exceptions coming from DAGScheduler.</span></span><br><span class="line">        <span class="keyword">val</span> callerStackTrace = <span class="type">Thread</span>.currentThread().getStackTrace.tail</span><br><span class="line">        exception.setStackTrace(exception.getStackTrace ++ callerStackTrace)</span><br><span class="line">        <span class="keyword">throw</span> exception</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;调用了 submitJob 方法来提交作业，这里会发生阻塞，等待作业完成。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DAGScheduler</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submitJob</span></span>[<span class="type">T</span>, <span class="type">U</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">      callSite: <span class="type">CallSite</span>,</span><br><span class="line">      resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>,</span><br><span class="line">      properties: <span class="type">Properties</span>): <span class="type">JobWaiter</span>[<span class="type">U</span>] = &#123;</span><br><span class="line">    <span class="comment">// Check to make sure we are not launching a task on a partition that does not exist.</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    assert(partitions.size &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> func2 = func.asInstanceOf[(<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _]</span><br><span class="line">    <span class="keyword">val</span> waiter = <span class="keyword">new</span> <span class="type">JobWaiter</span>(<span class="keyword">this</span>, jobId, partitions.size, resultHandler)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//发送JobSubmitted消息</span></span><br><span class="line">    eventProcessLoop.post(<span class="type">JobSubmitted</span>(</span><br><span class="line">      jobId, rdd, func2, partitions.toArray, callSite, waiter,</span><br><span class="line">      <span class="type">SerializationUtils</span>.clone(properties)))</span><br><span class="line">    waiter</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;submitJob 创建了 JobWaiter 对象，并发送 JobSubmitted 消息给 DAGScheduler 内嵌的 DAGSchedulerEventProcessLoop 类对象 eventProcessLoop 进行处理:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.DAGSchedulerEventProcessLoop</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doOnReceive</span></span>(event: <span class="type">DAGSchedulerEvent</span>): <span class="type">Unit</span> = event <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JobSubmitted</span>(jobId, rdd, func, partitions, callSite, listener, properties) =&gt;</span><br><span class="line">      dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties)</span><br><span class="line"></span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><br>&emsp;dagScheduler.handleJobSubmitted 方法是个很关键的方法，包含了作业提交处理的主要逻辑。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[scheduler] <span class="function"><span class="keyword">def</span> <span class="title">handleJobSubmitted</span></span>(jobId: <span class="type">Int</span>,</span><br><span class="line">      finalRDD: <span class="type">RDD</span>[_],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _,</span><br><span class="line">      partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">      callSite: <span class="type">CallSite</span>,</span><br><span class="line">      listener: <span class="type">JobListener</span>,</span><br><span class="line">      properties: <span class="type">Properties</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> finalStage: <span class="type">ResultStage</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// New stage creation may throw an exception if, for example, jobs are run on a</span></span><br><span class="line">      <span class="comment">// HadoopRDD whose underlying HDFS files have been deleted.</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//创建 ResultStage</span></span><br><span class="line">      finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    finalStage.setActiveJob(job)</span><br><span class="line">    <span class="keyword">val</span> stageIds = jobIdToStageIds(jobId).toArray</span><br><span class="line">    <span class="keyword">val</span> stageInfos = stageIds.flatMap(id =&gt; stageIdToStage.get(id).map(_.latestInfo))</span><br><span class="line">    listenerBus.post(</span><br><span class="line">      <span class="type">SparkListenerJobStart</span>(job.jobId, jobSubmissionTime, stageInfos, properties))</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//提交 Stage，开始切分Stage</span></span><br><span class="line">    submitStage(finalStage)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;finalRDD 是这 RDD 依赖链的最后一个RDD，即 action 触发作业提交的那个RDD。有两种类型的 Stage，ResultStage 和 ShuffleMapStage。finalRDD 是最后一个 RDD，包含在最后一个 Stage 中，结果直接输出，不需要再经过 shuffle，因此 这里创建的是 ResultStage（除最后的 stage 之外，前面的 stage 都是shufflemapstage）。最后调用 submitStage(finalStage)，会根据 finalStage 沿着父stage继续往前回溯开始切分stage。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.DAGScheduler</span></span><br><span class="line"><span class="comment">/** Submits stage, but first recursively submits any missing parents. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submitStage</span></span>(stage: <span class="type">Stage</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> jobId = activeJobForStage(stage)</span><br><span class="line">    <span class="keyword">if</span> (jobId.isDefined) &#123;</span><br><span class="line">      logDebug(<span class="string">"submitStage("</span> + stage + <span class="string">")"</span>)</span><br><span class="line">      <span class="keyword">if</span> (!waitingStages(stage) &amp;&amp; !runningStages(stage) &amp;&amp; !failedStages(stage)) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//寻找父stage</span></span><br><span class="line">        <span class="keyword">val</span> missing = getMissingParentStages(stage).sortBy(_.id)</span><br><span class="line">        logDebug(<span class="string">"missing: "</span> + missing)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//没有父stage，是最开头的stage，可以提交了</span></span><br><span class="line">        <span class="keyword">if</span> (missing.isEmpty) &#123;</span><br><span class="line">          logInfo(<span class="string">"Submitting "</span> + stage + <span class="string">" ("</span> + stage.rdd + <span class="string">"), which has no missing parents"</span>)</span><br><span class="line">          </span><br><span class="line">          <span class="comment">//提交这个stage给taskscheduler</span></span><br><span class="line">          submitMissingTasks(stage, jobId.get)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (parent &lt;- missing) &#123;</span><br><span class="line">            </span><br><span class="line">            <span class="comment">//沿着父stage继续往前回溯</span></span><br><span class="line">            submitStage(parent)</span><br><span class="line">          &#125;</span><br><span class="line">          waitingStages += stage</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      abortStage(stage, <span class="string">"No active job for stage "</span> + stage.id, <span class="type">None</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;submitStage 会根据依赖关系划分 Stage，通过递归调用从 finalStage 一直沿着父 stage 继续往前回溯，直到当前 Stage 没有父 Stage（missing.isEmpty 为 true） 时就调用 submitMissingTasks 方法提交 Stage 给 taskscheduler 去执行；如果有父 Stage，即 missing 不为空，则遍历 missing，回调当前 Stage 的所有父 Stage submitStage(parent)，然后将当前 Stage被放入 waitingStages 中，等待以后执行 (后面 submitMissingTasks 会介绍)。通过这种方式将 job 划分为一个或者多个 Stage，并且能够保证父 Stage 比子 Stage 先执行其中的任务。&nbsp;<br>&emsp;这里有两个关键的函数，getMissingParentStages 和 submitMissingTasks，下面具体介绍这两个函数。&nbsp;<br>&emsp;getMissingParentStages 的功能是寻找传入 stage 的所有父 stage。这里以是否为 <strong>ShuffleDependency(宽依赖)</strong> 作为划分 Stage 的 界限。关于 Dependency 的详细介绍可以参考文章<a href="http://zhoujiapeng.top/Spark/spark-dependency/">《Spark Dependency 详解》</a>。<br>&emsp;如果 RDD 的依赖是宽依赖，说明已经找到当前 Stage 的边界，可以进行切分，调用 getOrCreateShuffleMapStage 生成该 Stage 的父 Stage。<strong>注意</strong>，这里创建的是 ShuffleMapStage，dagScheduler.handleJobSubmitted 中创建的是 ResultStage；如果是窄依赖，则压入 waitingForVisit 栈顶，等待下一次调用 visit 方法时回溯。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getMissingParentStages</span></span>(stage: <span class="type">Stage</span>): <span class="type">List</span>[<span class="type">Stage</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> missing = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">Stage</span>]</span><br><span class="line">    <span class="keyword">val</span> visited = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">RDD</span>[_]]</span><br><span class="line">    <span class="comment">// We are manually maintaining a stack here to prevent StackOverflowError</span></span><br><span class="line">    <span class="comment">// caused by recursively visiting</span></span><br><span class="line">    <span class="keyword">val</span> waitingForVisit = <span class="keyword">new</span> <span class="type">ArrayStack</span>[<span class="type">RDD</span>[_]]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(rdd: <span class="type">RDD</span>[_]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited(rdd)) &#123;</span><br><span class="line">        visited += rdd</span><br><span class="line">        <span class="keyword">val</span> rddHasUncachedPartitions = getCacheLocs(rdd).contains(<span class="type">Nil</span>)</span><br><span class="line">        <span class="keyword">if</span> (rddHasUncachedPartitions) &#123;</span><br><span class="line">          <span class="keyword">for</span> (dep &lt;- rdd.dependencies) &#123;</span><br><span class="line">            dep <span class="keyword">match</span> &#123;</span><br><span class="line"></span><br><span class="line">              <span class="comment">//如果是宽依赖，切分Stage</span></span><br><span class="line">              <span class="keyword">case</span> shufDep: <span class="type">ShuffleDependency</span>[_, _, _] =&gt;</span><br><span class="line">                <span class="keyword">val</span> mapStage = getOrCreateShuffleMapStage(shufDep, stage.firstJobId)</span><br><span class="line">                <span class="keyword">if</span> (!mapStage.isAvailable) &#123;</span><br><span class="line">                  missing += mapStage</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">case</span> narrowDep: <span class="type">NarrowDependency</span>[_] =&gt;</span><br><span class="line">                waitingForVisit.push(narrowDep.rdd)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    waitingForVisit.push(stage.rdd)</span><br><span class="line">    <span class="keyword">while</span> (waitingForVisit.nonEmpty) &#123;</span><br><span class="line">      visit(waitingForVisit.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    missing.toList</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;submitMissingTasks 会提交当前切分好的 Stage 并执行其中的任务。submitMissingTasks 中将 Stage 封装成 TaskSet 通过 taskScheduler.submitTasks 提交给 TaskScheduler 处理。&nbsp;<br>&emsp;另外，submitMissingTasks 会首先生成 Tasks 的具体执行位置，然后在根据这些位置创建 TaskSet。Task 有两种类型，ShuffleMapTask 和 ResultTask，ShuffleMapStage 会根据 Stage 所依赖的 RDD 的partition 分布产生和 partition 数量相等的 Task，这些 Task 根据 partition 的 locality 进行分布。<br>&emsp;关于 Task 的更多介绍可以参考<a href="http://zhoujiapeng.top/Spark/spark-task/">《Spark Task 详解》</a>。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submitMissingTasks</span></span>(stage: <span class="type">Stage</span>, jobId: <span class="type">Int</span>) &#123;</span><br><span class="line">    logDebug(<span class="string">"submitMissingTasks("</span> + stage + <span class="string">")"</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> taskIdToLocations: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">TaskLocation</span>]] = <span class="keyword">try</span> &#123;</span><br><span class="line">      stage <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt; (id, getPreferredLocs(stage.rdd, id))&#125;.toMap</span><br><span class="line">        <span class="keyword">case</span> s: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> p = s.partitions(id)</span><br><span class="line">            (id, getPreferredLocs(stage.rdd, p))</span><br><span class="line">          &#125;.toMap</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> tasks: <span class="type">Seq</span>[<span class="type">Task</span>[_]] = <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> serializedTaskMetrics = closureSerializer.serialize(stage.latestInfo.taskMetrics).array()</span><br><span class="line">      stage <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">          stage.pendingPartitions.clear()</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">            <span class="keyword">val</span> part = partitions(id)</span><br><span class="line">            stage.pendingPartitions += id</span><br><span class="line">            <span class="keyword">new</span> <span class="type">ShuffleMapTask</span>(stage.id, stage.latestInfo.attemptNumber,</span><br><span class="line">              taskBinary, part, locs, properties, serializedTaskMetrics, <span class="type">Option</span>(jobId),</span><br><span class="line">              <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId, stage.rdd.isBarrier())</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> p: <span class="type">Int</span> = stage.partitions(id)</span><br><span class="line">            <span class="keyword">val</span> part = partitions(p)</span><br><span class="line">            <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">            <span class="keyword">new</span> <span class="type">ResultTask</span>(stage.id, stage.latestInfo.attemptNumber,</span><br><span class="line">              taskBinary, part, locs, id, properties, serializedTaskMetrics,</span><br><span class="line">              <span class="type">Option</span>(jobId), <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId,</span><br><span class="line">              stage.rdd.isBarrier())</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">        abortStage(stage, <span class="string">s"Task creation failed: <span class="subst">$e</span>\n<span class="subst">$&#123;Utils.exceptionString(e)&#125;</span>"</span>, <span class="type">Some</span>(e))</span><br><span class="line">        runningStages -= stage</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tasks.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      logInfo(<span class="string">s"Submitting <span class="subst">$&#123;tasks.size&#125;</span> missing tasks from <span class="subst">$stage</span> (<span class="subst">$&#123;stage.rdd&#125;</span>) (first 15 "</span> +</span><br><span class="line">        <span class="string">s"tasks are for partitions <span class="subst">$&#123;tasks.take(15).map(_.partitionId)&#125;</span>)"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">      taskScheduler.submitTasks(<span class="keyword">new</span> <span class="type">TaskSet</span>(</span><br><span class="line">        tasks.toArray, stage.id, stage.latestInfo.attemptNumber, jobId, properties))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">      submitWaitingChildStages(stage)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;总共有两种类型的 Stage，ShuffleMapStage 和 ResultStage,只有最后一个 Stage 才是 ResultStage，其它的都是 ShuffleMapStage。这里会根据不同的 Stage 创建不同的 Task，ShuffleMapStage 对应 ShuffleMapTask，ResultStage 对应 ResultTask。当前 Stage 的 Task 提交之后，最后执行 submitWaitingChildStages(stage)，这里会从之前放入 waitingStages 的 Stage 中过滤出属于当前 Stage 的子 Stage，继续调用 submitStage，即父 Stage 执行结束后，开始执行子 Stage。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submitWaitingChildStages</span></span>(parent: <span class="type">Stage</span>) &#123;</span><br><span class="line">    logTrace(<span class="string">s"Checking if any dependencies of <span class="subst">$parent</span> are now runnable"</span>)</span><br><span class="line">    logTrace(<span class="string">"running: "</span> + runningStages)</span><br><span class="line">    logTrace(<span class="string">"waiting: "</span> + waitingStages)</span><br><span class="line">    logTrace(<span class="string">"failed: "</span> + failedStages)</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从waitingStages中过滤出当前stage的子stage</span></span><br><span class="line">    <span class="keyword">val</span> childStages = waitingStages.filter(_.parents.contains(parent)).toArray</span><br><span class="line">    waitingStages --= childStages</span><br><span class="line">    <span class="keyword">for</span> (stage &lt;- childStages.sortBy(_.firstJobId)) &#123;</span><br><span class="line">      <span class="comment">//提交子stage</span></span><br><span class="line">      submitStage(stage)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>&emsp;action 算子会触发 SparkContext.runjob，然后调用 dagScheduler.runJob 触发 DAGScheduler 开始 Stage 切分。有两种类型的 Stage，ResultStage 和 ShuffleMapStage。DAGScheduler 以 RDD 的依赖是否为 ShuffleDependency 来决定是否需要进行 Stage 切分。因此相邻 Stage 之间会存在一个 Shuffle 的过程，所以除了最后一个 Stage 之外所有的 Stage 都是 ShuffleMapStage。最后一个 Stage 只需要将计算结果输出就行，不再需要 Shuffle，所以是 ResultStage。<br>&emsp;简单来说，DAGScheduler 的 Stage 切分过程为：根据 RDD 依赖链的最后一个 RDD(finalRDD) 创建一个 ResultStage，然后沿着 finalRDD 不断往前遍历，遇到 RDD 的依赖为 ShuffleDependency 时就创建一个 ShuffleMapStage。当无法再继续找到父 Stage 的时候，则提交当前 Stage 给 TaskScheduler，接着提交当前 Stage 的子 Stage，直到所有的 Stage 都被提交。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-dagscheduler/">http://zhoujiapeng.top/Spark/spark-dagscheduler/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark源码阅读 之 Task 详解</title>
      <link href="/Spark/spark-task/"/>
      <url>/Spark/spark-task/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-Task-详解"><a href="#Spark-Task-详解" class="headerlink" title="Spark Task 详解"></a>Spark Task 详解</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><h2 id="1-Task"><a href="#1-Task" class="headerlink" title="1. Task"></a>1. Task</h2><p> &emsp;首先我们先来看一下源码中的介绍，Task 抽象类有这么一段注释：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;*</span><br><span class="line"> * A Spark job consists of one or more stages. The very last stage in a job consists of multiple</span><br><span class="line"> * ResultTasks, while earlier stages consist of ShuffleMapTasks. A ResultTask executes the task</span><br><span class="line"> * and sends the task output back to the driver application. A ShuffleMapTask executes the task</span><br><span class="line"> * and divides the task output to multiple buckets (based on the task&#39;s partitioner).</span><br><span class="line"> *&#x2F;</span><br><span class="line"> private[spark] abstract class Task[T](</span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><br>&emsp;意思大致为：一个 Spark job 会包含多个 stage，最后一个 stage 由多个 ResultTask 组成，而签名的 stage 由多个 ShuffleMapTask 组成。ResultTask 会将任务执行结果发送给 driver，ShuffleMapTask 会将任务执行结果根据 task 的分区输出到多个 buckets（一些本地文件）。<br>&emsp;也就是说 Spark 中有两种类型的 Task：ResultTask：对应于 DAG 图中最后一个 Stage（也就是 ResultStage）；ShuffleMapTask：对应于非最后的 Stage（也就是 ShuffleMapStage）。</p><h2 id="2-TaskRunner"><a href="#2-TaskRunner" class="headerlink" title="2. TaskRunner"></a>2. TaskRunner</h2><p>&emsp;我们再来看一下 Task 的运行过程，TaskRunner 类实现了 Task 的主要运行工作原理：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">TaskRunner</span>(<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    execBackend: <span class="type">ExecutorBackend</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    private val taskDescription: <span class="type">TaskDescription</span></span>)</span></span><br><span class="line"><span class="class">  <span class="keyword">extends</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// 对task数据，反序列化</span></span><br><span class="line">      <span class="type">Executor</span>.taskDeserializationProps.set(taskDescription.properties)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 将依赖的文件资源、jar拷贝到到task读取文件的对应目录</span></span><br><span class="line">      updateDependencies(taskDescription.addedFiles, taskDescription.addedJars)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 反序列化 Taskset</span></span><br><span class="line">      task = ser.deserialize[<span class="type">Task</span>[<span class="type">Any</span>]](</span><br><span class="line">        taskDescription.serializedTask, <span class="type">Thread</span>.currentThread.getContextClassLoader)</span><br><span class="line">      task.localProperties = taskDescription.properties</span><br><span class="line">      task.setTaskMemoryManager(taskMemoryManager)</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> value = <span class="type">Utils</span>.tryWithSafeFinally &#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 如果是 ShuffleMapTask，这里的 res 就是 MapStatus</span></span><br><span class="line">        <span class="comment">// 如果后面执行的还是一个ShuffleMapTask，就会联系MapOutputTracker去获取上一个ShuffleMapTask的输出结果。 ResultTask也是一样的。</span></span><br><span class="line">        <span class="keyword">val</span> res = task.run(</span><br><span class="line">          taskAttemptId = taskId,</span><br><span class="line">          attemptNumber = taskDescription.attemptNumber,</span><br><span class="line">          metricsSystem = env.metricsSystem)</span><br><span class="line">        threwException = <span class="literal">false</span></span><br><span class="line">        res</span><br><span class="line">      &#125; &#123;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 对MapStatus 序列化和封装，因为要发送给driver</span></span><br><span class="line">      <span class="keyword">val</span> resultSer = env.serializer.newInstance()</span><br><span class="line">      <span class="keyword">val</span> beforeSerialization = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">      <span class="keyword">val</span> valueBytes = resultSer.serialize(value)</span><br><span class="line">      <span class="keyword">val</span> afterSerialization = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">      setTaskFinishedAndClearInterruptStatus()</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 调用了executor所在的CoraseGrainedBackend的statusUpdate()方法</span></span><br><span class="line">      execBackend.statusUpdate(taskId, <span class="type">TaskState</span>.<span class="type">FINISHED</span>, serializedResult)</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>&emsp;任务的实际执行是通过 task.run ，我们看一下这个方法<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Task.run</span></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(</span><br><span class="line">      taskAttemptId: <span class="type">Long</span>,</span><br><span class="line">      attemptNumber: <span class="type">Int</span>,</span><br><span class="line">      metricsSystem: <span class="type">MetricsSystem</span>): <span class="type">T</span> = &#123;</span><br><span class="line">    <span class="type">SparkEnv</span>.get.blockManager.registerTask(taskAttemptId)</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//task执行上下文，记录了task执行的全局性的数据，例如task重试次数，属于哪个stage，rdd处理的partition等</span></span><br><span class="line">    <span class="keyword">val</span> taskContext = <span class="keyword">new</span> <span class="type">TaskContextImpl</span>(</span><br><span class="line">      stageId,</span><br><span class="line">      stageAttemptId, <span class="comment">// stageAttemptId and stageAttemptNumber are semantically equal</span></span><br><span class="line">      partitionId,</span><br><span class="line">      taskAttemptId,</span><br><span class="line">      attemptNumber,</span><br><span class="line">      taskMemoryManager,</span><br><span class="line">      localProperties,</span><br><span class="line">      metricsSystem,</span><br><span class="line">      metrics)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      runTask(context)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Throwable</span> =&gt;</span><br><span class="line">        <span class="comment">// Catch all errors; run task failure callbacks, and rethrow the exception.</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          context.markTaskFailed(e)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> t: <span class="type">Throwable</span> =&gt;</span><br><span class="line">            e.addSuppressed(t)</span><br><span class="line">        &#125;</span><br><span class="line">        context.markTaskCompleted(<span class="type">Some</span>(e))</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里调用了 runTask 方法，Task 类中的 runTask 方法并没有定义具体的逻辑，这是因为 ResultTask 和 ShuffleMapTask 的逻辑不一样。</p><h2 id="3-ShuffleMapTask-runTask"><a href="#3-ShuffleMapTask-runTask" class="headerlink" title="3. ShuffleMapTask.runTask"></a>3. ShuffleMapTask.runTask</h2><p>&emsp;我们先看一些 ShuffleMapTask.runTask 方法<br>ShuffleMapTask runTask<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ShuffleMapTask runTask</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">runTask</span></span>(context: <span class="type">TaskContext</span>): <span class="type">MapStatus</span> = &#123;</span><br><span class="line">    <span class="comment">// Deserialize the RDD using the broadcast variable.</span></span><br><span class="line">    <span class="keyword">val</span> threadMXBean = <span class="type">ManagementFactory</span>.getThreadMXBean</span><br><span class="line">    <span class="keyword">val</span> deserializeStartTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> deserializeStartCpuTime = <span class="keyword">if</span> (threadMXBean.isCurrentThreadCpuTimeSupported) &#123;</span><br><span class="line">      threadMXBean.getCurrentThreadCpuTime</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="number">0</span>L</span><br><span class="line">    <span class="keyword">val</span> ser = <span class="type">SparkEnv</span>.get.closureSerializer.newInstance()</span><br><span class="line">    <span class="keyword">val</span> (rdd, dep) = ser.deserialize[(<span class="type">RDD</span>[_], <span class="type">ShuffleDependency</span>[_, _, _])](</span><br><span class="line">      <span class="type">ByteBuffer</span>.wrap(taskBinary.value), <span class="type">Thread</span>.currentThread.getContextClassLoader)</span><br><span class="line">    _executorDeserializeTime = <span class="type">System</span>.currentTimeMillis() - deserializeStartTime</span><br><span class="line">    _executorDeserializeCpuTime = <span class="keyword">if</span> (threadMXBean.isCurrentThreadCpuTimeSupported) &#123;</span><br><span class="line">      threadMXBean.getCurrentThreadCpuTime - deserializeStartCpuTime</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="number">0</span>L</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> writer: <span class="type">ShuffleWriter</span>[<span class="type">Any</span>, <span class="type">Any</span>] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> manager = <span class="type">SparkEnv</span>.get.shuffleManager</span><br><span class="line">      writer = manager.getWriter[<span class="type">Any</span>, <span class="type">Any</span>](dep.shuffleHandle, partitionId, context)</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 首先，调用rdd的iterator方法来获取数据，并且传入了当前要处理的partition</span></span><br><span class="line">      <span class="comment">// 核心逻辑就在rdd的iterator()方法中</span></span><br><span class="line">      <span class="comment">// write 方法将数据写入到对应的 bucket 中，供下游 task 拉取</span></span><br><span class="line">      writer.write(rdd.iterator(partition, context).asInstanceOf[<span class="type">Iterator</span>[_ &lt;: <span class="type">Product2</span>[<span class="type">Any</span>, <span class="type">Any</span>]]])</span><br><span class="line"></span><br><span class="line">      <span class="comment">// 返回结果 MapStatus ，里面封装了ShuffleMapTask存储在哪里，其实就是BlockManager相关信息</span></span><br><span class="line">      writer.stop(success = <span class="literal">true</span>).get</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">if</span> (writer != <span class="literal">null</span>) &#123;</span><br><span class="line">            writer.stop(success = <span class="literal">false</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">            log.debug(<span class="string">"Could not stop writer"</span>, e)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">throw</span> e</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;与 ResultTask 对 partition 数据进行计算得到计算结果并汇报给 driver 不同，ShuffleMapTask 的职责是为下游的 RDD 计算出输入数据。更具体的说，ShuffleMapTask 要计算出 partition 数据并通过 shuffle write 写入磁盘（由 BlockManager 来管理）来等待下游的 RDD 通过 shuffle read 读取，其核心流程如下：</p><ol><li>从 SparkEnv 中获取 ShuffleManager 对象</li><li>从 ShuffleManager 中获取 ShuffleWriter 对象 writer</li><li>得到对应 partition 的迭代器后，通过 writer 将数据写入文件系统中</li><li>停止 writer 并返回结果</li></ol><p>&emsp;MapOutputTrancker 用于跟踪 map 任务的输出状态，即 ShuffleMapTask 的输出 MapStatue，此状态便于 reduce 任务定位到 map 输出结果所在的节点地址，进而获取中间输出结果。</p><h2 id="4-ResultTask-runTask"><a href="#4-ResultTask-runTask" class="headerlink" title="4. ResultTask.runTask"></a>4. ResultTask.runTask</h2><p>&emsp;了解完 ShuffleMapTask，我们再来看一下 ResultTask：</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ResultTask.runTask</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">runTask</span></span>(context: <span class="type">TaskContext</span>): <span class="type">U</span> = &#123;</span><br><span class="line">    <span class="comment">// Deserialize the RDD and the func using the broadcast variables.</span></span><br><span class="line">    <span class="keyword">val</span> threadMXBean = <span class="type">ManagementFactory</span>.getThreadMXBean</span><br><span class="line">    <span class="keyword">val</span> deserializeStartTime = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line">    <span class="keyword">val</span> deserializeStartCpuTime = <span class="keyword">if</span> (threadMXBean.isCurrentThreadCpuTimeSupported) &#123;</span><br><span class="line">      threadMXBean.getCurrentThreadCpuTime</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="number">0</span>L</span><br><span class="line">    <span class="keyword">val</span> ser = <span class="type">SparkEnv</span>.get.closureSerializer.newInstance()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//反序列化得到 rdd 及 rdd 的处理方法 func</span></span><br><span class="line">    <span class="keyword">val</span> (rdd, func) = ser.deserialize[(<span class="type">RDD</span>[<span class="type">T</span>], (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>)](</span><br><span class="line">      <span class="type">ByteBuffer</span>.wrap(taskBinary.value), <span class="type">Thread</span>.currentThread.getContextClassLoader)</span><br><span class="line">    _executorDeserializeTime = <span class="type">System</span>.currentTimeMillis() - deserializeStartTime</span><br><span class="line">    _executorDeserializeCpuTime = <span class="keyword">if</span> (threadMXBean.isCurrentThreadCpuTimeSupported) &#123;</span><br><span class="line">      threadMXBean.getCurrentThreadCpuTime - deserializeStartCpuTime</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="number">0</span>L</span><br><span class="line"></span><br><span class="line">    <span class="comment">//对 rdd 指定 partition 的迭代器执行 func 函数</span></span><br><span class="line">    func(context, rdd.iterator(partition, context))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;ResultTask.runTask 的核心流程为：</p><ol><li>反序列化得到 rdd 及 处理方法 func</li><li>对 rdd 指定 partition 的迭代器执行 func 函数并返回结果</li></ol><h2 id="5-Shuffle"><a href="#5-Shuffle" class="headerlink" title="5. Shuffle"></a>5. Shuffle</h2><p>&emsp;我们前面多次提到，ShuffleMapTask 会将计算结果写入 bucket 作为上游数据，供下游的 ResultTask 需要时拉取。接下来我们大致看一下这个过程：<br>&emsp;Shuffle 的写操作（Shuffle writer）是将 MapTask 操作后的数据写入磁盘中，ShuffleMapTask 会为每个 ReduceTask 创建对应的 Bucket，ShuffleMapTask 产生的结果会根据设置的 partitioner（分区）得到对应的 BucketId，然后填充到相应的 Bucket 中。每个 ShuffleMapTask 的输出结果可能包含所有的 ReduceTask 需要的数据，所以每个 ShuffleMapTask 创建的 Bucket 数目是和 ReduceTask 的数目相等的。ShuffleMapTask 创建的 Bucket 对应于磁盘上的一个文件，用来储存结果，此文件也被称为 BlockFile。如下图所示：<br><img src="https://gitee.com/JP6907/Pic/raw/master/spark/spark-shuffle1.jpg" alt="spark-shuffle"><br>&emsp;每个 Map Task 为每个 Reduce Task 生成一个文件，通常会产生大量的文件（即对应为 M*R 个中间文件，其中 M 表示 Map Task 个数，R 表示 Reduce Task 个数），伴随大量的随机磁盘 I/O 操作与大量的内存开销。总结下这里的两个严重问题：</p><ol><li>生成大量文件，占用文件描述符，同时引入 DiskObjectWriter 带来的 Writer Handler 的缓存也非常消耗内存；</li><li>如果在 Reduce Task 时需要合并操作的话，会把数据放在一个 HashMap 中进行合并，如果数据量较大，很容易引发 OOM。</li></ol><p>&emsp;因此，Spark 做了改进，引入了 File Consolidation 机制。<br>&emsp;一个 Executor 上所有的 Map Task 生成的分区文件只有一份，即将所有的 Map Task 相同的分区文件合并，这样每个 Executor 上最多只生成 N 个分区文件。<br><img src="https://gitee.com/JP6907/Pic/raw/master/spark/spark-shuffle2.jpg" alt="spark-shuffle-aggregate"></p><p>&emsp;我们再来看一下，shuffle 过程是怎么利用 MapOutputTrancker 记录的 MapStatue：</p><ol><li><p>在 ShuffleRDD 的 compute 方法中，会获取 BlockStoreShuffleReader，然后在 BlockStoreShuffleReader 中，BlockStoreShuffleReader 的 read 方法会调用 mapOutputTracker.getMapSizesByExecutorId 方法获取一组二元组序列Seq[(BlockManagerId, Seq[(BlockId, Long)])]，第一项代表了 BlockManagerId，第二项描述了存储于该 BlockManager上的一组 shuffle blocks。</p></li><li><p>getMapSizesByExecutorId会调用getStatuses方法获取MapStatus集合，然后最后返回MapStatus集合。</p></li><li><p>最后根据执行的分区范围[startPartition, endPartition]将返回的结果Array[MapStatus]转换成Seq[(BlockManagerId, Seq[(BlockId, Long)])]。</p></li><li><p>利用这个Seq[(BlockManagerId, Seq[(BlockId, Long)])]，去指定的BlockManager中去拉取对应的Block块的数据用来迭代计算。</p></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BlockStoreShuffleReader.read</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">read</span></span>(): <span class="type">Iterator</span>[<span class="type">Product2</span>[<span class="type">K</span>, <span class="type">C</span>]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> wrappedStreams = <span class="keyword">new</span> <span class="type">ShuffleBlockFetcherIterator</span>(</span><br><span class="line">      context,</span><br><span class="line">      blockManager.shuffleClient,</span><br><span class="line">      blockManager,</span><br><span class="line">      mapOutputTracker.getMapSizesByExecutorId(handle.shuffleId, startPartition, endPartition),</span><br><span class="line">      serializerManager.wrapStream,</span><br><span class="line">      <span class="comment">// Note: we use getSizeAsMb when no suffix is provided for backwards compatibility</span></span><br><span class="line">      <span class="type">SparkEnv</span>.get.conf.getSizeAsMb(<span class="string">"spark.reducer.maxSizeInFlight"</span>, <span class="string">"48m"</span>) * <span class="number">1024</span> * <span class="number">1024</span>,</span><br><span class="line">      <span class="type">SparkEnv</span>.get.conf.getInt(<span class="string">"spark.reducer.maxReqsInFlight"</span>, <span class="type">Int</span>.<span class="type">MaxValue</span>),</span><br><span class="line">      <span class="type">SparkEnv</span>.get.conf.get(config.<span class="type">REDUCER_MAX_BLOCKS_IN_FLIGHT_PER_ADDRESS</span>),</span><br><span class="line">      <span class="type">SparkEnv</span>.get.conf.get(config.<span class="type">MAX_REMOTE_BLOCK_SIZE_FETCH_TO_MEM</span>),</span><br><span class="line">      <span class="type">SparkEnv</span>.get.conf.getBoolean(<span class="string">"spark.shuffle.detectCorrupt"</span>, <span class="literal">true</span>))</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-task/">http://zhoujiapeng.top/Spark/spark-task/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo 文章置顶功能</title>
      <link href="/Hexo/hexo-article-set-top/"/>
      <url>/Hexo/hexo-article-set-top/</url>
      
        <content type="html"><![CDATA[<h1 id="Hexo-实现文章置顶"><a href="#Hexo-实现文章置顶" class="headerlink" title="Hexo 实现文章置顶"></a>Hexo 实现文章置顶</h1><h3 id="文章列表置顶"><a href="#文章列表置顶" class="headerlink" title="文章列表置顶"></a>文章列表置顶</h3><p>&emsp;Hexo 中文章指定功能无法通过配置实现，需要修改 node_modules/hexo-generator-index/lib/generator.js 文件。<br>需要添加的代码：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">  &#125;);</span><br></pre></td></tr></table></figure><br>以下是最终的generator.js内容：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> pagination = <span class="built_in">require</span>(<span class="string">'hexo-pagination'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = <span class="function"><span class="keyword">function</span>(<span class="params">locals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> config = <span class="keyword">this</span>.config;</span><br><span class="line">  <span class="keyword">var</span> posts = locals.posts.sort(config.index_generator.order_by);</span><br><span class="line"></span><br><span class="line">  posts.data = posts.data.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">if</span>(a.top == b.top) <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">          <span class="keyword">else</span> <span class="keyword">return</span> b.top - a.top;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(a.top &amp;&amp; !b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">if</span>(!a.top &amp;&amp; b.top) &#123;</span><br><span class="line">          <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span> <span class="keyword">return</span> b.date - a.date;</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> paginationDir = config.pagination_dir || <span class="string">'page'</span>;</span><br><span class="line">  <span class="keyword">var</span> path = config.index_generator.path || <span class="string">''</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> pagination(path, posts, &#123;</span><br><span class="line">    perPage: config.index_generator.per_page,</span><br><span class="line">    layout: [<span class="string">'index'</span>, <span class="string">'archive'</span>],</span><br><span class="line">    format: paginationDir + <span class="string">'/%d/'</span>,</span><br><span class="line">    data: &#123;</span><br><span class="line">      __index: <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><br>之后在文章中添加 top 标签可以设置置顶顺序。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: 文章名</span><br><span class="line">date: 文章发布时间</span><br><span class="line">tags: 文章标签</span><br><span class="line">top: 100(文章置顶)</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p><h3 id="显示置顶标志"><a href="#显示置顶标志" class="headerlink" title="显示置顶标志"></a>显示置顶标志</h3><p>&emsp;修改 themes/theme-name/layout/index.ejs 文件，在标签<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;a href=<span class="string">"&lt;%- config.root %&gt;&lt;%- post.path %&gt;"</span>&gt;</span><br><span class="line">        &lt;h2 <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-title"</span>&gt;</span><br></pre></td></tr></table></figure><br>下插入<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&lt;% <span class="keyword">if</span> (post.top)&#123; %&gt;</span><br><span class="line">                &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-thumb-tack"</span> style=<span class="string">"color:#F4711F"</span> &gt;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">                &lt;font color=#F4711F&gt;置顶&lt;/</span>font&gt;</span><br><span class="line">            &lt;% &#125; %&gt;</span><br></pre></td></tr></table></figure><br>完整的 preview 为：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">&lt;% page.posts.each(<span class="function"><span class="keyword">function</span>(<span class="params">post</span>)</span>&#123; %&gt;</span><br><span class="line">&lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-preview"</span>&gt;</span><br><span class="line"></span><br><span class="line">    &lt;a href=<span class="string">"&lt;%- config.root %&gt;&lt;%- post.path %&gt;"</span>&gt;</span><br><span class="line">        &lt;h2 <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-title"</span>&gt;</span><br><span class="line">            &lt;% <span class="keyword">if</span> (post.top)&#123; %&gt;</span><br><span class="line">                &lt;i <span class="class"><span class="keyword">class</span></span>=<span class="string">"fa fa-thumb-tack"</span> style=<span class="string">"color:#F4711F"</span> &gt;&lt;<span class="regexp">/i&gt;</span></span><br><span class="line"><span class="regexp">                &lt;font color=#F4711F&gt;置顶&lt;/</span>font&gt;</span><br><span class="line">            &lt;% &#125; %&gt;                     </span><br><span class="line">            &lt;%- post.title || <span class="string">"Untitled"</span> %&gt;</span><br><span class="line">        &lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">        &lt;h3 class="post-subtitle"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;%- post.subtitle || "" %&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>h3&gt;</span><br><span class="line">        &lt;div <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-content-preview"</span>&gt;</span><br><span class="line">            &lt;%- truncate(strip_html(post.content), &#123;<span class="attr">length</span>: <span class="number">200</span>, <span class="attr">omission</span>: <span class="string">'...'</span>&#125;) %&gt;...</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>a&gt;</span><br><span class="line">    &lt;% <span class="keyword">if</span> (config.home_posts_tag)&#123;%&gt;</span><br><span class="line">        &lt;p <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-meta"</span> style=<span class="string">"margin: 10px 0;"</span>&gt;</span><br><span class="line">            Posted by &lt;%- post.author || config.author %&gt; on</span><br><span class="line">            &lt;%= post.date.format(config.date_format) %&gt;</span><br><span class="line">        &lt;<span class="regexp">/p&gt;</span></span><br><span class="line"><span class="regexp">        &lt;div class="tags"&gt;</span></span><br><span class="line"><span class="regexp">            &lt;% post.tags.forEach(function(tag)&#123; %&gt;</span></span><br><span class="line">              &lt;a href="&lt;%= config.root %&gt;tags/#&lt;%= tag.name %&gt;" title="&lt;%= tag.name %&gt;"&gt;&lt;%= tag.name %&gt;&lt;/a&gt;</span><br><span class="line">            &lt;% &#125;) %&gt;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;%&#125; else &#123;%&gt;</span></span><br><span class="line"><span class="regexp">        &lt;p class="post-meta"&gt;</span></span><br><span class="line"><span class="regexp">            Posted by &lt;%- post.author || config.author %&gt; on</span></span><br><span class="line"><span class="regexp">            &lt;%= post.date.format(config.date_format) %&gt;</span></span><br><span class="line"><span class="regexp">        &lt;/</span>p&gt;</span><br><span class="line">    &lt;%&#125;%&gt;</span><br><span class="line"></span><br><span class="line">&lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">&lt;hr&gt;</span></span><br><span class="line"><span class="regexp">&lt;% &#125;); %&gt;</span></span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark源码阅读 之 Dependency 详解</title>
      <link href="/Spark/spark-dependency/"/>
      <url>/Spark/spark-dependency/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-Dependency-实现"><a href="#Spark-Dependency-实现" class="headerlink" title="Spark Dependency 实现"></a>Spark Dependency 实现</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><p>&emsp;在<a href="http://zhoujiapeng.top/Spark/spark-dagscheduler/">《Spark DAGScheduler 详解》</a>中讲到，DADScheduler 根据 ShuffleDependency 来切分 Stage，那么 ShuffleDependency 是怎么实现的，Dependency 又有那些类型？本文根据源码详细剖析 Spark 中 Dependency 的实现原理。</p><h2 id="1-Dependency-的类型"><a href="#1-Dependency-的类型" class="headerlink" title="1. Dependency 的类型"></a>1. Dependency 的类型</h2><p>&emsp;通过源码，我们可以知道，Dependency 是一个抽象类，内部只有一个方法，返回类型是 RDD[T]，因此 RDD 的 Dependency 也是 RDD。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Dependency</span>[<span class="type">T</span>] <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">rdd</span></span>: <span class="type">RDD</span>[<span class="type">T</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;Dependency 只有两个实现类，ShuffleDependency 和 NarrowDependency。NarrowDependency 有三个子类，OneToOneDependency、RangeDependency 和 PruneDependency。因此，总的来说，Dependency 只有两大类型：<strong>ShuffleDependency</strong> 和 <strong>NarrowDependency</strong>，也就是我们常说的宽依赖和窄依赖。</p><h2 id="2-获取-RDD-的-依赖"><a href="#2-获取-RDD-的-依赖" class="headerlink" title="2. 获取 RDD 的 依赖"></a>2. 获取 RDD 的 依赖</h2><p>&emsp;接下来我们来看一下如何获得一个 rdd 的依赖信息。我们可以看到，在DAGScheduler 中 getMissingParentStages 方法 (寻找当前Stage的父Stage) 调用 rdd.dependencies 来获取 RDD 的依赖：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//RDD</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Get the list of dependencies of this RDD, taking into account whether the</span></span><br><span class="line"><span class="comment">   * RDD is checkpointed or not.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">dependencies</span></span>: <span class="type">Seq</span>[<span class="type">Dependency</span>[_]] = &#123;</span><br><span class="line">    checkpointRDD.map(r =&gt; <span class="type">List</span>(<span class="keyword">new</span> <span class="type">OneToOneDependency</span>(r))).getOrElse &#123;</span><br><span class="line">      <span class="keyword">if</span> (dependencies_ == <span class="literal">null</span>) &#123;</span><br><span class="line">        dependencies_ = getDependencies</span><br><span class="line">      &#125;</span><br><span class="line">      dependencies_</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里将 checkpoint 也考虑进去，之所以要考虑 checkpoint，是因为当 rdd 被 checkpoint 之后， 依赖关系会被切断，不能再通过调用 getDependencies 来获取依赖信息。<br>&emsp;关于 checkpoint 的原理可以参考<a href="http://zhoujiapeng.top/Spark/spark-fault-tolerant/">《Spark 容错机制》</a>，这里只做简要概述。<br>&emsp;如果 rdd 被 checkpoint 后， checkpointData 不为空，被赋值为一个 ReliableRDDCheckpointData 对象。执行 checkpointRDD.map(r =&gt; List(new OneToOneDependency(r))) 会生成返回一个OneToOneDependency 类型的 List，OneToOneDependency 是 NarrowDependency 的子类，因此调用 rdd.dependencies 会返回一个 NarrowDependency 列表。<br>&emsp;如果 rdd 没有被checkpoint，则会返回 getOrElse 后面的东西，这里面调用了 getDependencies 来获取依赖信息。由于 RDD 的实现类型很多，我们以 MapPartitionsRDD 和 ShuffledRDD 为例，来说明 getDependencies 。</p><h2 id="3-MapPartitionsRDD"><a href="#3-MapPartitionsRDD" class="headerlink" title="3. MapPartitionsRDD"></a>3. MapPartitionsRDD</h2><p>&emsp;有很多 RDD 算子会返回 MapPartitionsRDD 对象，我们这里以 map 方法为例子，它会返回一个  MapPartitionsRDD 对象。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</span><br><span class="line">    <span class="keyword">val</span> cleanF = sc.clean(f)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (context, pid, iter) =&gt; iter.map(cleanF))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;当前的 RDD（父RDD）作为 MapPartitionsRDD 构造参数中的 prev RDD 传进去。<br>&emsp;我们再看一下 MapPartitionsRDD 的构造：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//MapPartitionsRDD</span></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">MapPartitionsRDD</span>[<span class="type">U</span>: <span class="type">ClassTag</span>, <span class="type">T</span>: <span class="type">ClassTag</span>](<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    var prev: <span class="type">RDD</span>[<span class="type">T</span>],</span></span></span><br><span class="line"><span class="class"><span class="params">    f: (<span class="type">TaskContext</span>, <span class="type">Int</span>, <span class="type">Iterator</span>[<span class="type">T</span>]</span>) <span class="title">=&gt;</span> <span class="title">Iterator</span>[<span class="type">U</span>],  <span class="title">//</span> (<span class="params"><span class="type">TaskContext</span>, partition index, iterator</span>)</span></span><br><span class="line"><span class="class">    <span class="title">preservesPartitioning</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    isFromBarrier: <span class="type">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    isOrderSensitive: <span class="type">Boolean</span> = <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">extends</span> <span class="type">RDD</span>[<span class="type">U</span>](prev)</span><br><span class="line">          ↓↓↓↓↓↓↓</span><br><span class="line"><span class="comment">//RDD[U](prev)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(<span class="meta">@transient</span> oneParent: <span class="type">RDD</span>[_]) =</span><br><span class="line">    <span class="keyword">this</span>(oneParent.context, <span class="type">List</span>(<span class="keyword">new</span> <span class="type">OneToOneDependency</span>(oneParent)))</span><br><span class="line">    ↓↓↓↓↓↓↓</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RDD</span>[<span class="type">T</span>: <span class="type">ClassTag</span>](<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    @transient private var _sc: <span class="type">SparkContext</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    @transient private var deps: <span class="type">Seq</span>[<span class="type">Dependency</span>[_]]</span></span></span><br><span class="line"><span class="class"><span class="params">  </span>) <span class="keyword">extends</span> <span class="title">Serializable</span> <span class="keyword">with</span> <span class="title">Logging</span></span></span><br></pre></td></tr></table></figure><br>第二个参数是deps，传入的实现类型是 OneToOneDependency，即 NarrowDependency。</p><p>我们看一下 getDependencies 方法，返回的正是这个参数，因此 rdd.dependencies 返回的是 NarrowDependency。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">getDependencies</span></span>: <span class="type">Seq</span>[<span class="type">Dependency</span>[_]] = deps</span><br></pre></td></tr></table></figure></p><h2 id="4-ShuffledRDD"><a href="#4-ShuffledRDD" class="headerlink" title="4. ShuffledRDD"></a>4. ShuffledRDD</h2><p>&emsp;接下来看一下 ShuffledRDD。以 reduceByKey 为例，它会返回一个 MapPartitionsRDD 对象或 ShuffledRDD 对象。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reduceByKey</span></span>(func: (<span class="type">V</span>, <span class="type">V</span>) =&gt; <span class="type">V</span>): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">V</span>)] = self.withScope &#123;</span><br><span class="line">    <span class="comment">//defaultPartitioner构造默认分区器</span></span><br><span class="line">    reduceByKey(defaultPartitioner(self), func)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;这里面调用了 defaultPartitioner 方法，它会根据参数(父RDD)构造一个 Partitioner 分区器，这个分区器是 reduce 过程重分区使用的。关于 defaultPartitioner 可以参考<a href="http://zhoujiapeng.top/Spark/spark-partitioner/#4defaultpartitioner-1">《Spark Partitioner 详解》</a>。reduceByKey 方法最终会调用 combineByKeyWithClassTag 方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">combineByKeyWithClassTag</span></span>[<span class="type">C</span>](</span><br><span class="line">      createCombiner: <span class="type">V</span> =&gt; <span class="type">C</span>,</span><br><span class="line">      mergeValue: (<span class="type">C</span>, <span class="type">V</span>) =&gt; <span class="type">C</span>,</span><br><span class="line">      mergeCombiners: (<span class="type">C</span>, <span class="type">C</span>) =&gt; <span class="type">C</span>,</span><br><span class="line">      partitioner: <span class="type">Partitioner</span>,</span><br><span class="line">      mapSideCombine: <span class="type">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line">      serializer: <span class="type">Serializer</span> = <span class="literal">null</span>)(<span class="keyword">implicit</span> ct: <span class="type">ClassTag</span>[<span class="type">C</span>]): <span class="type">RDD</span>[(<span class="type">K</span>, <span class="type">C</span>)] = self.withScope &#123;</span><br><span class="line">    require(mergeCombiners != <span class="literal">null</span>, <span class="string">"mergeCombiners must be defined"</span>) <span class="comment">// required as of Spark 0.9.0</span></span><br><span class="line">    <span class="keyword">if</span> (keyClass.isArray) &#123;</span><br><span class="line">      <span class="keyword">if</span> (mapSideCombine) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"Cannot use map-side combining with array keys."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (partitioner.isInstanceOf[<span class="type">HashPartitioner</span>]) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"HashPartitioner cannot partition array keys."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> aggregator = <span class="keyword">new</span> <span class="type">Aggregator</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">C</span>](</span><br><span class="line">      self.context.clean(createCombiner),</span><br><span class="line">      self.context.clean(mergeValue),</span><br><span class="line">      self.context.clean(mergeCombiners))</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断父分区和子分区器是否一样</span></span><br><span class="line">    <span class="keyword">if</span> (self.partitioner == <span class="type">Some</span>(partitioner)) &#123;</span><br><span class="line">      <span class="comment">//分区器一样，则不需要 shuffle，返回 MapPartitionsRDD</span></span><br><span class="line">      self.mapPartitions(iter =&gt; &#123;</span><br><span class="line">        <span class="keyword">val</span> context = <span class="type">TaskContext</span>.get()</span><br><span class="line">        <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, aggregator.combineValuesByKey(iter, context))</span><br><span class="line">      &#125;, preservesPartitioning = <span class="literal">true</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">//分区器不一样，需要 shuffle，返回 ShuffledRDD</span></span><br><span class="line">      <span class="keyword">new</span> <span class="type">ShuffledRDD</span>[<span class="type">K</span>, <span class="type">V</span>, <span class="type">C</span>](self, partitioner)</span><br><span class="line">        .setSerializer(serializer)</span><br><span class="line">        .setAggregator(aggregator)</span><br><span class="line">        .setMapSideCombine(mapSideCombine)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;combineByKeyWithClassTag 方法会根据 self.partitioner == Some(partitioner)  条件来决定要生成 MapPartitionsRDD 还是 ShuffledRDD。如何理解这个条件？我们假设 reduceByKey 是在某个 RDD 上被调用的，设此 RDD 为A，调用 reduceByKey 生成的 RDD 为B，这个条件里面的 partitioner 就是 reduceByKey 方法里面使用 defaultPartitioner(self) 生成的分区器，也就是 B 的 分区器，self.partitioner 是指 A 的分区器。分区器的作用在于决定 RDD 中每个 KV 对应哪个分区。如果 A 和 B 的分区器一样，它们的分区规则一样，因此 A 中的数据经过计算之后的分区号会保持不变，数据不需要 shuffle，因此会生成一个 MapPartitionsRDD。如果分区器不一样，分区规则不一样，意味着需要 shuffle，所以生成一个 ShuffledRDD。</p><blockquote><p>注意：在特定情况下 reduceByKey 不会导致shuffle，因为在 combineByKey 中会根据 Partitioner 决定需要生成的RDD。</p></blockquote><p>&emsp;MapPartitionsRDD 的 getDependencies 方法在前面已经介绍过了，我们再来看一下 ShuffledRDD 的 getDependencies 方法。ShuffledRDD 重写了 getDependencies 方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getDependencies</span></span>: <span class="type">Seq</span>[<span class="type">Dependency</span>[_]] = &#123;</span><br><span class="line">    <span class="keyword">val</span> serializer = userSpecifiedSerializer.getOrElse &#123;</span><br><span class="line">      <span class="keyword">val</span> serializerManager = <span class="type">SparkEnv</span>.get.serializerManager</span><br><span class="line">      <span class="keyword">if</span> (mapSideCombine) &#123;</span><br><span class="line">        serializerManager.getSerializer(implicitly[<span class="type">ClassTag</span>[<span class="type">K</span>]], implicitly[<span class="type">ClassTag</span>[<span class="type">C</span>]])</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        serializerManager.getSerializer(implicitly[<span class="type">ClassTag</span>[<span class="type">K</span>]], implicitly[<span class="type">ClassTag</span>[<span class="type">V</span>]])</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">List</span>(<span class="keyword">new</span> <span class="type">ShuffleDependency</span>(prev, part, serializer, keyOrdering, aggregator, mapSideCombine))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>这个方法会返回 ShuffleDependency。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>&emsp;从上面两个例子可以看到，getDependencies 方法返回的依赖类型是 NarrowDependency 或 ShuffleDependency，事实上 Dependency 的实现类也只有这两种。<br>&emsp;通过调用 rdd.dependencies 可以获取某个 RDD 的依赖。如果 rdd 已经被 checkpoint，那么它的依赖关系会被清除，rdd.dependencies 会默认返回 OneToOneDependency，即 NarrowDependency。 reduceByKey 在某些情况下不会导致 shuffle，因为在 combineByKey 中会根据 Partitioner 决定需要生成的 RDD，如果 reduceByKey 使用的分区规则和调用者的分区规则一致，会返回一个 MapPartitionsRDD，不需要经过 shuffle。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-dependency/">http://zhoujiapeng.top/Spark/spark-dependency/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark源码阅读 之 Partitioner 详解</title>
      <link href="/Spark/spark-partitioner/"/>
      <url>/Spark/spark-partitioner/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-Partitioner-详解"><a href="#Spark-Partitioner-详解" class="headerlink" title="Spark Partitioner 详解"></a>Spark Partitioner 详解</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><p>&emsp;本文主要根据源码剖析 Spark Partitioner 分区器的实现原理，以及介绍如何自定义分区器。</p><h2 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h2><p>&emsp;Partitioner 是 shuffle 过程中 key 重分区时的策略，即计算 key 决定 k-v 属于哪个分区，Transformation 是宽依赖的算子时，父 RDD 和子 RDD 之间会进行 shuffle 操作，shuffle 涉及到网络开销，由于父 RDD 和子 RDD 中的 partition 是多对多关系，所以容易造成partition中数据分配不均匀，导致数据的倾斜。</p><h2 id="2-Shuffle"><a href="#2-Shuffle" class="headerlink" title="2.Shuffle"></a>2.Shuffle</h2><p>&emsp;在 MapReduce 框架中，Shuffle 是连接 Map 和和 Reduce 之间的桥梁，Map 的输出要用到 Reduce 中必须经过 Shuffle这个环节，Spark 作为 MapReduce 框架的一种实现，自然也实现了 shuffle 的逻辑。<br>&emsp;Shuffle 描述的是一个过程，表现多对多的依赖关系，是 Map 和 Reduce 两个阶段的纽带，是对数据重新分区的过程，将经过 mapTask 后，key 值相同的数据重新划分到同一个 partition 中。<br>&emsp;在 Spark2.4.0 版本中 Shuffle 的实现只保留了 SortShuffleManager，也可以自定义。在本文中，只讨论 Shuffle 过程中 Partitioner 的作用，Partitioner 在 shuffle 的 map 端发挥作用，根据 map 端的 key 值，按照不同 Partitioner 的逻辑计算出 reduce 端的 partitionId，以实现对相同 key 值数据的重新聚合。</p><h2 id="3-Partitioner"><a href="#3-Partitioner" class="headerlink" title="3.Partitioner"></a>3.Partitioner</h2><p>&emsp;Partitioner 是一个抽象类，有两个方法，numPartitions 和 getPartition。numPartitions 返回分区数量，getPartition 根据 key 返回分区 id。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Partitioner</span> <span class="keyword">extends</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="4-defaultPartitioner"><a href="#4-defaultPartitioner" class="headerlink" title="4.defaultPartitioner"></a>4.defaultPartitioner</h2><p>&emsp;defaultPartitioner 是 Partitioner 伴生对象里面定义的一个方法，该函数定义了 Partitioner 的默认分区策略。如果设置了 spark.default.parallelism，则使用该值作为默认 partitions 分区数量，否则使用上游 RDD (参数中的RDD)中 partitions 最大的数作为默认 partitions。过滤出上游 RDD 中包含 partitioner 的 RDD，选择包含有最大 partitions 并且符合 isEligiblePartitioner 条件 的 RDD，将该 RDD 中的partitioner 设置为分区策略，否则返回一个带有默认分区数量的 HashPartitioner 作为 Partitioner。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">defaultPartitioner</span></span>(rdd: <span class="type">RDD</span>[_], others: <span class="type">RDD</span>[_]*): <span class="type">Partitioner</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> rdds = (<span class="type">Seq</span>(rdd) ++ others)</span><br><span class="line">    <span class="keyword">val</span> hasPartitioner = rdds.filter(_.partitioner.exists(_.numPartitions &gt; <span class="number">0</span>))</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> hasMaxPartitioner: <span class="type">Option</span>[<span class="type">RDD</span>[_]] = <span class="keyword">if</span> (hasPartitioner.nonEmpty) &#123;</span><br><span class="line">      <span class="type">Some</span>(hasPartitioner.maxBy(_.partitions.length))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="type">None</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> defaultNumPartitions = <span class="keyword">if</span> (rdd.context.conf.contains(<span class="string">"spark.default.parallelism"</span>)) &#123;</span><br><span class="line">      rdd.context.defaultParallelism</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rdds.map(_.partitions.length).max</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// If the existing max partitioner is an eligible one, or its partitions number is larger</span></span><br><span class="line">    <span class="comment">// than the default number of partitions, use the existing partitioner.</span></span><br><span class="line">    <span class="keyword">if</span> (hasMaxPartitioner.nonEmpty &amp;&amp; (isEligiblePartitioner(hasMaxPartitioner.get, rdds) ||</span><br><span class="line">        defaultNumPartitions &lt; hasMaxPartitioner.get.getNumPartitions)) &#123;</span><br><span class="line">      hasMaxPartitioner.get.partitioner.get</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">HashPartitioner</span>(defaultNumPartitions)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-Partitioner实现类"><a href="#5-Partitioner实现类" class="headerlink" title="5.Partitioner实现类"></a>5.Partitioner实现类</h2><p>&emsp;Partitioner 主要有两个实现类：HashPartitioner 和 RangePartitioner，上面提到过 HashPartitioner 是默认的重分区方式.</p><h3 id="5-1-HashPartitioner"><a href="#5-1-HashPartitioner" class="headerlink" title="5.1 HashPartitioner"></a>5.1 HashPartitioner</h3><p>&emsp;HashPartitioner 将 key 的 hashCode 与分区数量求模得到分区号。由于 Java Array 的 hashcode 依赖于索引而不是 Array 的内容，因此如果尝试使用 HashPartitioner 对 RDD[Array[<em>]] 或 RDD[(Array[</em>], _)] 进行分区，它将不会对 key 值进行重分区，不会得到我们想要的结果。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HashPartitioner</span>(<span class="params">partitions: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line">  require(partitions &gt;= <span class="number">0</span>, <span class="string">s"Number of partitions (<span class="subst">$partitions</span>) cannot be negative."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = partitions</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = key <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="literal">null</span> =&gt; <span class="number">0</span></span><br><span class="line">    <span class="keyword">case</span> _ =&gt; <span class="type">Utils</span>.nonNegativeMod(key.hashCode, numPartitions)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">equals</span></span>(other: <span class="type">Any</span>): <span class="type">Boolean</span> = other <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> h: <span class="type">HashPartitioner</span> =&gt;</span><br><span class="line">      h.numPartitions == numPartitions</span><br><span class="line">    <span class="keyword">case</span> _ =&gt;</span><br><span class="line">      <span class="literal">false</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">hashCode</span></span>: <span class="type">Int</span> = numPartitions</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-2-RangePartitioner"><a href="#5-2-RangePartitioner" class="headerlink" title="5.2 RangePartitioner"></a>5.2 RangePartitioner</h3><p>&emsp;RangePartitioner 主要用于 RDD 的数据排序相关API中，比如 sortByKey 底层使用的数据分区器就是 RangePartitioner 分区器。</p><p><img src="https://gitee.com/JP6907/Pic/raw/master/spark/rangePartitioner.png?raw=true" alt="rangePartitioner"></p><p>&emsp;RangePartitioner 分区器的实现方式主要是通过两个步骤来实现的，第一步：先从整个 RDD 中抽取出样本数据，将样本数据排序，计算出每个分区的最大key值，形成一个 Array[KEY] 类型的数组变量 rangeBounds；第二步：判断 key 在 rangeBounds 中所处的范围，给出该 key 值在下一个 RDD 中的分区id号；该分区器要求 RDD 中的 KEY 类型必须是可以排序的。<br>&emsp;RangePartitioner 的 rangeBounds 按照 key 排序 划分出长度大致相等的几个范围，最终返回 （partitions - 1）个有序的边界值。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">var</span> rangeBounds: <span class="type">Array</span>[<span class="type">K</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (partitions &lt;= <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="type">Array</span>.empty</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// This is the sample size we need to have roughly balanced output partitions, capped at 1M.</span></span><br><span class="line">      <span class="comment">// Cast to double to avoid overflowing ints or longs</span></span><br><span class="line">      <span class="keyword">val</span> sampleSize = math.min(samplePointsPerPartitionHint.toDouble * partitions, <span class="number">1e6</span>)</span><br><span class="line">      <span class="comment">// Assume the input partitions are roughly balanced and over-sample a little bit.</span></span><br><span class="line">      <span class="keyword">val</span> sampleSizePerPartition = math.ceil(<span class="number">3.0</span> * sampleSize / rdd.partitions.length).toInt</span><br><span class="line">      <span class="keyword">val</span> (numItems, sketched) = <span class="type">RangePartitioner</span>.sketch(rdd.map(_._1), sampleSizePerPartition)</span><br><span class="line">      <span class="keyword">if</span> (numItems == <span class="number">0</span>L) &#123;</span><br><span class="line">        <span class="type">Array</span>.empty</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// If a partition contains much more than the average number of items, we re-sample from it</span></span><br><span class="line">        <span class="comment">// to ensure that enough items are collected from that partition.</span></span><br><span class="line">        <span class="keyword">val</span> fraction = math.min(sampleSize / math.max(numItems, <span class="number">1</span>L), <span class="number">1.0</span>)</span><br><span class="line">        <span class="keyword">val</span> candidates = <span class="type">ArrayBuffer</span>.empty[(<span class="type">K</span>, <span class="type">Float</span>)]</span><br><span class="line">        <span class="keyword">val</span> imbalancedPartitions = mutable.<span class="type">Set</span>.empty[<span class="type">Int</span>]</span><br><span class="line">        sketched.foreach &#123; <span class="keyword">case</span> (idx, n, sample) =&gt;</span><br><span class="line">          <span class="keyword">if</span> (fraction * n &gt; sampleSizePerPartition) &#123;</span><br><span class="line">            imbalancedPartitions += idx</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">// The weight is 1 over the sampling probability.</span></span><br><span class="line">            <span class="keyword">val</span> weight = (n.toDouble / sample.length).toFloat</span><br><span class="line">            <span class="keyword">for</span> (key &lt;- sample) &#123;</span><br><span class="line">              candidates += ((key, weight))</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (imbalancedPartitions.nonEmpty) &#123;</span><br><span class="line">          <span class="comment">// Re-sample imbalanced partitions with the desired sampling probability.</span></span><br><span class="line">          <span class="keyword">val</span> imbalanced = <span class="keyword">new</span> <span class="type">PartitionPruningRDD</span>(rdd.map(_._1), imbalancedPartitions.contains)</span><br><span class="line">          <span class="keyword">val</span> seed = byteswap32(-rdd.id - <span class="number">1</span>)</span><br><span class="line">          <span class="keyword">val</span> reSampled = imbalanced.sample(withReplacement = <span class="literal">false</span>, fraction, seed).collect()</span><br><span class="line">          <span class="keyword">val</span> weight = (<span class="number">1.0</span> / fraction).toFloat</span><br><span class="line">          candidates ++= reSampled.map(x =&gt; (x, weight))</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">RangePartitioner</span>.determineBounds(candidates, math.min(partitions, candidates.size))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;分区数量为边界值数量+1<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = rangeBounds.length + <span class="number">1</span></span><br></pre></td></tr></table></figure><br>&emsp;我们再来看一下 getPartition 方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> k = key.asInstanceOf[<span class="type">K</span>]</span><br><span class="line">    <span class="keyword">var</span> partition = <span class="number">0</span></span><br><span class="line">    <span class="keyword">if</span> (rangeBounds.length &lt;= <span class="number">128</span>) &#123;</span><br><span class="line">      <span class="comment">// If we have less than 128 partitions naive search</span></span><br><span class="line">      </span><br><span class="line">      <span class="comment">///如果分区数量少于128，直接遍历</span></span><br><span class="line">      <span class="keyword">while</span> (partition &lt; rangeBounds.length &amp;&amp; ordering.gt(k, rangeBounds(partition))) &#123;</span><br><span class="line">        partition += <span class="number">1</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//否则使用二分查找</span></span><br><span class="line">      <span class="comment">// Determine which binary search method to use only once.</span></span><br><span class="line">      partition = binarySearch(rangeBounds, k)</span><br><span class="line">      <span class="comment">// binarySearch either returns the match location or -[insertion point]-1</span></span><br><span class="line">      <span class="keyword">if</span> (partition &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        partition = -partition<span class="number">-1</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (partition &gt; rangeBounds.length) &#123;</span><br><span class="line">        partition = rangeBounds.length</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ascending) &#123;</span><br><span class="line">      partition</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      rangeBounds.length - partition</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;getPartition 先判断间隔符的个数，如果小于128则直接遍历比较key和分隔符得到 PartitionId，否则使用二分查找，并对边界条件进行了判断，最后根据构造 RangePartitioner 时传入的ascending参数确定是升序或降序返回 PartitionId。</p><h2 id="6-自定义-Partitioner"><a href="#6-自定义-Partitioner" class="headerlink" title="6.自定义 Partitioner"></a>6.自定义 Partitioner</h2><p>&emsp;在 Spark，默认使用 HashPartitioner 对 rdd 进行分区。在有些情况下，可能会产生数据倾斜等情况，这个时候就需要我们自定义分区器。自定义分区器最主要的是重写 numPartitions 、 getPartition 和 equals 方法。<br>&emsp;比如我们想对以以下数据集根据第一个字段分区：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cookieid,createtime,pv</span><br><span class="line">cookie1,2015-04-10,1</span><br><span class="line">cookie1,2015-04-11,5</span><br><span class="line">cookie2,2015-04-10,2</span><br><span class="line">cookie2,2015-04-11,3</span><br><span class="line">.....</span><br></pre></td></tr></table></figure><br>定义分区器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">UDFPartitioner</span>(<span class="params">args: <span class="type">Array</span>[<span class="type">String</span>]</span>) <span class="keyword">extends</span> <span class="title">Partitioner</span> </span>&#123;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> partitionMap: <span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Int</span>] = <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">Int</span>]()</span><br><span class="line">  <span class="keyword">var</span> parId = <span class="number">0</span></span><br><span class="line">  <span class="keyword">for</span> (arg &lt;- args) &#123;</span><br><span class="line">    <span class="keyword">if</span> (!partitionMap.contains(arg)) &#123;</span><br><span class="line">      partitionMap(arg) = parId</span><br><span class="line">      parId += <span class="number">1</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">numPartitions</span></span>: <span class="type">Int</span> = partitionMap.valuesIterator.length</span><br><span class="line"> </span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">getPartition</span></span>(key: <span class="type">Any</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> keys: <span class="type">String</span> = key.asInstanceOf[<span class="type">String</span>]</span><br><span class="line">    <span class="keyword">val</span> sub = keys</span><br><span class="line">    partitionMap(sub)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>测试：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">object</span> <span class="title">UDFPartitionerMain</span> </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(<span class="string">"local[2]"</span>).setAppName(<span class="keyword">this</span>.getClass.getSimpleName)</span><br><span class="line">    <span class="keyword">val</span> ssc = <span class="type">SparkSession</span></span><br><span class="line">      .builder()</span><br><span class="line">      .config(conf)</span><br><span class="line">      .getOrCreate()</span><br><span class="line">    <span class="keyword">val</span> sc = ssc.sparkContext</span><br><span class="line">    sc.setLogLevel(<span class="string">"WARN"</span>)</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">val</span> rdd = ssc.sparkContext.textFile(<span class="string">"file:///E:\\TestFile\\analyfuncdata.txt"</span>)</span><br><span class="line">    <span class="keyword">val</span> transform = rdd.filter(_.split(<span class="string">","</span>).length == <span class="number">3</span>).map(x =&gt; &#123;</span><br><span class="line">      <span class="keyword">val</span> arr = x.split(<span class="string">","</span>)</span><br><span class="line">      (arr(<span class="number">0</span>), (arr(<span class="number">1</span>), arr(<span class="number">2</span>)))</span><br><span class="line">    &#125;)</span><br><span class="line">    <span class="keyword">val</span> keys: <span class="type">Array</span>[<span class="type">String</span>] = transform.map(_._1).collect()</span><br><span class="line">    <span class="keyword">val</span> partiion = transform.partitionBy(<span class="keyword">new</span> <span class="type">UDFPartitioner</span>(keys))</span><br><span class="line">    partiion.foreachPartition(iter =&gt; &#123;</span><br><span class="line">      println(<span class="string">s"**********分区号：<span class="subst">$&#123;TaskContext.getPartitionId()&#125;</span>***************"</span>)</span><br><span class="line">      iter.foreach(r =&gt; &#123;</span><br><span class="line">        println(<span class="string">s"分区:<span class="subst">$&#123;TaskContext.getPartitionId()&#125;</span>###"</span> + r._1 + <span class="string">"\t"</span> + r._2 + <span class="string">"::"</span> + r._2._1)</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;)</span><br><span class="line">    ssc.stop()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-partitioner/">http://zhoujiapeng.top/Spark/spark-partitioner/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark 性能调优</title>
      <link href="/Spark/spark-tuning/"/>
      <url>/Spark/spark-tuning/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-性能调优"><a href="#Spark-性能调优" class="headerlink" title="Spark 性能调优"></a>Spark 性能调优</h1><p>&emsp;Spark 具有”内存计算”的天性，集群中的所有资源：CPU、网络带宽或者内存都会成为 Spark 程序的瓶颈。这里主要讲解两方面的 Sprk 性能优化：数据序列化和内存优化。</p><h2 id="1-数据序列化"><a href="#1-数据序列化" class="headerlink" title="1.数据序列化"></a>1.数据序列化</h2><p>&emsp;序列化对于提高分布式程序的性能起到非常重要的作用。这里的数据序列化指的是网络传输的序列化，并不包含 RDD 的序列化储存（在第2节），数据序列化不但能提高网络性能还能减少内存使用。一个不好的序列化模式的速度非常慢或者序列化结果非常大。会极大降低计算速度。很多情况下，这是我们优化 Spark 应用的第一选择。我们可以通过 spark.serializer 参数来配置序列化模式，Spark 提供了两个序列化库：</p><ul><li><p>Java serialization：这是默认的序列化模式，Spark 采用 Java 的 ObjectOutputStream 序列化一个对象，该方式适用于所有实现了 java.io.Serializable 接口的类。Java 序列化非常灵活，但是速度比较慢，在某些情况下也比较大。</p></li><li><p>Kryo serialization：Kryo 不但速度极快，而且产生的结果更为紧凑。kryo 的缺点是不支持所有类型，为了更好的性能，需要提前注册程序中所使用的类。<br>&emsp;我们可以通过调用 conf.set(“spark.serializer”, “org.apache.spark.serializer.KryoSerializer”) 来设置 Kryo 序列化模式。Kryo 不能成为默认方式的唯一原因是需要用户进行注册。但是，对于任何“网络密集型”（network-intensive）的应用，都建议采用这种方式。</p></li></ul><p>&emsp;下面是注册自定义类型的方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setMaster(...).setAppName(...)</span><br><span class="line">conf.registerKryoClasses(<span class="type">Array</span>(classOf[<span class="type">MyClass1</span>], classOf[<span class="type">MyClass2</span>]))</span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br></pre></td></tr></table></figure><br>&emsp;另外，如果不注册自定义的类，Kryo 仍然可以工作，但是需要为了每一个对象保存其对应的全类名，这是非常浪费的。更多详细介绍可以查看 <a href="https://github.com/EsotericSoftware/kryo" target="_blank" rel="noopener">Kryo 文档</a>。</p><h2 id="2-内存优化"><a href="#2-内存优化" class="headerlink" title="2.内存优化"></a>2.内存优化</h2><p>&emsp;内存优化有三方面的考虑：对象所占用的内存（可能我们希望将所有数据都加载到内存），访问对象的消耗以及内存回收（GC）所占用的开销。<br>&emsp;通常，Java对象的访问速度更快，但其占用的空间通常比其内部的属性数据大2-5倍，主要由于一下几方面原因：</p><ul><li>每一个 Java 对象都包含一个对象头，对象头大约16字节；</li><li>Java String 在实际字符串数据之外，还需要大约40字节的额外开销（String 保存在一个Char数组中，需要额外保存类似长度等其它数据）；同时，因为是 Unicode 编码，一个字符需要占用两个字节，所以，一个长度为10的字符串需要占用60字节；</li><li>通用的集合类，例如 HashMap、LinkedList 等都采用了链表数据结构，每一个条目不仅包含对象头，还包含一个指向下一个条目的指针（通常8字节）；</li><li>基本数据类型（Primitive Type）的集合通常保存为对应的包装类，例如 java.lang.Integer。</li></ul><p>&emsp;下面分析如何估算对象所占用的内存以及如何进行内存优化—-通过改变数据结构或采用序列化。</p><h3 id="2-1-确定内存消耗"><a href="#2-1-确定内存消耗" class="headerlink" title="2.1 确定内存消耗"></a>2.1 确定内存消耗</h3><p>&emsp;确定对象所需内存大小的最好方法是创建一个 RDD，然后将其放入缓存，查看 WebUI 的 Storage 页面，可以看到 RDD 的内存占用情况，或者可以查看 Driver 的日志：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> conf = <span class="keyword">new</span> <span class="type">SparkConf</span>().setAppName(<span class="string">"test"</span>).setMaster(<span class="string">"local"</span>) </span><br><span class="line"><span class="keyword">val</span> sc = <span class="keyword">new</span> <span class="type">SparkContext</span>(conf)</span><br><span class="line">sc.setLogLevel(<span class="string">"info"</span>) <span class="comment">//修改日志级别</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">val</span> value = sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>))</span><br><span class="line">value.cache()</span><br><span class="line">value.count()   <span class="comment">//触发action</span></span><br><span class="line"></span><br><span class="line">sc.stop()</span><br></pre></td></tr></table></figure><br>&emsp;注意，如果是在ide中运行，输出日志级别默认是 warn，需要设置成 info 才能看到内存占用情况，日志信息如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">INFO [dispatcher-event-loop-1] - Added rdd_0_0 in memory on [ip]:41353 (size: 32.0 B, free: 871.8 MB)</span><br></pre></td></tr></table></figure><br>&emsp;表明 rdd_0_0 这个数据块 消耗了32B内存。</p><h3 id="2-2-优化数据结构"><a href="#2-2-优化数据结构" class="headerlink" title="2.2 优化数据结构"></a>2.2 优化数据结构</h3><p>&emsp;减少内存使用的第一个方法是避免使用一些增加额外开销的 Java 特性，例如基于指针的数据结构以对对象进行再包装等：</p><ul><li>使用对象数组以及类型（primitive type）数组代替 Java 或 Scala 集合类（Collection Class）。<a href="http://fastutil.di.unimi.it/" target="_blank" rel="noopener">fastutil</a> 库为原始数据类型提供了非常方便的集合类，且兼容 Java 标准类库；</li><li>尽可能避免采用含有很多小对象和指针的嵌套数据结构；</li><li>考虑采用数字ID或者枚举类型代替 String 类型的主键；</li><li>如果内存小于32G，可以设置 JVM 参数 -XX:+UseCompressedOops 以便将8字节指针修改成4字节。我们可以将这些选项添加到 <a href="http://spark.apache.org/docs/2.4.0/configuration.html#environment-variables" target="_blank" rel="noopener">Spark-env.sh</a> 中。</li></ul><h3 id="2-3-序列化RDD储存"><a href="#2-3-序列化RDD储存" class="headerlink" title="2.3 序列化RDD储存"></a>2.3 序列化RDD储存</h3><p>&emsp;如果经过上述优化，对象还是太大以至于不能有效存放，还有一个减少内存使用的简单方法—-序列化。采用 <a href="http://spark.apache.org/docs/2.4.0/rdd-programming-guide.html#rdd-persistence" target="_blank" rel="noopener">RDD persistence API</a>的序列化储存级别，例如 MEMORY_ONLY_SER，这会将 RDD 的每一个分区都保存为 byte 数组。序列化带来的唯一缺点是会降低访问速度，因为需要将对象反序列化。序列化方式建议采用 <a href="https://github.com/EsotericSoftware/kryo" target="_blank" rel="noopener">Kryo</a>。</p><h3 id="2-4-优化内存回收（GC）"><a href="#2-4-优化内存回收（GC）" class="headerlink" title="2.4 优化内存回收（GC）"></a>2.4 优化内存回收（GC）</h3><p>&emsp;如果 Spark 程序产生大量的 RDD 数据，JVM内存回收就可能成为问题。JVM需要跟踪所有的Java对象以确定哪些对象不再使用。需要注意的一点是：内存回收的代价和对象的数量正相关。因此，使用对象数量更少的数据结构（使用int数组而不是LinkedList）能显著降低这种消耗。<br>&emsp;task　的工作内存和缓存在节点的 RDD 之间会相互影响，这种影响也会带来内存回收问题。下面讨论如何为 RDD 分配空间以便减少这种影响。</p><ol><li><p>估算内存回收的影响<br>&emsp;优化内存回收的第一步是获取一些统计信息，包括内存回收频率、内存回收耗费的时间等。我们可以把参数 -verbose:gc -XX:+PrintGCDetails -XX:+PrintGCTimeStamps 添加到JavaOption　中，详细配置方法可以参考<a href="http://spark.apache.org/docs/2.4.0/configuration.html#Dynamically-Loading-Spark-Properties" target="_blank" rel="noopener">configuration guide</a> 。设置之后，我们可以在日志中看到每一次内存回收的信息。注意，这些日志是保存在集群的 Worker 节点，而不是 Driver。</p></li><li><p>优化缓存大小<br>&emsp;用多大的内存来缓存RDD是内存回收一个非常重要的配置参数，默认情况下，Spark采用运行内存(spark.executor.memory)60%的空间来进行RDD缓存。这表明，在 task 运行期间，有40%的内存可以用来进行对象创建。<br>&emsp;如果task运行速度变慢且JVM频繁进行内存回收，或者内存空间不足，那么降低缓存大小设置减少内存消耗，提高可用的运行内存大小。缓存占用大小比例可以通过参数 spark.storage.memoryFraction 来设置。结合序列化缓存，使用较小缓存足够解决内存回收大部分问题。</p></li><li><p>内存回收高级优化</p></li></ol><p>&emsp;为了进一步优化内存回收，我们需要了解JVM内存管理的一些基本知识。</p><ul><li>(1) Java堆空间分为两部分，新生代和老年代，新生代用于保存生命周期较短的对象，老年代用于保存生命周期较长的对象；</li><li>(2) 新生代进一步分为三部分：一块较大的 Eden 空间和两块较小的 Survivor 空间，Eden 空间和 Survivor 空间默认是8:1；</li><li>(3) 内存回收过程可以简要描述为：每次使用 Eden 和其中一块 Survivor 空间。如果 Eden 空间满则执行 minor GC(新生代GC),然后将当前 Eden 和 Survivor 空间中存活的对象复制到另外一块 Survivor 空间中。但 Survivor 空间不够用时，那么会将存活对象复制到老年代空间中。最终。如果老年代空间也不够用时，则执行 full GC。</li></ul><p>&nbsp;<br>&emsp;Spark 内存回收优化的目标是确保只有长时间存活的RDD才能保存到老年代区域，同时，新生代区域足够大以保存生命周期较短的对象。这样，在任务执行期间可以避免执行full GC。下面是几个有用的步骤：</p><ul><li>(1) 收集GC信息检查内存回收是否太过频繁。如果在任务结束之前执行了很多次 full GC，则说明任务执行的内存空间不足；</li><li>(2) 如果发现老年代消耗殆尽，那么可以减少用于缓存的内存空间，通过配置 spark.storage.memoryFraction 参数。通过减少缓存对象来提高执行速度是非常值得的；</li><li>(3) 如果有过多的 minor GC 而不是 full GC，那么可以为 Eden 空间分配更大的内存。可以为 Eden 分配大于 task 执行所需要的内存空间。如果 Eden 的大小为E，那么可以通过参数 -Xmn=4/3*E 来设置新生代的大小。（4/3是考虑到 survivor 所需要的空间）；</li><li>(4) 尝试使用 G1 垃圾回收器，通过配置 -XX:+UseG1GC 参数完成。当垃圾回收是瓶颈的时候，在有些情况下 G1 垃圾回收器能够提高性能。注意，如果 Executors 需要大堆内存时，需要设置 -XX:G1HeapRegionSize 参数来提高 G1 的 region 大小；</li><li>(5) 举一个例子，如果任务从 HDFS 读取数据，那么任务需要的内存空间可以从读取的 block 数量估算出来。解压后的 block 通常是解压前的2-3倍，所以，当我们需要同时执行3个或4个任务，block 的大小为64M，那么 Eden 的大小为 4<em>3</em>64M。</li></ul><h2 id="3-其他优化方法"><a href="#3-其他优化方法" class="headerlink" title="3.其他优化方法"></a>3.其他优化方法</h2><h3 id="3-1-并行度"><a href="#3-1-并行度" class="headerlink" title="3.1 并行度"></a>3.1 并行度</h3><p>&emsp;我们需要为每一个操作都设置足够高的并行度，才能有效利用集群资源。通常来讲，在集群中，建议为每一个CPU核分配2-3个task。</p><h3 id="3-2-Reduce-Task的内存使用"><a href="#3-2-Reduce-Task的内存使用" class="headerlink" title="3.2 Reduce Task的内存使用"></a>3.2 Reduce Task的内存使用</h3><p>&emsp;有时候我们会碰到 OutOfMemoryError 错误，这不是因为我们的 RDD 不能加载到内存，而是因为 task 执行需要的数据集过大，例如 执行 groupByKey 操作的 reduce task。Spark 的 shuffle 操作（比如sortByKey, groupByKey, reduceByKey, join, etc），为了完成分组需要为每一个 task 创建 hash 表，这个 hash 表可能非常大。最简单的方法就是增加并行度，这样对于每一个 task 的输入会变得更小。Spark 能够非常有效地支持短时间任务（例如200ms），因为它能够在很多个 task 之间复用 Executor JVM，这样能够减少 task 的启动消耗。所以，我们能够放心地使任务的并行度大于集群的CPU核数。</p><h3 id="3-3-广播-“大变量”"><a href="#3-3-广播-“大变量”" class="headerlink" title="3.3 广播 “大变量”"></a>3.3 广播 “大变量”</h3><p>&emsp;广播变量允许用户保留一个只读的变量，缓存在每一台机器上，而不用在任务（Task）之间传递变量。详细介绍可以参考文章<a href="http://zhoujiapeng.top/Spark/spark-share-variable/">《Spark 共享变量》</a>。广播变量可以有效减少每一个 task 的大小，以及在集群中启动作业的消耗。如果 task 需要用到 driver 端程序中比较大的对象（例如静态查找表），可以考虑将其变成广播变量。Spark 会在 master 打印每一个 task 序列化后的大小，我们可以通过它来检查任务是否过于庞大。通常来说，超过20KB的任务都是值得优化的。</p><h3 id="3-4-数据本地性"><a href="#3-4-数据本地性" class="headerlink" title="3.4 数据本地性"></a>3.4 数据本地性</h3><p>&emsp;数据本地性对于 Spark 任务执行的性能有显著的影响。如果数据和操作的代码都在同一个节点的话，计算会非常块。但是如果数据和代码是分离的，那么必须有一方必须移动到另外一方。通常来讲，传输序列化后的代码肯定比传输数据要快得多。Spark在此原则上建立数据本地性的调度策略，简单来说，就是尽可能将 task 分配到拥有所需要数据的节点上。<br>&emsp;数据本地性的原理在这里不多加介绍，详细介绍可以关注我后续会编写的文章《Spark 任务调度 之 数据本地性》。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>&emsp;最后总结一下 Spark 程序优化需要关注的几个关键点—-最主要的是数据序列化和内存优化。对于大多数情况而言，采用 Kryo 序列化能够解决性能有关的大部分问题。</p><blockquote><p>参考： <a href="http://spark.apache.org/docs/2.4.0/tuning.html" target="_blank" rel="noopener">http://spark.apache.org/docs/2.4.0/tuning.html</a></p></blockquote><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-tuning/">http://zhoujiapeng.top/Spark/spark-tuning/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark源码阅读 之 共享变量</title>
      <link href="/Spark/spark-share-variable/"/>
      <url>/Spark/spark-share-variable/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-共享变量"><a href="#Spark-共享变量" class="headerlink" title="Spark 共享变量"></a>Spark 共享变量</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><p>&emsp;Spark一个非常重要的特性就是共享变量。通常情况下，传递给 Spark 操作（例如 map 或 reduce）的函数是在远程集群节点上执行的，函数中使用的变量，在多个节点上执行时是同一变量的多个副本。这些变量被拷贝到每台机器上，并且在远程机器上对变量的更新不会回传给驱动程序。在任务之间支持通用的，可读写的共享变量是效率是非常低的。<br>&emsp;Spark 提供了两种类型的共享变量 : 广播变量（broadcast variables）和 累加器（accumulators）。Broadcast Variable会将使用到的变量，仅仅为每个节点拷贝一份，更大的用处是优化性能，减少网络传输以及内存消耗。Accumulator则可以让多个task共同操作一份变量，主要可以进行累加操作。</p><h2 id="1-广播变量"><a href="#1-广播变量" class="headerlink" title="1. 广播变量"></a>1. 广播变量</h2><p>&emsp;广播变量允许用户保留一个只读的<strong>变量</strong>，缓存在每一台机器上，而不用在任务（Task）之间传递变量。广播变量可以被用于有效地给<strong>每个节点</strong>一个大输入数据集的副本而<strong>非每个任务</strong>保存一份复制。同时 Spark 采用 <strong>P2P</strong> 的方式来传播广播变量，从而减少通信开销。<br>&emsp;广播变量的实例对象的 value 值不能在广播后被修改，这样可以保证所有节点收到的都是一样的广播值。<br>&emsp;广播变量通常使用方式包括共享配置文件、map数据集、树形数据结构等，为能够更好更快速为 Task 使用相关变量。<br>&emsp;接下来从三个方面解析广播变量：初始化、创建（写入）、使用（读取）。</p><h3 id="1-1-初始化"><a href="#1-1-初始化" class="headerlink" title="1.1 初始化"></a>1.1 初始化</h3><p>&emsp;SparkEnv 中会有一个 BroadcastManager 对象被创建：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SparkEnv</span></span><br><span class="line"><span class="keyword">val</span> broadcastManager = <span class="keyword">new</span> <span class="type">BroadcastManager</span>(isDriver, conf, securityManager)</span><br></pre></td></tr></table></figure><br>&emsp;BroadcastManager 的初始化函数 initialize 中会创建一个 broadcastFactory，factory 负责创建我们所需要的 Broadcast 对象。BroadcastFactory 是一个 trait，但是在 Spark 2.4.0 版本中，BroadcastFactory 只有一种实现(1.X版本中有 HttpBroadcastFactory 方式)，也就是 BroadcastManager 中创建的 broadcastFactory 类型 —- TorrentBroadcastFactory。TorrentBroadcastFactory 使用类似于 BitTorrent 的协议（P2P方式）在 Executors 之间传输和广播变量。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BroadcastManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>() &#123;</span><br><span class="line">    synchronized &#123;</span><br><span class="line">      <span class="keyword">if</span> (!initialized) &#123;</span><br><span class="line">        broadcastFactory = <span class="keyword">new</span> <span class="type">TorrentBroadcastFactory</span></span><br><span class="line">        broadcastFactory.initialize(isDriver, conf, securityManager)</span><br><span class="line">        initialized = <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;调用 SparkContext.broadcast(value) 可以创建一个 Broadcast 实例，它的值可以通过调用 Broadcast 实例的 value() 方法获得。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SparkContext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">broadcast</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](value: <span class="type">T</span>): <span class="type">Broadcast</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">    assertNotStopped()</span><br><span class="line">    require(!classOf[<span class="type">RDD</span>[_]].isAssignableFrom(classTag[<span class="type">T</span>].runtimeClass),</span><br><span class="line">      <span class="string">"Can not directly broadcast RDDs; instead, call collect() and broadcast the result."</span>)</span><br><span class="line">    <span class="keyword">val</span> bc = env.broadcastManager.newBroadcast[<span class="type">T</span>](value, isLocal)</span><br><span class="line">    <span class="keyword">val</span> callSite = getCallSite</span><br><span class="line">    logInfo(<span class="string">"Created broadcast "</span> + bc.id + <span class="string">" from "</span> + callSite.shortForm)</span><br><span class="line">    cleaner.foreach(_.registerBroadcastForCleanup(bc))</span><br><span class="line">    bc</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里调用 env.broadcastManager 的 newBroadcast 方法来创建一个新的 Broadcast 对象，env 里面的 broadcastManager 是 TorrentBroadcastFactory，所以创建的是 TorrentBroadcast。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TorrentBroadcastFactory</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">newBroadcast</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](value_ : <span class="type">T</span>, isLocal: <span class="type">Boolean</span>, id: <span class="type">Long</span>): <span class="type">Broadcast</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">TorrentBroadcast</span>[<span class="type">T</span>](value_, id)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;在 TorrentBroadcast 的初始化过程中，会调用 setConf() 方法将 SparkConf 对象注入到 TorrentBroadcast 中，setConf() 方法里面会设置压缩方式。并调用 writeBlocks() 方法将数据切分储存。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TorrentBroadcast</span></span><br><span class="line">setConf(<span class="type">SparkEnv</span>.get.conf)</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Total number of blocks this broadcast variable contains. */</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> numBlocks: <span class="type">Int</span> = writeBlocks(obj)</span><br></pre></td></tr></table></figure></p><h3 id="1-2-创建（写入）"><a href="#1-2-创建（写入）" class="headerlink" title="1.2 创建（写入）"></a>1.2 创建（写入）</h3><p>&emsp;上面讲到 TorrentBroadcast 实例创建过程，会调用 writeBlocks 方法，这个方法的主要功能是按照定义的广播块大小切分数据，切分块大小默认是4M（spark.broadcast.blockSize），在 setConf 方法中被设置。然后调用 blockManager 将切分后的数据信息储存到磁盘中。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TorrentBroadcast</span></span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Divide the object into multiple blocks and put those blocks in the block manager.</span></span><br><span class="line"><span class="comment">   *</span></span><br><span class="line"><span class="comment">   * @param value the object to divide</span></span><br><span class="line"><span class="comment">   * @return number of blocks this broadcast variable is divided into</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">writeBlocks</span></span>(value: <span class="type">T</span>): <span class="type">Int</span> = &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">StorageLevel</span>._</span><br><span class="line">    <span class="comment">// Store a copy of the broadcast variable in the driver so that tasks run on the driver</span></span><br><span class="line">    <span class="comment">// do not create a duplicate copy of the broadcast variable's value.</span></span><br><span class="line">    <span class="keyword">val</span> blockManager = <span class="type">SparkEnv</span>.get.blockManager</span><br><span class="line"></span><br><span class="line">    <span class="comment">//持久化广播对象，blockid是broadcastId</span></span><br><span class="line">    <span class="keyword">if</span> (!blockManager.putSingle(broadcastId, value, <span class="type">MEMORY_AND_DISK</span>, tellMaster = <span class="literal">false</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s"Failed to store <span class="subst">$broadcastId</span> in BlockManager"</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//切分成块</span></span><br><span class="line">    <span class="keyword">val</span> blocks =</span><br><span class="line">      <span class="type">TorrentBroadcast</span>.blockifyObject(value, blockSize, <span class="type">SparkEnv</span>.get.serializer, compressionCodec)</span><br><span class="line">    <span class="keyword">if</span> (checksumEnabled) &#123;</span><br><span class="line">      checksums = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">Int</span>](blocks.length)</span><br><span class="line">    &#125;</span><br><span class="line">    blocks.zipWithIndex.foreach &#123; <span class="keyword">case</span> (block, i) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (checksumEnabled) &#123;</span><br><span class="line">        checksums(i) = calcChecksum(block)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="comment">//序列化方式储存每个切分块，blockid是pieceId</span></span><br><span class="line">      <span class="keyword">val</span> pieceId = <span class="type">BroadcastBlockId</span>(id, <span class="string">"piece"</span> + i)</span><br><span class="line">      <span class="keyword">val</span> bytes = <span class="keyword">new</span> <span class="type">ChunkedByteBuffer</span>(block.duplicate())</span><br><span class="line">      <span class="keyword">if</span> (!blockManager.putBytes(pieceId, bytes, <span class="type">MEMORY_AND_DISK_SER</span>, tellMaster = <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s"Failed to store <span class="subst">$pieceId</span> of <span class="subst">$broadcastId</span> in local BlockManager"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    blocks.length</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;writeBlocks 在储存切分的广播块之前需要先调用 blockManager.putSingle 将广播变量以非序列化方式持久化，然后再将广播变量切分成块，调用 putBytes 将切分好的块以<strong>序列化</strong>的方式储存。putBytes 根据储存策略会优先写入本地，既然序列化数据是本地储存，由此而来的问题是读取问题，BlockManager 储存数据不会像 HDFS 依据备份策略储存多份数据放置不同节点，如果没有备份数据，那么必然产生数个问题：</p><ul><li>节点故障，无法访问节点数据；</li><li>数据热点，所有任务都会使用该数据；</li><li>网络传输，所有节点频繁访问单节点；</li></ul><h3 id="1-3-使用（读取）"><a href="#1-3-使用（读取）" class="headerlink" title="1.3 使用（读取）"></a>1.3 使用（读取）</h3><p>&emsp;为了解决广播变量读取的问题，Spark 采用 P2P 点对点方式，只要使用过广播变量数据，则在本节点储存数据，由此变成新的数据源，随着数据源不断增加，传输数据的速度也会越来越快。广播变量的值通过调用 Broadcast.value 来获取：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Broadcast</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: <span class="type">T</span> = &#123;</span><br><span class="line">    assertValid()</span><br><span class="line">    getValue()</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">//TorrentBroadcast</span></span><br><span class="line"><span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">getValue</span></span>() = &#123;</span><br><span class="line">    _value</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">@transient</span> <span class="keyword">private</span> <span class="keyword">lazy</span> <span class="keyword">val</span> _value: <span class="type">T</span> = readBroadcastBlock()</span><br></pre></td></tr></table></figure></p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TorrentBroadcast</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">readBroadcastBlock</span></span>(): <span class="type">T</span> = <span class="type">Utils</span>.tryOrIOException &#123;</span><br><span class="line">    <span class="type">TorrentBroadcast</span>.synchronized &#123;</span><br><span class="line">      <span class="keyword">val</span> broadcastCache = <span class="type">SparkEnv</span>.get.broadcastManager.cachedValues</span><br><span class="line"></span><br><span class="line">      <span class="type">Option</span>(broadcastCache.get(broadcastId)).map(_.asInstanceOf[<span class="type">T</span>]).getOrElse &#123;</span><br><span class="line">        setConf(<span class="type">SparkEnv</span>.get.conf)</span><br><span class="line">        <span class="keyword">val</span> blockManager = <span class="type">SparkEnv</span>.get.blockManager</span><br><span class="line"></span><br><span class="line">        <span class="comment">//尝试从本地读取</span></span><br><span class="line">        blockManager.getLocalValues(broadcastId) <span class="keyword">match</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> <span class="type">Some</span>(blockResult) =&gt;</span><br><span class="line">            <span class="keyword">if</span> (blockResult.data.hasNext) &#123;</span><br><span class="line">              ...</span><br><span class="line">          <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">            logInfo(<span class="string">"Started reading broadcast variable "</span> + id)</span><br><span class="line">            <span class="keyword">val</span> startTimeMs = <span class="type">System</span>.currentTimeMillis()</span><br><span class="line"></span><br><span class="line">            <span class="comment">//从其它节点获取</span></span><br><span class="line">            <span class="keyword">val</span> blocks = readBlocks()</span><br><span class="line">            logInfo(<span class="string">"Reading broadcast variable "</span> + id + <span class="string">" took"</span> + <span class="type">Utils</span>.getUsedTimeMs(startTimeMs))</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              ...</span><br><span class="line">              <span class="keyword">val</span> storageLevel = <span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK</span></span><br><span class="line"></span><br><span class="line">              <span class="comment">//储存到本地，并汇报给 master</span></span><br><span class="line">              <span class="keyword">if</span> (!blockManager.putSingle(broadcastId, obj, storageLevel, tellMaster = <span class="literal">false</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s"Failed to store <span class="subst">$broadcastId</span> in BlockManager"</span>)</span><br><span class="line">              &#125;</span><br><span class="line"></span><br><span class="line">              ...</span><br><span class="line">              blocks.foreach(_.dispose())</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;readBlocks 方法会尝试从其它节点获取广播块：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//TorrentBroadcast</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">readBlocks</span></span>(): <span class="type">Array</span>[<span class="type">BlockData</span>] = &#123;</span><br><span class="line">    <span class="comment">// Fetch chunks of data. Note that all these chunks are stored in the BlockManager and reported</span></span><br><span class="line">    <span class="comment">// to the driver, so other executors can pull these chunks from this executor as well.</span></span><br><span class="line">    <span class="keyword">val</span> blocks = <span class="keyword">new</span> <span class="type">Array</span>[<span class="type">BlockData</span>](numBlocks)</span><br><span class="line">    <span class="keyword">val</span> bm = <span class="type">SparkEnv</span>.get.blockManager</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环遍历所有块，避免访问热点，随即顺序读取数据</span></span><br><span class="line">    <span class="keyword">for</span> (pid &lt;- <span class="type">Random</span>.shuffle(<span class="type">Seq</span>.range(<span class="number">0</span>, numBlocks))) &#123;</span><br><span class="line">      <span class="keyword">val</span> pieceId = <span class="type">BroadcastBlockId</span>(id, <span class="string">"piece"</span> + pid)</span><br><span class="line">      logDebug(<span class="string">s"Reading piece <span class="subst">$pieceId</span> of <span class="subst">$broadcastId</span>"</span>)</span><br><span class="line">      <span class="comment">// First try getLocalBytes because there is a chance that previous attempts to fetch the</span></span><br><span class="line">      <span class="comment">// broadcast blocks have already fetched some of the blocks. In that case, some blocks</span></span><br><span class="line">      <span class="comment">// would be available locally (on this executor).</span></span><br><span class="line">      bm.getLocalBytes(pieceId) <span class="keyword">match</span> &#123;   <span class="comment">//获取本地数据成功</span></span><br><span class="line">        <span class="keyword">case</span> <span class="type">Some</span>(block) =&gt;</span><br><span class="line">          blocks(pid) = block</span><br><span class="line">          releaseLock(pieceId)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">None</span> =&gt;                    </span><br><span class="line">          bm.getRemoteBytes(pieceId) <span class="keyword">match</span> &#123;  </span><br><span class="line">            <span class="keyword">case</span> <span class="type">Some</span>(b) =&gt;</span><br><span class="line">              <span class="keyword">if</span> (checksumEnabled) &#123;</span><br><span class="line">                <span class="keyword">val</span> sum = calcChecksum(b.chunks(<span class="number">0</span>))</span><br><span class="line">                <span class="keyword">if</span> (sum != checksums(pid)) &#123;</span><br><span class="line">                  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s"corrupt remote block <span class="subst">$pieceId</span> of <span class="subst">$broadcastId</span>:"</span> +</span><br><span class="line">                    <span class="string">s" <span class="subst">$sum</span> != <span class="subst">$&#123;checksums(pid)&#125;</span>"</span>)</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              <span class="comment">// We found the block from remote executors/driver's BlockManager, so put the block</span></span><br><span class="line">              <span class="comment">// in this executor's BlockManager.</span></span><br><span class="line">              </span><br><span class="line">              <span class="comment">//储存到本地，并汇报Master</span></span><br><span class="line">              <span class="keyword">if</span> (!bm.putBytes(pieceId, b, <span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK_SER</span>, tellMaster = <span class="literal">true</span>)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(</span><br><span class="line">                  <span class="string">s"Failed to store <span class="subst">$pieceId</span> of <span class="subst">$broadcastId</span> in local BlockManager"</span>)</span><br><span class="line">              &#125;</span><br><span class="line">              blocks(pid) = <span class="keyword">new</span> <span class="type">ByteBufferBlockData</span>(b, <span class="literal">true</span>)</span><br><span class="line">            <span class="keyword">case</span> <span class="type">None</span> =&gt;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">s"Failed to get <span class="subst">$pieceId</span> of <span class="subst">$broadcastId</span>"</span>)</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    blocks</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;在 readBlocks 方法中，为了避免访问热点，会以随机顺序读取数据。读取某个块的时候，会先再一次尝试从本地读取，这是因为在上一次获取的时候可能已经成功获取到某些块。如果这一次还是无法从本地获取到数据，则调用 getRemoteBytes 从其它节点获取，getRemoteBytes 方法在<a href="http://zhoujiapeng.top/Spark/spark-storage/#532-get-1">《Spark储存体系》</a>文章中已经介绍过了，这里不再赘述。</p><h3 id="1-4-广播变量总结"><a href="#1-4-广播变量总结" class="headerlink" title="1.4 广播变量总结"></a>1.4 广播变量总结</h3><p>&emsp;到这里我们知道，TorrentBroadcast 首先将广播变量数据分块，并存到 BlockManager 中；每个节点需要读取广播变量时，是分块读取，对每一块都读取其位置信息，然后选择其中一个存有此块的节点进行读取；每个节点读取后会将包含的广播块信息报告给 mBlockadeanagerMaster，这样本地节点就成了这个广播网络中的一个 peer。</p><h3 id="1-5-一个特殊例子"><a href="#1-5-一个特殊例子" class="headerlink" title="1.5 一个特殊例子"></a>1.5 一个特殊例子</h3><p>&emsp;广播变量有时候可以用来解决由于数据切片造成的程序逻辑错误问题。<br>&emsp;举例来说，有两个表，ip规则表和日志表，ip规则表记录了ip和省份的映射关系，日志表记录了页面访问地址以及访问ip，现在需要使用这两个表进行匹配聚合，统计出各个省份的访问ip总数量，两个表的数据都是储存在HDFS中的。数据示例如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;访问日志示例</span><br><span class="line">20090121000132095572000|125.213.100.123|show.51.com|&#x2F;shoplist.php?phpfile&#x3D;shoplist2.php&amp;style&#x3D;1&amp;sex&#x3D;137|Mozilla&#x2F;4.0 (compatible; MSIE 6.0; Windows NT 5.1; SV1; Mozilla&#x2F;4.0(Compatible Mozilla&#x2F;4.0(Compatible-EmbeddedWB 14.59 http:&#x2F;&#x2F;bsalsa.com&#x2F; EmbeddedWB- 14.59  from: http:&#x2F;&#x2F;bsalsa.com&#x2F; )|http:&#x2F;&#x2F;show.51.com&#x2F;main.php|</span><br></pre></td></tr></table></figure><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;&#x2F;ip规则表示例，数据按照ip有序存放</span><br><span class="line">1.0.1.0|1.0.3.255|16777472|16778239|亚洲|中国|福建|福州||电信|350100|China|CN|119.306239|26.075302</span><br></pre></td></tr></table></figure><br>&emsp;稍微不注意的话，或许我们会这么做，从HDFS中将数据读取到 ipRulesRDD、和 logRDD 之后，遍历 logRDD，逐一使用二分法去比对 ipRulesRDD，通过这种方式查找出每一条日志记录中ip对应的省份。但是这种做法是错误的，这里忽略了一个问题，如果数据是存放在 HDFS 的话，那么读取数据的时候日志表和<strong>ip规则表都会被分区</strong>，每个 Executor 节点都只能读取到部分的ip规则表而不是完整的ip规则表，因此 Executor 在查找ip规则表的时候，就只能使用本地获取到的那部分ip规则表进行比对，这样势必会造成某些ip无法查找到对应的省份。<br>&emsp;为了解决这个问题，我们需要让每一个 Executor 节点都拥有完整的ip规则表，这时候广播变量就发挥作用了。我们可以先调用 RDD.collect 方法将完整的数据收集到 Driver 端，然后再调用 sc.broadcast 将数据ip规则表广播到所有的 Executor 节点上，这样的话，每一个 Executor 都能够持有一个完整的ip规则表的数据副本。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//从hdfs读取ip规则数据</span></span><br><span class="line"><span class="keyword">val</span> rulesLines = sc.textFile(args(<span class="number">0</span>))</span><br><span class="line"><span class="comment">//整理ip规则数据</span></span><br><span class="line"><span class="comment">//整理ip规则数据</span></span><br><span class="line"><span class="keyword">val</span> ipRulesRDD: <span class="type">RDD</span>[(<span class="type">Long</span>, <span class="type">Long</span>, <span class="type">String</span>)] = rulesLines.map(line =&gt; &#123;</span><br><span class="line">  <span class="keyword">val</span> fields = line.split(<span class="string">"[|]"</span>)</span><br><span class="line">  <span class="keyword">val</span> startNum = fields(<span class="number">2</span>).toLong</span><br><span class="line">  <span class="keyword">val</span> endNum = fields(<span class="number">3</span>).toLong</span><br><span class="line">  <span class="keyword">val</span> province = fields(<span class="number">6</span>)</span><br><span class="line">  (startNum, endNum, province)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//从各个executor收集ip规则到driver端</span></span><br><span class="line"><span class="keyword">val</span> rulesInDriver : <span class="type">Array</span>[(<span class="type">Long</span>,<span class="type">Long</span>,<span class="type">String</span>)] = ipRulesRDD.collect()</span><br><span class="line"><span class="comment">//从driver端广播ip规则到各个executor</span></span><br><span class="line"><span class="keyword">val</span> broadcastRef = sc.broadcast(rulesInDriver)</span><br></pre></td></tr></table></figure></p><h2 id="2-累加器"><a href="#2-累加器" class="headerlink" title="2. 累加器"></a>2. 累加器</h2><p>&emsp;累加器是一种只能通过关联操作进行“加”操作的变量，因此它能够高效的应用于并行操作中。它们能够用来实现计数器和求和器。Spark原生支持Int和Double类型的累加器，开发者可以自己添加支持的类型。运行在集群上的任务可以给累加器增加值，但是它们不能读取这个值，<strong>只有驱动程序（Driver端程序）可以使用 Accumulators 对象的 value 方法来读取累加器的值</strong>。<br>&emsp;我们可以创建命名或未命名的累加器。命名累加器会在 Web UI(4040端口) 中展示。Spark在Tasks 任务表中显示由任务修改的每个累加器的值。比如创建一个 longAccumulator 类型的累加器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> longAccumulator = sc.longAccumulator(<span class="string">"long-account"</span>)</span><br><span class="line">sc.parallelize(<span class="type">Array</span>(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>)).foreach(x =&gt; longAccumulator.add(x))</span><br></pre></td></tr></table></figure><br>&emsp;在 WebUI 中可以看到：<br><img src="https://gitee.com/JP6907/Pic/raw/master/spark/accumulators.png?raw=true" alt="accumulators"><br>&emsp;跟踪 WebUI 中的累加器对于理解运行的 stage　的进度很有用。&nbsp;<br>&emsp;下面我们来看一下累加器的实现，以 longAccumulator 为例，当调用 sc.longAccumulator 的时候：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SparkContext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">longAccumulator</span></span>(name: <span class="type">String</span>): <span class="type">LongAccumulator</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> acc = <span class="keyword">new</span> <span class="type">LongAccumulator</span></span><br><span class="line">    register(acc, name)</span><br><span class="line">    acc</span><br><span class="line">  &#125;</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span></span>(acc: <span class="type">AccumulatorV2</span>[_, _], name: <span class="type">String</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    acc.register(<span class="keyword">this</span>, name = <span class="type">Option</span>(name))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//AccumulatorV2</span></span><br><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">register</span></span>(</span><br><span class="line">      sc: <span class="type">SparkContext</span>,</span><br><span class="line">      name: <span class="type">Option</span>[<span class="type">String</span>] = <span class="type">None</span>,</span><br><span class="line">      countFailedValues: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.metadata != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"Cannot register an Accumulator twice."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.metadata = <span class="type">AccumulatorMetadata</span>(<span class="type">AccumulatorContext</span>.newId(), name, countFailedValues)</span><br><span class="line">    <span class="type">AccumulatorContext</span>.register(<span class="keyword">this</span>)</span><br><span class="line">    sc.cleaner.foreach(_.registerAccumulatorForCleanup(<span class="keyword">this</span>))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;最后会调用 AccumulatorV2 的 register 方法，可以看到，这个方法里面将累加器注册到了 AccumulatorContext 里面：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//AccumulatorContext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">register</span></span>(a: <span class="type">AccumulatorV2</span>[_, _]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    originals.putIfAbsent(a.id, <span class="keyword">new</span> jl.ref.<span class="type">WeakReference</span>[<span class="type">AccumulatorV2</span>[_, _]](a))</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> originals = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>[<span class="type">Long</span>, jl.ref.<span class="type">WeakReference</span>[<span class="type">AccumulatorV2</span>[_, _]]]</span><br></pre></td></tr></table></figure><br>&emsp;在 AccumulatorContext 中注册累加器其实就是将累加器添加到 originals 中，originals 是一个 HashMap。因此，Driver 端是通过 AccumulatorContext 里面的一个 HashMap 变量来维护所有的累加器。<br>&emsp;当调用累加器的 value 方法时，直接返回累加器的和：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//LongAccumulator</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">value</span></span>: jl.<span class="type">Long</span> = _sum</span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">add</span></span>(v: jl.<span class="type">Long</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    _sum += v</span><br><span class="line">    _count += <span class="number">1</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-share-variable/">http://zhoujiapeng.top/Spark/spark-share-variable/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark源码阅读 之 Storage储存模块</title>
      <link href="/Spark/spark-storage/"/>
      <url>/Spark/spark-storage/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark储存体系"><a href="#Spark储存体系" class="headerlink" title="Spark储存体系"></a>Spark储存体系</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><h2 id="1-储存体系架构"><a href="#1-储存体系架构" class="headerlink" title="1.储存体系架构"></a>1.储存体系架构</h2><p>&emsp;简单来说，Spark 储存体系是各个 Driver 和 Executor 实例中的 BlockManager 所组成的，但从一个整体上看，Spark 储存体系包含很多组件，如图所示。<br><img src="https://gitee.com/JP6907/Pic/raw/master/spark/storage-architecture.png" alt="storage-architecture"></p><ul><li><p>BlockManagerMaster：代理 BlockManager 与 Driver 上的 BlockManagerMasterEndpoint 通信。图中记号1表示 Executor 节点上的 BlockManager 通过 BlockManagerMaster 与 BlockManagerMasterEndpoint 进行通信，记号2表示 Driver 节点上的 BlockManager 通过 BlockManagerMaster 与 BlockManagerMasterEndpoint 进行通信。</p></li><li><p>BlockManagerMasterEndpoint：由 Driver 上的 SparkEnv 负责创建和注册到 Driver 的 RpcEnv 中。<strong>BlockManagerMasterEndpoint 只存在 Driver 的 SparkEnv 中</strong>，Driver 或 Executor 上的 BlockManagerMaster 的 driverEndpoint 持有 BlockManagerMasterEndpoint 的 <strong>RpcEndPointRef</strong>。BlockManagerMasterEndpoint 主要对各个节点上的 BlockManager、BlockManager 与 Executor 的映射关系及 Block 位置信息等进行管理。</p></li><li><p>BlockManagerSlaveEndpoint：每个 Executor 或 Driver 的 SparkEnv 中的 BlockManager 都会有创建并注册属于自己的 slaveEndpoint。BlockManagerSlaveEndpoint 将接收 BlockManagerMasterEndpoint 下发的命令。图中记号3和4分别表示 BlockManagerMasterEndpoint 向 Driver节点 和 Executor节点上的 BlockManagerSlaveEndpoint 下发命令。</p></li><li><p>SerializerManager：序列化管理器。</p></li><li><p>MemoryManager：内存管理器，负责对单个节点上内存的分配与回收。</p></li><li><p>MapOutputTracker：map任务输出跟踪器。</p></li><li><p>ShuffleManager：Shuffle管理器。</p></li><li><p>BlockTransferService：块传输服务。</p></li><li><p>shuffleClient：Shuffle的客户端，与 BlockTransferService 配合使用。</p></li><li><p>SecurityManager：安全管理器。</p></li><li><p>DiskBlockManager：磁盘管理器，对磁盘上的文件及目录的读写操作进行管理。</p></li><li><p>BlockInfoManager：块信息管理器，负责Block的元数据及锁资源进行管理。</p></li><li><p>MemoryStore：内存储存。依赖于MemoryManager，负责对Block的内存储存。</p></li><li><p>DiskStore：磁盘储存。依赖于DiskBlockManager，负责对Block的磁盘储存。</p></li></ul><h2 id="2-BlockManagerMaster对BlockManager的管理"><a href="#2-BlockManagerMaster对BlockManager的管理" class="headerlink" title="2.BlockManagerMaster对BlockManager的管理"></a>2.BlockManagerMaster对BlockManager的管理</h2><p>&emsp;BlockManagerMaster 的作用是对存在于 Executor 或 Driver 上的 BlockManager 进行统一管理。Executor 与 Driver 关于 BlockManager 的交互都依赖于 BlockManagerMaster。Driver 上的 BlockManagerMaster 会实例化并注册 BlockManagerMasterEndpoint。无论是 Driver 还是 Executor，它们的 BlockManagerMaster 的 driverEndpoint 属性都持有 BlockManagerMasterEndpoint 的 RpcEndpointRef。无论是 Driver 还是 Executor，每个 BlockManager 都拥有自己的 BlockManagerSlaveEndpoint 的 RpcEndpointRef。<br>&emsp;BlockManagerMaster 负责发送消息，BlockManagerMasterEndpoint 负责消息的接收与处理。BlockManagerSlaveEndpoint 则接收 BlockManagerMasterEndpoint 下发的命令。</p><h2 id="3-BlockManager的创建"><a href="#3-BlockManager的创建" class="headerlink" title="3.BlockManager的创建"></a>3.BlockManager的创建</h2><p>&emsp;BlockManager 在 SparkEnv 类的 create 方法中被创建：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SparkEnv</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">create</span></span>(</span><br><span class="line">      ... ): <span class="type">SparkEnv</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> blockManagerMaster = <span class="keyword">new</span> <span class="type">BlockManagerMaster</span>(registerOrLookupEndpoint(</span><br><span class="line">      <span class="type">BlockManagerMaster</span>.<span class="type">DRIVER_ENDPOINT_NAME</span>,</span><br><span class="line">      <span class="keyword">new</span> <span class="type">BlockManagerMasterEndpoint</span>(rpcEnv, isLocal, conf, listenerBus)),</span><br><span class="line">      conf, isDriver)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// NB: blockManager is not valid until initialize() is called later.</span></span><br><span class="line">    <span class="keyword">val</span> blockManager = <span class="keyword">new</span> <span class="type">BlockManager</span>(executorId, rpcEnv, blockManagerMaster,</span><br><span class="line">      serializerManager, conf, memoryManager, mapOutputTracker, shuffleManager,</span><br><span class="line">      blockTransferService, securityManager, numUsableCores)</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;其中会先创建 BlockManagerMaster，在 registerOrLookupEndpoint 中根据是否为 Driver 节点来创建 BlockManagerMasterEndpoint 的 RpcEndpointRef：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//SparkEnv</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">registerOrLookupEndpoint</span></span>(</span><br><span class="line">        name: <span class="type">String</span>, endpointCreator: =&gt; <span class="type">RpcEndpoint</span>):</span><br><span class="line">      <span class="type">RpcEndpointRef</span> = &#123;</span><br><span class="line">      <span class="keyword">if</span> (isDriver) &#123;</span><br><span class="line">        logInfo(<span class="string">"Registering "</span> + name)</span><br><span class="line">        rpcEnv.setupEndpoint(name, endpointCreator)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">RpcUtils</span>.makeDriverRef(name, conf, rpcEnv)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;registerOrLookupEndpoint 创建结果会当作参数传进 BlockManagerMaster，并赋值给了 BlockManagerMaster 中的 driverEndpoint 变量。无论当前节点是 Driver 或者 Executor，这个 driverEndpoint 都代表着 BlockManagerMasterEndpoint，当需要向 Driver 发送消息的时候就要调用这个 driverEndpoint。<br>&emsp;另外，在 BlockManager 内部，会创建一个 slaveEndpoint，用来代表自己，如果当前节点是 Executor，则 Driver 需要调用这个 slaveEndpoint 发送消息。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BlockManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> slaveEndpoint = rpcEnv.setupEndpoint(</span><br><span class="line">    <span class="string">"BlockManagerEndpoint"</span> + <span class="type">BlockManager</span>.<span class="type">ID_GENERATOR</span>.next,</span><br><span class="line">    <span class="keyword">new</span> <span class="type">BlockManagerSlaveEndpoint</span>(rpcEnv, <span class="keyword">this</span>, mapOutputTracker))</span><br></pre></td></tr></table></figure></p><h2 id="4-通信层"><a href="#4-通信层" class="headerlink" title="4.通信层"></a>4.通信层</h2><p>&emsp;Driver 和 Executor 的通信通过 RpcEndpoint 来实现，无论是 Driver 还是 Executor，它们的 BlockManagerMaster 的 driverEndpoint 属性都持有 BlockManagerMasterEndpoint 的 RpcEndpointRef。无论是 Driver 还是 Executor，每个 BlockManager 都拥有自己的 BlockManagerSlaveEndpoint 的 RpcEndpointRef。<br>&emsp;Executor 与 Driver 关于 BlockManager 的交互都依赖于 BlockManagerMaster。在 BlockManager 中会通过 BlockManagerMaster 向 BlockManagerMasterEndpoint 发送消息，以注册为例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.storage.BlockManager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reregister</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> We might need to rate limit re-registering.</span></span><br><span class="line">    logInfo(<span class="string">s"BlockManager <span class="subst">$blockManagerId</span> re-registering with master"</span>)</span><br><span class="line">    master.registerBlockManager(blockManagerId, maxOnHeapMemory, maxOffHeapMemory, slaveEndpoint)</span><br><span class="line">    reportAllBlocks()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>这里调用 master 的 registerBlockManager 方法进行注册，查看该方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">registerBlockManager</span></span>(</span><br><span class="line">      blockManagerId: <span class="type">BlockManagerId</span>,</span><br><span class="line">      maxOnHeapMemSize: <span class="type">Long</span>,</span><br><span class="line">      maxOffHeapMemSize: <span class="type">Long</span>,</span><br><span class="line">      slaveEndpoint: <span class="type">RpcEndpointRef</span>): <span class="type">BlockManagerId</span> = &#123;</span><br><span class="line">    logInfo(<span class="string">s"Registering BlockManager <span class="subst">$blockManagerId</span>"</span>)</span><br><span class="line">    <span class="keyword">val</span> updatedId = driverEndpoint.askSync[<span class="type">BlockManagerId</span>](</span><br><span class="line">      <span class="type">RegisterBlockManager</span>(blockManagerId, maxOnHeapMemSize, maxOffHeapMemSize, slaveEndpoint))</span><br><span class="line">    logInfo(<span class="string">s"Registered BlockManager <span class="subst">$updatedId</span>"</span>)</span><br><span class="line">    updatedId</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里通过 driverEndpoint 发送了一个 RegisterBlockManager 信息，这里的 driverEndpoint 是 BlockManagerMaster 构造的时候传入的 BlockManagerMasterEndpoint 的 RpcEndpointRef。<br>&emsp;简单来说，当 Executor 需要向 Driver 发送消息的时候，消息通信由 SparkEnv 的 BlockManagerMaster 负责，向 BlockManagerMaster 中的 <strong>driverEndpoint</strong>，即 BlockManagerMasterEndpoint 的 RpcEndPointRef 发送消息即可。BlockManagerMasterEndpoint 消息处理函数为 receive 函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context: <span class="type">RpcCallContext</span>): <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RegisterBlockManager</span>(blockManagerId, maxOnHeapMemSize, maxOffHeapMemSize, slaveEndpoint) =&gt;</span><br><span class="line">      context.reply(register(blockManagerId, maxOnHeapMemSize, maxOffHeapMemSize, slaveEndpoint))</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;由于在 BlockManagerMaster 调用 registerBlockManager 发送消息的时候，使用 driverEndpoint.askSync，即同步方式，返回结果直接赋值给 updatedId，所以不需要有单独的消息处理函数。<br>&emsp;我们看一下 Driver 向 Executor 发送消息的过程，这时候则需要向 BlockManager 的 <strong>slaveEndpoint</strong> 发送消息，这个 slaveEndpoint 代表指定 Executor 的 BlockManager。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BlockManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> slaveEndpoint = rpcEnv.setupEndpoint(</span><br><span class="line">    <span class="string">"BlockManagerEndpoint"</span> + <span class="type">BlockManager</span>.<span class="type">ID_GENERATOR</span>.next,</span><br><span class="line">    <span class="keyword">new</span> <span class="type">BlockManagerSlaveEndpoint</span>(rpcEnv, <span class="keyword">this</span>, mapOutputTracker))</span><br></pre></td></tr></table></figure><br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BlockManagerMasterEndpoint</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">removeBlockFromWorkers</span></span>(blockId: <span class="type">BlockId</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> locations = blockLocations.get(blockId)</span><br><span class="line">    <span class="keyword">if</span> (locations != <span class="literal">null</span>) &#123;</span><br><span class="line">      locations.foreach &#123; blockManagerId: <span class="type">BlockManagerId</span> =&gt;</span><br><span class="line">        <span class="keyword">val</span> blockManager = blockManagerInfo.get(blockManagerId)</span><br><span class="line">        <span class="keyword">if</span> (blockManager.isDefined) &#123;</span><br><span class="line">          <span class="comment">// Remove the block from the slave's BlockManager.</span></span><br><span class="line">          <span class="comment">// Doesn't actually wait for a confirmation and the message might get lost.</span></span><br><span class="line">          <span class="comment">// If message loss becomes frequent, we should add retry logic here.</span></span><br><span class="line">          </span><br><span class="line">          <span class="comment">//发送消息</span></span><br><span class="line">          blockManager.get.slaveEndpoint.ask[<span class="type">Boolean</span>](<span class="type">RemoveBlock</span>(blockId))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>BlockManagerMasterEndpoint 会向 Executor 对应的 blockManager 的 slaveEndpoint 发送消息，slaveEndpoint处理消息如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//BlockManagerSlaveEndpoint</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receiveAndReply</span></span>(context: <span class="type">RpcCallContext</span>): <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">RemoveBlock</span>(blockId) =&gt;</span><br><span class="line">      doAsync[<span class="type">Boolean</span>](<span class="string">"removing block "</span> + blockId, context) &#123;</span><br><span class="line">        blockManager.removeBlock(blockId)</span><br><span class="line">        <span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-储存层-缓存实现"><a href="#5-储存层-缓存实现" class="headerlink" title="5.储存层(缓存实现)"></a>5.储存层(缓存实现)</h2><p>&emsp;在 RDD 层面来说，RDD 是由不同的 partition 组成的，我们所进行的 transformation 或 action 操作 都是在 partition 上面进行的；而在 Storage 模块内部，RDD 由被视为由不同的 block 组成，对 RDD 的存取是以 block 为单位进行的，<strong>本质上 partition 和 block 是等价的</strong>，只是看待角度不一样。在 Spark storage 模块中存取数据的最小单位是 block，所有的操作都是以 block 为单位进行的。<br>&emsp;BlockManager 对象被创建的时候会创建出 MemoryStore 和 DiskStore，作为实际 Block 的储存位置。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> diskBlockManager = &#123;</span><br><span class="line">    <span class="comment">// Only perform cleanup if an external service is not serving our shuffle files.</span></span><br><span class="line">    <span class="keyword">val</span> deleteFilesOnStop =</span><br><span class="line">      !externalShuffleServiceEnabled || executorId == <span class="type">SparkContext</span>.<span class="type">DRIVER_IDENTIFIER</span></span><br><span class="line">    <span class="keyword">new</span> <span class="type">DiskBlockManager</span>(conf, deleteFilesOnStop)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="comment">// Actual storage of where blocks are kept</span></span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="keyword">val</span> memoryStore =</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MemoryStore</span>(conf, blockInfoManager, serializerManager, memoryManager, <span class="keyword">this</span>)</span><br><span class="line">  <span class="keyword">private</span>[spark] <span class="keyword">val</span> diskStore = <span class="keyword">new</span> <span class="type">DiskStore</span>(conf, diskBlockManager, securityManager)</span><br><span class="line">  memoryManager.setMemoryStore(memoryStore)</span><br></pre></td></tr></table></figure></p><h3 id="5-1-DiskStore"><a href="#5-1-DiskStore" class="headerlink" title="5.1 DiskStore"></a>5.1 DiskStore</h3><p>&emsp;磁盘储存可以配置多个本地储存目录，通过配置 spark.local.dir 属性或 系统属性 java.io.tmpdir 制定的目录，并在每个路径下创建以 blockmgr- 为前缀，UUID 为后缀的随机字符串的子目录<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DiskBlockManager</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createLocalDirs</span></span>(conf: <span class="type">SparkConf</span>): <span class="type">Array</span>[<span class="type">File</span>] = &#123;</span><br><span class="line">    <span class="type">Utils</span>.getConfiguredLocalDirs(conf).flatMap &#123; rootDir =&gt;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> localDir = <span class="type">Utils</span>.createDirectory(rootDir, <span class="string">"blockmgr"</span>)</span><br><span class="line">        logInfo(<span class="string">s"Created local directory at <span class="subst">$localDir</span>"</span>)</span><br><span class="line">        <span class="type">Some</span>(localDir)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">IOException</span> =&gt;</span><br><span class="line">          logError(<span class="string">s"Failed to create local dir in <span class="subst">$rootDir</span>. Ignoring this directory."</span>, e)</span><br><span class="line">          <span class="type">None</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;图片表示 DiskBlockManager 管理的文件目录结构，可以看到，每个一级目录，即 localDirs 下面都会有多个 subDirs，每个 subDir 则储存一个或多个 Block 文件。<br><img src="https://gitee.com/JP6907/Pic/raw/master/spark/DiskBlockManager-dir.png" alt="DiskBlockManager-dir"><br>&emsp;实际 Block 是如何映射到磁盘的具体文件的？我们可以看一下下面函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DiskBlockManager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFile</span></span>(blockId: <span class="type">BlockId</span>): <span class="type">File</span> = getFile(blockId.name)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getFile</span></span>(filename: <span class="type">String</span>): <span class="type">File</span> = &#123;</span><br><span class="line">    <span class="comment">// Figure out which local directory it hashes to, and which subdirectory in that</span></span><br><span class="line">    <span class="keyword">val</span> hash = <span class="type">Utils</span>.nonNegativeHash(filename)</span><br><span class="line">    <span class="keyword">val</span> dirId = hash % localDirs.length</span><br><span class="line">    <span class="keyword">val</span> subDirId = (hash / localDirs.length) % subDirsPerLocalDir</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Create the subdirectory if it doesn't already exist</span></span><br><span class="line">    <span class="keyword">val</span> subDir = subDirs(dirId).synchronized &#123;</span><br><span class="line">      <span class="keyword">val</span> old = subDirs(dirId)(subDirId)</span><br><span class="line">      <span class="keyword">if</span> (old != <span class="literal">null</span>) &#123;</span><br><span class="line">        old</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">val</span> newDir = <span class="keyword">new</span> <span class="type">File</span>(localDirs(dirId), <span class="string">"%02x"</span>.format(subDirId))</span><br><span class="line">        <span class="keyword">if</span> (!newDir.exists() &amp;&amp; !newDir.mkdir()) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">s"Failed to create local dir in <span class="subst">$newDir</span>."</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        subDirs(dirId)(subDirId) = newDir</span><br><span class="line">        newDir</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">new</span> <span class="type">File</span>(subDir, filename)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;先是获取 blockId 的名字，BlockId 是一个抽象类，它有很多中实现，比如 RDDBlockId,ShuffleBlockId等，以RDDBlockId为例，它的规则为：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.storage.BlockId</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RDDBlockId</span>(<span class="params">rddId: <span class="type">Int</span>, splitIndex: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">BlockId</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">name</span></span>: <span class="type">String</span> = <span class="string">"rdd_"</span> + rddId + <span class="string">"_"</span> + splitIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;获取到 blockid 的名字之后，接下来以下面的规则进行 block 到 file 的映射：</p><ol><li>获取文件名的 hash；<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> hash = <span class="type">Utils</span>.nonNegativeHash(filename)</span><br></pre></td></tr></table></figure></li><li>hash 和 localDirs 数组的长度取余获得选中的一级目录；<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> dirId = hash % localDirs.length</span><br></pre></td></tr></table></figure></li><li>hash 和 localDirs 数组的长度的商和 subDirsPerLocalDir 取余获得二级目录；<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> subDirId = (hash / localDirs.length) % subDirsPerLocalDir</span><br></pre></td></tr></table></figure>如果二级目录不存在，则需要创建二级目录。</li></ol><h3 id="5-2-MemoryStore"><a href="#5-2-MemoryStore" class="headerlink" title="5.2 MemoryStore"></a>5.2 MemoryStore</h3><p>&emsp;MemoryStore 管理 Block 相对于 BlockStore 来说比较简单，MemoryStore 内部维护了一个 Hashmap 来管理所有的 block，以 block id 为 key 将 block 存放到 Hashmap中。block 的内容则被封装在一个结构体 MemoryEntry。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> entries = <span class="keyword">new</span> <span class="type">LinkedHashMap</span>[<span class="type">BlockId</span>, <span class="type">MemoryEntry</span>[_]](<span class="number">32</span>, <span class="number">0.75</span>f, <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><br>&emsp;在 MemoryStore 中存放 block必须确保内存足够容纳下该 block，JVM 默认 是60%可以被内存缓存用来储存 block。当超过60%之后，Spark 会根据配置的缓存策略来决定是丢弃一些 block 还是将一些 block 储存到磁盘上。</p><h3 id="5-3-BlockManager存取Block"><a href="#5-3-BlockManager存取Block" class="headerlink" title="5.3 BlockManager存取Block"></a>5.3 BlockManager存取Block</h3><p>&emsp;对于 Block 的存取不需要我们直接通过 DiskStore 或 MemoryStore 来进行，BlockManager 提供了相应的 get 和 put 接口。</p><h4 id="5-3-1-put"><a href="#5-3-1-put" class="headerlink" title="5.3.1 put"></a>5.3.1 put</h4><p>&emsp;在 BlockManager 中，putSingle 方法能够将一个对象写入 Block，putSingle 调用了 putIterator 方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doPutIterator</span></span>[<span class="type">T</span>](</span><br><span class="line">      blockId: <span class="type">BlockId</span>,</span><br><span class="line">      iterator: () =&gt; <span class="type">Iterator</span>[<span class="type">T</span>],</span><br><span class="line">      level: <span class="type">StorageLevel</span>,</span><br><span class="line">      classTag: <span class="type">ClassTag</span>[<span class="type">T</span>],</span><br><span class="line">      tellMaster: <span class="type">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line">      keepReadLock: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Option</span>[<span class="type">PartiallyUnrolledIterator</span>[<span class="type">T</span>]] = &#123;</span><br><span class="line">    doPut(blockId, level, classTag, tellMaster = tellMaster, keepReadLock = keepReadLock) &#123; info =&gt;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;doPutIterator 方法里面只调用了 doPut 方法，后面 {} 里面的内容是传入 doPut 方法的一个函数，该函数的参数是 Blockinfo，函数体的具体内容是根据 Blockinfo 执行相应的储存操作。我们先看一下 doPut 方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doPut</span></span>[<span class="type">T</span>](</span><br><span class="line">      blockId: <span class="type">BlockId</span>,</span><br><span class="line">      level: <span class="type">StorageLevel</span>,</span><br><span class="line">      classTag: <span class="type">ClassTag</span>[_],</span><br><span class="line">      tellMaster: <span class="type">Boolean</span>,</span><br><span class="line">      keepReadLock: <span class="type">Boolean</span>)(putBody: <span class="type">BlockInfo</span> =&gt; <span class="type">Option</span>[<span class="type">T</span>]): <span class="type">Option</span>[<span class="type">T</span>] = &#123;</span><br><span class="line"></span><br><span class="line">    require(blockId != <span class="literal">null</span>, <span class="string">"BlockId is null"</span>)</span><br><span class="line">    require(level != <span class="literal">null</span> &amp;&amp; level.isValid, <span class="string">"StorageLevel is null or invalid"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> putBlockInfo = &#123;</span><br><span class="line">      <span class="keyword">val</span> newInfo = <span class="keyword">new</span> <span class="type">BlockInfo</span>(level, classTag, tellMaster)</span><br><span class="line">      <span class="keyword">if</span> (blockInfoManager.lockNewBlockForWriting(blockId, newInfo)) &#123;</span><br><span class="line">        newInfo</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logWarning(<span class="string">s"Block <span class="subst">$blockId</span> already exists on this machine; not re-adding it"</span>)</span><br><span class="line">        <span class="keyword">if</span> (!keepReadLock) &#123;</span><br><span class="line">          <span class="comment">// lockNewBlockForWriting returned a read lock on the existing block, so we must free it:</span></span><br><span class="line">          releaseLock(blockId)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="type">None</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> startTimeMs = <span class="type">System</span>.currentTimeMillis</span><br><span class="line">    <span class="keyword">var</span> exceptionWasThrown: <span class="type">Boolean</span> = <span class="literal">true</span></span><br><span class="line">    <span class="keyword">val</span> result: <span class="type">Option</span>[<span class="type">T</span>] = <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> res = putBody(putBlockInfo)</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    result</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;在 doPut 方法里面，先构造一个 BlockInfo，然后将 BlockInfo 放进 putBody，putBody 就是前面 doPutIterator 方法中传入 doPut 方法的函数，我们再来看一下这个函数：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doPutIterator</span></span>[<span class="type">T</span>](</span><br><span class="line">      blockId: <span class="type">BlockId</span>,</span><br><span class="line">      iterator: () =&gt; <span class="type">Iterator</span>[<span class="type">T</span>],</span><br><span class="line">      level: <span class="type">StorageLevel</span>,</span><br><span class="line">      classTag: <span class="type">ClassTag</span>[<span class="type">T</span>],</span><br><span class="line">      tellMaster: <span class="type">Boolean</span> = <span class="literal">true</span>,</span><br><span class="line">      keepReadLock: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">Option</span>[<span class="type">PartiallyUnrolledIterator</span>[<span class="type">T</span>]] = &#123;</span><br><span class="line">    doPut(blockId, level, classTag, tellMaster = tellMaster, keepReadLock = keepReadLock) &#123; info =&gt;</span><br><span class="line">      <span class="keyword">val</span> startTimeMs = <span class="type">System</span>.currentTimeMillis</span><br><span class="line">      <span class="keyword">var</span> iteratorFromFailedMemoryStorePut: <span class="type">Option</span>[<span class="type">PartiallyUnrolledIterator</span>[<span class="type">T</span>]] = <span class="type">None</span></span><br><span class="line">      <span class="comment">// Size of the block in bytes</span></span><br><span class="line">      <span class="keyword">var</span> size = <span class="number">0</span>L</span><br><span class="line"></span><br><span class="line">      <span class="comment">//根据储存级别储存到本地</span></span><br><span class="line">      <span class="keyword">if</span> (level.useMemory) &#123;</span><br><span class="line">        <span class="comment">// Put it in memory first, even if it also has useDisk set to true;</span></span><br><span class="line">        <span class="comment">// We will drop it to disk later if the memory store can't hold it.</span></span><br><span class="line">        <span class="keyword">if</span> (level.deserialized) &#123;</span><br><span class="line">          memoryStore.putIteratorAsValues(blockId, iterator(), classTag) <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Right</span>(s) =&gt;</span><br><span class="line">              size = s</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Left</span>(iter) =&gt;</span><br><span class="line">              <span class="comment">// Not enough space to unroll this block; drop to disk if applicable</span></span><br><span class="line">              <span class="keyword">if</span> (level.useDisk) &#123;</span><br><span class="line">                logWarning(<span class="string">s"Persisting block <span class="subst">$blockId</span> to disk instead."</span>)</span><br><span class="line">                diskStore.put(blockId) &#123; channel =&gt;</span><br><span class="line">                  <span class="keyword">val</span> out = <span class="type">Channels</span>.newOutputStream(channel)</span><br><span class="line">                  serializerManager.dataSerializeStream(blockId, out, iter)(classTag)</span><br><span class="line">                &#125;</span><br><span class="line">                size = diskStore.getSize(blockId)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                iteratorFromFailedMemoryStorePut = <span class="type">Some</span>(iter)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123; <span class="comment">// !level.deserialized</span></span><br><span class="line">          memoryStore.putIteratorAsBytes(blockId, iterator(), classTag, level.memoryMode) <span class="keyword">match</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Right</span>(s) =&gt;</span><br><span class="line">              size = s</span><br><span class="line">            <span class="keyword">case</span> <span class="type">Left</span>(partiallySerializedValues) =&gt;</span><br><span class="line">              <span class="comment">// Not enough space to unroll this block; drop to disk if applicable</span></span><br><span class="line">              <span class="keyword">if</span> (level.useDisk) &#123;</span><br><span class="line">                logWarning(<span class="string">s"Persisting block <span class="subst">$blockId</span> to disk instead."</span>)</span><br><span class="line">                diskStore.put(blockId) &#123; channel =&gt;</span><br><span class="line">                  <span class="keyword">val</span> out = <span class="type">Channels</span>.newOutputStream(channel)</span><br><span class="line">                  partiallySerializedValues.finishWritingToStream(out)</span><br><span class="line">                &#125;</span><br><span class="line">                size = diskStore.getSize(blockId)</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                iteratorFromFailedMemoryStorePut = <span class="type">Some</span>(partiallySerializedValues.valuesIterator)</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (level.useDisk) &#123;</span><br><span class="line">        diskStore.put(blockId) &#123; channel =&gt;</span><br><span class="line">          <span class="keyword">val</span> out = <span class="type">Channels</span>.newOutputStream(channel)</span><br><span class="line">          serializerManager.dataSerializeStream(blockId, out, iterator())(classTag)</span><br><span class="line">        &#125;</span><br><span class="line">        size = diskStore.getSize(blockId)</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">val</span> putBlockStatus = getCurrentBlockStatus(blockId, info)</span><br><span class="line">      <span class="keyword">val</span> blockWasSuccessfullyStored = putBlockStatus.storageLevel.isValid</span><br><span class="line">      <span class="keyword">if</span> (blockWasSuccessfullyStored) &#123;</span><br><span class="line">        <span class="comment">// Now that the block is in either the memory or disk store, tell the master about it.</span></span><br><span class="line">        info.size = size</span><br><span class="line">        <span class="keyword">if</span> (tellMaster &amp;&amp; info.tellMaster) &#123;</span><br><span class="line">          reportBlockStatus(blockId, putBlockStatus)</span><br><span class="line">        &#125;</span><br><span class="line">        addUpdatedBlockStatusToTaskMetrics(blockId, putBlockStatus)</span><br><span class="line">        logDebug(<span class="string">"Put block %s locally took %s"</span>.format(blockId, <span class="type">Utils</span>.getUsedTimeMs(startTimeMs)))</span><br><span class="line"></span><br><span class="line">        <span class="comment">//如果副本数量大于1，需要储存到其它节点上</span></span><br><span class="line">        <span class="keyword">if</span> (level.replication &gt; <span class="number">1</span>) &#123;</span><br><span class="line">          <span class="keyword">val</span> remoteStartTime = <span class="type">System</span>.currentTimeMillis</span><br><span class="line">          <span class="keyword">val</span> bytesToReplicate = doGetLocalBytes(blockId, info)</span><br><span class="line">          <span class="comment">// [SPARK-16550] Erase the typed classTag when using default serialization, since</span></span><br><span class="line">          <span class="comment">// NettyBlockRpcServer crashes when deserializing repl-defined classes.</span></span><br><span class="line">          <span class="comment">// TODO(ekl) remove this once the classloader issue on the remote end is fixed.</span></span><br><span class="line">          <span class="keyword">val</span> remoteClassTag = <span class="keyword">if</span> (!serializerManager.canUseKryo(classTag)) &#123;</span><br><span class="line">            scala.reflect.classTag[<span class="type">Any</span>]</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            classTag</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            replicate(blockId, bytesToReplicate, level, remoteClassTag)</span><br><span class="line">          &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            bytesToReplicate.dispose()</span><br><span class="line">          &#125;</span><br><span class="line">          logDebug(<span class="string">"Put block %s remotely took %s"</span></span><br><span class="line">            .format(blockId, <span class="type">Utils</span>.getUsedTimeMs(remoteStartTime)))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      assert(blockWasSuccessfullyStored == iteratorFromFailedMemoryStorePut.isEmpty)</span><br><span class="line">      iteratorFromFailedMemoryStorePut</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这个函数体首先根据 block 的 storage level 将 block 储存到内存或者磁盘上，在本地储存成功之后，判断 block 指定的副本数量 level.replication 是否大于1，如果是，则调用 replicate 方法将 block 储存到其它节点上。在 replicate 方法里面会使用 blockTransferService 服务将 Block 传输到其它节点，而节点的选择会根据副本策略 blockReplicationPolicy，副本策略通过 spark.storage.replication.policy 配置来指定，默认使用 RandomBlockReplicationPolicy。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">replicate</span></span>(</span><br><span class="line">      blockId: <span class="type">BlockId</span>,</span><br><span class="line">      data: <span class="type">BlockData</span>,</span><br><span class="line">      level: <span class="type">StorageLevel</span>,</span><br><span class="line">      classTag: <span class="type">ClassTag</span>[_],</span><br><span class="line">      existingReplicas: <span class="type">Set</span>[<span class="type">BlockManagerId</span>] = <span class="type">Set</span>.empty): <span class="type">Unit</span> = &#123;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> peersForReplication = blockReplicationPolicy.prioritize(</span><br><span class="line">      blockManagerId,</span><br><span class="line">      initialPeers,</span><br><span class="line">      peersReplicatedTo,</span><br><span class="line">      blockId,</span><br><span class="line">      numPeersToReplicateTo)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(numFailures &lt;= maxReplicationFailures &amp;&amp;</span><br><span class="line">      !peersForReplication.isEmpty &amp;&amp;</span><br><span class="line">      peersReplicatedTo.size &lt; numPeersToReplicateTo) &#123;</span><br><span class="line">      <span class="keyword">val</span> peer = peersForReplication.head</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        </span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">        blockTransferService.uploadBlockSync(</span><br><span class="line">          peer.host,</span><br><span class="line">          peer.port,</span><br><span class="line">          peer.executorId,</span><br><span class="line">          blockId,</span><br><span class="line">          buffer,</span><br><span class="line">          tLevel,</span><br><span class="line">          classTag)</span><br><span class="line">        logTrace(<span class="string">s"Replicated <span class="subst">$blockId</span> of <span class="subst">$&#123;data.size&#125;</span> bytes to <span class="subst">$peer</span>"</span> +</span><br><span class="line">          <span class="string">s" in <span class="subst">$&#123;(System.nanoTime - onePeerStartTime).toDouble / 1e6&#125;</span> ms"</span>)</span><br><span class="line">        peersForReplication = peersForReplication.tail</span><br><span class="line">        peersReplicatedTo += peer</span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h4 id="5-3-2-get"><a href="#5-3-2-get" class="headerlink" title="5.3.2 get"></a>5.3.2 get</h4><p>&emsp;接下来我们看一下 BlockManager 的 get 方法，get 能够根据 id 获取指定的 Block。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](blockId: <span class="type">BlockId</span>): <span class="type">Option</span>[<span class="type">BlockResult</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> local = getLocalValues(blockId)</span><br><span class="line">    <span class="keyword">if</span> (local.isDefined) &#123;</span><br><span class="line">      logInfo(<span class="string">s"Found block <span class="subst">$blockId</span> locally"</span>)</span><br><span class="line">      <span class="keyword">return</span> local</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> remote = getRemoteValues[<span class="type">T</span>](blockId)</span><br><span class="line">    <span class="keyword">if</span> (remote.isDefined) &#123;</span><br><span class="line">      logInfo(<span class="string">s"Found block <span class="subst">$blockId</span> remotely"</span>)</span><br><span class="line">      <span class="keyword">return</span> remote</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">None</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;get 方法比较简单，判断该 Block 是否在本地，是的话调用 getLocalValues 直接从本地读取，否则调用 getRemoteValues 请求从其它节点获取。这两个方法也相对比较简单，getLocalValues 根据 Block 的储存级别决定从内存或者磁盘读取。getRemoteValues 调用了 getRemoteBytes，getRemoteBytes 会先向 master 节点请求获取有储存该 Block 的节点地址，然后调用 blockTransferService 服务接收该 Block。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">getRemoteBytes</span></span>(blockId: <span class="type">BlockId</span>): <span class="type">Option</span>[<span class="type">ChunkedByteBuffer</span>] = &#123;</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> locationsAndStatus = master.getLocationsAndStatus(blockId)</span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (locationIterator.hasNext) &#123;</span><br><span class="line">      <span class="keyword">val</span> loc = locationIterator.next()</span><br><span class="line">      logDebug(<span class="string">s"Getting remote block <span class="subst">$blockId</span> from <span class="subst">$loc</span>"</span>)</span><br><span class="line">      <span class="keyword">val</span> data = <span class="keyword">try</span> &#123;</span><br><span class="line">        blockTransferService.fetchBlockSync(</span><br><span class="line">          loc.host, loc.port, loc.executorId, blockId.toString, tempFileManager)</span><br><span class="line">      &#125; </span><br><span class="line"></span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="5-4-Partition和Block的关系"><a href="#5-4-Partition和Block的关系" class="headerlink" title="5.4 Partition和Block的关系"></a>5.4 Partition和Block的关系</h3><p>&emsp;在 Storage 模块里面所有的操作都是和 Block 有关的，但是在 RDD 里面所有的运算都是基于 Partition 的，那么 Partition 是如何与 Block 对应上的？在 Spark 中，Partition 是一个逻辑上的概念，而 Block 是一个物理上的数据实体，<strong>一个 RDD 的 Partition 对应于一个 Storage 模块中的 Block</strong>，下面是 RDD 类中 iterator() 方法的实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (storageLevel != <span class="type">StorageLevel</span>.<span class="type">NONE</span>) &#123;</span><br><span class="line">      getOrCompute(split, context)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      computeOrReadCheckpoint(split, context)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;如果储存级别不是 NONE 的话，表示该 RDD 所包括的一系列 Partition 以 Block 的状态储存在 BlockManager 中，调用 getOrCompute 获取：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">getOrCompute</span></span>(partition: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> blockId = <span class="type">RDDBlockId</span>(id, partition.index)</span><br><span class="line">    <span class="keyword">var</span> readCachedBlock = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// This method is called on executors, so we need call SparkEnv.get instead of sc.env.</span></span><br><span class="line">    <span class="type">SparkEnv</span>.get.blockManager.getOrElseUpdate(blockId, storageLevel, elementClassTag, () =&gt; &#123;</span><br><span class="line">      readCachedBlock = <span class="literal">false</span></span><br><span class="line">      computeOrReadCheckpoint(partition, context)</span><br><span class="line">    &#125;) <span class="keyword">match</span> &#123;</span><br><span class="line">      ...</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@DeveloperApi</span></span><br><span class="line"><span class="keyword">case</span> <span class="class"><span class="keyword">class</span> <span class="title">RDDBlockId</span>(<span class="params">rddId: <span class="type">Int</span>, splitIndex: <span class="type">Int</span></span>) <span class="keyword">extends</span> <span class="title">BlockId</span> </span>&#123;</span><br><span class="line">  <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">name</span></span>: <span class="type">String</span> = <span class="string">"rdd_"</span> + rddId + <span class="string">"_"</span> + splitIndex</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;可以看到，blockId 是由 RDD id 和 Partition index构造出来的，每一个 RDD 的一个分区都对应有一个独一无二的 block id，使用这个 block id 就能够从 BlockManager 获取到指定的 Block。</p><h2 id="6-储存级别"><a href="#6-储存级别" class="headerlink" title="6.储存级别"></a>6.储存级别</h2><p>&emsp;Spark 是基于内存进行计算的，但 RDD 的数据集不仅可以储存在内存中，还可以使用 RDD 类的 persist 方法和 cache 方法将数据缓存到 内存、磁盘等媒介中。我们看一下 persist 方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">persist</span></span>(newLevel: <span class="type">StorageLevel</span>, allowOverride: <span class="type">Boolean</span>): <span class="keyword">this</span><span class="class">.<span class="keyword">type</span> </span>= &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> Handle changes of StorageLevel</span></span><br><span class="line">    <span class="keyword">if</span> (storageLevel != <span class="type">StorageLevel</span>.<span class="type">NONE</span> &amp;&amp; newLevel != storageLevel &amp;&amp; !allowOverride) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">UnsupportedOperationException</span>(</span><br><span class="line">        <span class="string">"Cannot change storage level of an RDD after it was already assigned a level"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// If this is the first time this RDD is marked for persisting, register it</span></span><br><span class="line">    <span class="comment">// with the SparkContext for cleanups and accounting. Do this only once.</span></span><br><span class="line">    <span class="keyword">if</span> (storageLevel == <span class="type">StorageLevel</span>.<span class="type">NONE</span>) &#123;</span><br><span class="line">      sc.cleaner.foreach(_.registerRDDForCleanup(<span class="keyword">this</span>))</span><br><span class="line">      sc.persistRDD(<span class="keyword">this</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    storageLevel = newLevel</span><br><span class="line">    <span class="keyword">this</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;当 RDD 第一次被计算时，persist 方法会根据参数 StorageLevel 设置特定的缓存策略，但它只适用于原本 StorageLevel 为 None 或者参数与原来 StorageLevel 一致的情况，即 RDD 不允许修改已经设置的 储存级别。<br>&emsp;注意，persist 方法只是修改了 RDD 的 storageLevel 属性，并没有触发真正的储存操作，storageLevel 属性会被当作参数传递给 BlockManager，由 BlockManager 负责具体的储存操作。RDD 的 getOrCompute 函数会接收 storageLevel 参数，接着就会调用 blockManager.getOrElseUpdate 方法，这时候才真正触发了 RDD 的存储操作。<br>&emsp;对于 cache 方法而言，它只是 persist 方法的一个特例，即 persist 方法参数为 StorageLevel.MEMORY_ONLY 的情况：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">persist</span></span>(): <span class="keyword">this</span><span class="class">.<span class="keyword">type</span> </span>= persist(<span class="type">StorageLevel</span>.<span class="type">MEMORY_ONLY</span>)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">cache</span></span>(): <span class="keyword">this</span><span class="class">.<span class="keyword">type</span> </span>= persist()</span><br></pre></td></tr></table></figure><br>&emsp;接下来我们看一下储存级别，根据 _useDisk（使用磁盘）、_useMemory（使用内存）、_useOffHeap（使用堆外内存）、_deserialized（反序列化）、_replication（副本数量）五个参数的组合，Spark提供了12中储存级别的缓存策略：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StorageLevel</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">NONE</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">DISK_ONLY</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>)  </span><br><span class="line">  <span class="keyword">val</span> <span class="type">DISK_ONLY_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)  </span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)  <span class="comment">//只储存在内存</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>)  <span class="comment">//只储存在内存，副本数量为2</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY_SER</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>)   <span class="comment">//序列化后储存在内存</span></span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_ONLY_SER_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">false</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">true</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_SER</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">MEMORY_AND_DISK_SER_2</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="literal">false</span>, <span class="number">2</span>)</span><br><span class="line">  <span class="keyword">val</span> <span class="type">OFF_HEAP</span> = <span class="keyword">new</span> <span class="type">StorageLevel</span>(<span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">true</span>, <span class="literal">false</span>, <span class="number">1</span>)  <span class="comment">//储存在外部分布式缓存系统中</span></span><br></pre></td></tr></table></figure><br>&emsp;Spark 的默认储存级别是 MEMORY_ONLY，只缓存到内存并且以原生方式存（反序列化）一个副本。采用 SER 序列化的储存级别能够提高空间的利用率，MEMORY_AND_DISK 储存级别在内存足够的时候直接保存到内存，只有当内存不足的时候，才会储存到磁盘。如果想要确保高效的容错，除了依靠 RDD 的 Lineage 重新计算，还可以采用 replication 大于1的储存策略。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>&emsp;本文首先介绍了 Spark 储存系统的整体架构以及各个组件之间的关系，接着介绍了 Storage 通信层和储存层的实现原理，还分析了 RDD 的 partition 与 Storage 中 Block 一对一的关系，对 Spark 的储存系统整体上有了更好的把握。</p><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-storage/">http://zhoujiapeng.top/Spark/spark-storage/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark源码阅读 之 容错机制</title>
      <link href="/Spark/spark-fault-tolerant/"/>
      <url>/Spark/spark-fault-tolerant/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-容错机制"><a href="#Spark-容错机制" class="headerlink" title="Spark 容错机制"></a>Spark 容错机制</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><p>&emsp;分布式数据集实现容错的方式有两种，一种是记录更新，另一种是检查点(checkpoint)。Spark 采用两种方式类实现数据集的容错：第一种是Lineage(血统)机制，即记录更新，基于 RDD，Spark 实现了一系列的 transformation 算子。这些算子可以同时施加于同一数据，这样就形成了以了 Lineage 链。当某个 RDD 的分区数据丢失时，就可以依据这个链进行回溯，重新计算并还原丢失的数据；第二种是 Checkpoint(检查点)机制，当 RDD 的计算链过长时，一旦某个分区的数据丢失后就需要进行大量的重复计算来恢复，这样不仅消耗了时间资源，也可能会造成某些数据的冗余计算，为了避免这种情况的发生，可以使用 Checkpoint 机制，将数据储存到磁盘来实现容错。</p><h2 id="1-Lineage机制"><a href="#1-Lineage机制" class="headerlink" title="1.Lineage机制"></a>1.Lineage机制</h2><p>&emsp;RDD 提供基于粗粒度转换(coarse-grained-transformation)的接口，如map、join等可以将同一操作施加到许多数据项上。RDD 通过所谓的血统关系（Lineage）记录它是如何从其它 RDD 演变过来的。当某个 RDD 部分分区数据丢失时，可以通过重新计算来还原丢失的数据，避免数据复制的高开销。<br>&emsp;在 RDD 中将依赖划分成两种类型：窄依赖（Narrow Dependencies）和宽依赖（Wide/Shuffle Dependencies）。窄依赖是指父 RDD 的每一个分区最多被一个子 RDD 的分区所用，表现为一个父 RDD 的分区对应于一个子 RDD 的分区或多个父 RDD 的分区对应于一个子 RDD 的分区，也就是说一个父 RDD 的一个分区不可能对应一个子 RDD 的多个分区；宽依赖是指子 RDD 的分区依赖于父 RDD 的多个分区或所有分区，也就是说存在一个父 RDD 的一个分区对应一个子 RDD 的多个分区。例如，map就是一种窄依赖，而join则会导致宽依赖，除非父 RDD 是 hash-partitioned。窄依赖对于数据重新计算的开销远小于宽依赖的数据重新计算开销。<br>&emsp;这种划分在容错机制中有两个用处。首先，窄依赖支持在一个节点上管道化执行，即 pipeline 操作；其次，窄依赖支持更高效的故障还原，对于窄依赖，只有丢失的父 RDD 的分区需要重新计算，不依赖于其它分区，并不存在冗余计算，而宽依赖可能会导致重新计算并不会丢失的子 RDD 的分区数据。因此对于宽依赖，Spark 通过一定的数据持久化来简化故障还原。</p><h2 id="2-Checkpoint机制"><a href="#2-Checkpoint机制" class="headerlink" title="2.Checkpoint机制"></a>2.Checkpoint机制</h2><p>&emsp;Lineage 机制可以用来故障恢复，但对于 Lineage 链较长的 RDD 来说，这种恢复可能很耗时，尤其是在做一些迭代操作的时候。Checkpoint 机制通过冗余数据来缓存数据，避免重复计算。Checkpoint 机制没有在 Job 第一次计算得到结果就储存，而是等到 Job 结束后启动<strong>专门的 Job</strong> 去完成 Checkpoint。也就是说，需要 Checkpoint 的 RDD 会被计算两次。因此，在使用 rdd.Checkpoint() 的时候，建议加上 rdd.cache()，这样第二次运行的 job 可能直接从缓存读取数据而不需要重复计算。另外，RDD 提供了 rdd.persist(StorageLevel.DISK_ONLY) 这样的方法，相当于缓存到磁盘，这样就可以做到 RDD 在第一次计算的时候就将结果储存到磁盘。<br>&emsp;在checkpoint之前，我们需要先设置checkpoint数据保存的目录:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sc.setCheckpointDir(<span class="string">"path"</span>)</span><br></pre></td></tr></table></figure><br>&emsp;当一个RDD需要被 checkpoint 的时候，一般会经过四个阶段：initialized、Mark for checkpointing、checkpoinging in progress、checkpointed。</p><h3 id="2-1-标记-checkpoint"><a href="#2-1-标记-checkpoint" class="headerlink" title="2.1 标记 checkpoint"></a>2.1 标记 checkpoint</h3><p>&emsp;当我们调用 rdd.checkpoint() 的时候，实际上并不会真正触发 checkpoint 操作，而只是将当前 RDD 标识为需要 checkpoint。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkpoint</span></span>(): <span class="type">Unit</span> = <span class="type">RDDCheckpointData</span>.synchronized &#123;</span><br><span class="line">    <span class="comment">// <span class="doctag">NOTE:</span> we use a global lock here due to complexities downstream with ensuring</span></span><br><span class="line">    <span class="comment">// children RDD partitions point to the correct parent partitions. In the future</span></span><br><span class="line">    <span class="comment">// we should revisit this consideration.</span></span><br><span class="line">    <span class="keyword">if</span> (context.checkpointDir.isEmpty) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(<span class="string">"Checkpoint directory has not been set in the SparkContext"</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (checkpointData.isEmpty) &#123;</span><br><span class="line">        <span class="comment">//类型是 ReliableRDDCheckpointData</span></span><br><span class="line">      checkpointData = <span class="type">Some</span>(<span class="keyword">new</span> <span class="type">ReliableRDDCheckpointData</span>(<span class="keyword">this</span>))</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;这里会根据当前 RDD 给 checkpointData 赋值，注意，这里给 checkpointData 赋的值是 <strong>ReliableRDDCheckpointData</strong> 对象。当 checkpointData 不为空的时候，表明这个 RDD 需要被 checkpoint，即被标记。</p><h3 id="2-2-触发-checkpoint-操作"><a href="#2-2-触发-checkpoint-操作" class="headerlink" title="2.2 触发 checkpoint 操作"></a>2.2 触发 checkpoint 操作</h3><p>&emsp;checkpoint 真正执行操作会被推迟到 action 算子触发 runJob 的时候。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Sparkcontext.runJob</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runJob</span></span>[<span class="type">T</span>, <span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">      resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (stopped.get()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"SparkContext has been shutdown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> callSite = getCallSite</span><br><span class="line">    <span class="keyword">val</span> cleanedFunc = clean(func)</span><br><span class="line">    logInfo(<span class="string">"Starting job: "</span> + callSite.shortForm)</span><br><span class="line">    <span class="keyword">if</span> (conf.getBoolean(<span class="string">"spark.logLineage"</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">      logInfo(<span class="string">"RDD's recursive dependencies:\n"</span> + rdd.toDebugString)</span><br><span class="line">    &#125;</span><br><span class="line">    dagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, resultHandler, localProperties.get)</span><br><span class="line">    progressBar.foreach(_.finishAll())</span><br><span class="line">    rdd.doCheckpoint()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>最后会执行 rdd.doCheckpoint()，这里真正触发 checkpoint 操作。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">doCheckpoint</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="type">RDDOperationScope</span>.withScope(sc, <span class="string">"checkpoint"</span>, allowNesting = <span class="literal">false</span>, ignoreParent = <span class="literal">true</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!doCheckpointCalled) &#123;</span><br><span class="line">        doCheckpointCalled = <span class="literal">true</span></span><br><span class="line">        <span class="keyword">if</span> (checkpointData.isDefined) &#123;</span><br><span class="line">          <span class="keyword">if</span> (checkpointAllMarkedAncestors) &#123;</span><br><span class="line">            <span class="comment">// TODO We can collect all the RDDs that needs to be checkpointed, and then checkpoint</span></span><br><span class="line">            <span class="comment">// them in parallel.</span></span><br><span class="line">            <span class="comment">// Checkpoint parents first because our lineage will be truncated after we</span></span><br><span class="line">            <span class="comment">// checkpoint ourselves</span></span><br><span class="line">            dependencies.foreach(_.rdd.doCheckpoint())</span><br><span class="line">          &#125;</span><br><span class="line">          checkpointData.get.checkpoint()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          dependencies.foreach(_.rdd.doCheckpoint())</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;doCheckpoint函数首先会判断 checkpointData 是否被定义，即当前 RDD 是否已经被标记为需要 checkpoint，然后 finalRDD 会顺着依赖关系回溯扫描，先将需要的父 RDD checkpoint。之后调用 checkpointData.get.checkpoint() 对当前 RDD 做 checkpoint 操作。</p><h3 id="2-3-checkpointData-checkpoint"><a href="#2-3-checkpointData-checkpoint" class="headerlink" title="2.3 checkpointData.checkpoint"></a>2.3 checkpointData.checkpoint</h3><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.rdd.RDDCheckpointData</span></span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">checkpoint</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// Guard against multiple threads checkpointing the same RDD by</span></span><br><span class="line">    <span class="comment">// atomically flipping the state of this RDDCheckpointData</span></span><br><span class="line">    <span class="type">RDDCheckpointData</span>.synchronized &#123;</span><br><span class="line">      <span class="keyword">if</span> (cpState == <span class="type">Initialized</span>) &#123;</span><br><span class="line">        cpState = <span class="type">CheckpointingInProgress</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//持久化</span></span><br><span class="line">    <span class="keyword">val</span> newRDD = doCheckpoint()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Update our state and truncate the RDD lineage</span></span><br><span class="line">    <span class="type">RDDCheckpointData</span>.synchronized &#123;</span><br><span class="line">      cpRDD = <span class="type">Some</span>(newRDD)</span><br><span class="line">      cpState = <span class="type">Checkpointed</span></span><br><span class="line">      <span class="comment">//标记，切断依赖关系</span></span><br><span class="line">      rdd.markCheckpointed()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>&emsp;这里首先会将状态修改为 CheckpointingInProgress(正在checkpoint)，然后调用 val newRDD = doCheckpoint() 将 RDD 持久化，之后将状态置为 Checkpointed(已经checkpoint)，最后调用 rdd.markCheckpointed() 将当前 rdd 标志为已经 checkpoint。</p><p>&emsp;这里先讲解 rdd.markCheckpointed()，然后再介绍 doCheckpoint。<br>&emsp;markCheckpointed 会清除所有当前 rdd 的所有依赖信息，切断依赖关系。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">markCheckpointed</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    clearDependencies()</span><br><span class="line">    partitions_ = <span class="literal">null</span></span><br><span class="line">    deps = <span class="literal">null</span>    <span class="comment">// Forget the constructor argument for dependencies too</span></span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">clearDependencies</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    dependencies_ = <span class="literal">null</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>&emsp;RDDCheckpointData 是一个抽象类，checkpointData 在赋值的时候是赋以一个 ReliableRDDCheckpointData 对象，所以这里的 doCheckpoint() 调用的是 ReliableRDDCheckpointData 的 doCheckpoint()函数。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">protected</span> <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doCheckpoint</span></span>(): <span class="type">CheckpointRDD</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> newRDD = <span class="type">ReliableCheckpointRDD</span>.writeRDDToCheckpointDirectory(rdd, cpDir)</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Optionally clean our checkpoint files if the reference is out of scope</span></span><br><span class="line">    <span class="keyword">if</span> (rdd.conf.getBoolean(<span class="string">"spark.cleaner.referenceTracking.cleanCheckpoints"</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">      rdd.context.cleaner.foreach &#123; cleaner =&gt;</span><br><span class="line">        cleaner.registerRDDCheckpointDataForCleanup(newRDD, rdd.id)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    logInfo(<span class="string">s"Done checkpointing RDD <span class="subst">$&#123;rdd.id&#125;</span> to <span class="subst">$cpDir</span>, new parent is RDD <span class="subst">$&#123;newRDD.id&#125;</span>"</span>)</span><br><span class="line">    newRDD</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="2-4-持久化"><a href="#2-4-持久化" class="headerlink" title="2.4 持久化"></a>2.4 持久化</h3><p>&emsp;我们再打开 ReliableCheckpointRDD.writeRDDToCheckpointDirectory 函数，这个函数实现了将 RDD 持久化的操作，最后返回一个新的 ReliableCheckpointRDD 类型的 RDD。<br>&emsp;注意，在这个函数里面，调用了 sc.runJob，启动了一个<strong>专门的 Job</strong> 来完成 Checkpoint，这里的代价是比较大的，会重新计算原来的 RDD。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writeRDDToCheckpointDirectory</span></span>[<span class="type">T</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      originalRDD: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      checkpointDir: <span class="type">String</span>,</span><br><span class="line">      blockSize: <span class="type">Int</span> = <span class="number">-1</span>): <span class="type">ReliableCheckpointRDD</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> checkpointStartTimeNs = <span class="type">System</span>.nanoTime()</span><br><span class="line"></span><br><span class="line">    <span class="comment">//......</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//将写磁盘需要的配置文件（如core-site.xml等）brocast到其他worker节点上的BlockManager</span></span><br><span class="line">    <span class="keyword">val</span> broadcastedConf = sc.broadcast(</span><br><span class="line">      <span class="keyword">new</span> <span class="type">SerializableConfiguration</span>(sc.hadoopConfiguration))</span><br><span class="line">    <span class="comment">// <span class="doctag">TODO:</span> This is expensive because it computes the RDD again unnecessarily (SPARK-8582)</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//启动一个Job来完成Checkpoint</span></span><br><span class="line">    sc.runJob(originalRDD,</span><br><span class="line">      writePartitionToCheckpointFile[<span class="type">T</span>](checkpointDirPath.toString, broadcastedConf) _)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (originalRDD.partitioner.nonEmpty) &#123;</span><br><span class="line">      writePartitionerToCheckpointDir(sc, originalRDD.partitioner.get, checkpointDirPath)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> checkpointDurationMs =</span><br><span class="line">      <span class="type">TimeUnit</span>.<span class="type">NANOSECONDS</span>.toMillis(<span class="type">System</span>.nanoTime() - checkpointStartTimeNs)</span><br><span class="line">    logInfo(<span class="string">s"Checkpointing took <span class="subst">$checkpointDurationMs</span> ms."</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> newRDD = <span class="keyword">new</span> <span class="type">ReliableCheckpointRDD</span>[<span class="type">T</span>](</span><br><span class="line">      sc, checkpointDirPath.toString, originalRDD.partitioner)</span><br><span class="line">    <span class="keyword">if</span> (newRDD.partitions.length != originalRDD.partitions.length) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">SparkException</span>(</span><br><span class="line">        <span class="string">"Checkpoint RDD has a different number of partitions from original RDD. Original "</span> +</span><br><span class="line">          <span class="string">s"RDD [ID: <span class="subst">$&#123;originalRDD.id&#125;</span>, num of partitions: <span class="subst">$&#123;originalRDD.partitions.length&#125;</span>]; "</span> +</span><br><span class="line">          <span class="string">s"Checkpoint RDD [ID: <span class="subst">$&#123;newRDD.id&#125;</span>, num of partitions: "</span> +</span><br><span class="line">          <span class="string">s"<span class="subst">$&#123;newRDD.partitions.length&#125;</span>]."</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    newRDD</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;至此，checkpoint 操作完成。</p><h3 id="2-5-获取RDD"><a href="#2-5-获取RDD" class="headerlink" title="2.5 获取RDD"></a>2.5 获取RDD</h3><p>&emsp;在后面，当需要获取某个 RDD 的数据的时候，系统就会尝试从磁盘中读取数据，获取不到再重新计算。<br>&emsp;我们可以看到，rdd.getOrCompute 函数调用了 computeOrReadCheckpoint 方法，在rdd.computeOrReadCheckpoint方法中，如果看到已经完成 Checkpoint，就直接从 firstParent 中读取数据。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">computeOrReadCheckpoint</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] =</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">if</span> (isCheckpointedAndMaterialized) &#123;</span><br><span class="line">      firstParent[<span class="type">T</span>].iterator(split, context)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      compute(split, context)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">isCheckpointedAndMaterialized</span></span>: <span class="type">Boolean</span> =</span><br><span class="line">    checkpointData.exists(_.isCheckpointed)</span><br></pre></td></tr></table></figure><br>firstParent 其实就是当前 RDD 的第一个父 RDD，iterator 就会尝试通过 blockManager 从磁盘读取数据<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Returns the first parent RDD */</span></span><br><span class="line">  <span class="keyword">protected</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">firstParent</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>]: <span class="type">RDD</span>[<span class="type">U</span>] = &#123;</span><br><span class="line">    dependencies.head.rdd.asInstanceOf[<span class="type">RDD</span>[<span class="type">U</span>]]</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">final</span> <span class="function"><span class="keyword">def</span> <span class="title">iterator</span></span>(split: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">    <span class="keyword">if</span> (storageLevel != <span class="type">StorageLevel</span>.<span class="type">NONE</span>) &#123;</span><br><span class="line">      getOrCompute(split, context)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      computeOrReadCheckpoint(split, context)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>[spark] <span class="function"><span class="keyword">def</span> <span class="title">getOrCompute</span></span>(partition: <span class="type">Partition</span>, context: <span class="type">TaskContext</span>): <span class="type">Iterator</span>[<span class="type">T</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> blockId = <span class="type">RDDBlockId</span>(id, partition.index)</span><br><span class="line">    <span class="keyword">var</span> readCachedBlock = <span class="literal">true</span></span><br><span class="line">    <span class="comment">// This method is called on executors, so we need call SparkEnv.get instead of sc.env.</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//尝试通过blockManager从磁盘读取</span></span><br><span class="line">    <span class="type">SparkEnv</span>.get.blockManager.getOrElseUpdate(blockId, storageLevel, elementClassTag, () =&gt; &#123;</span><br><span class="line">      readCachedBlock = <span class="literal">false</span></span><br><span class="line">      computeOrReadCheckpoint(partition, context)</span><br><span class="line">    &#125;) <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Left</span>(blockResult) =&gt;</span><br><span class="line">        <span class="keyword">if</span> (readCachedBlock) &#123;</span><br><span class="line">          <span class="keyword">val</span> existingMetrics = context.taskMetrics().inputMetrics</span><br><span class="line">          existingMetrics.incBytesRead(blockResult.bytes)</span><br><span class="line">          <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>[<span class="type">T</span>](context, blockResult.data.asInstanceOf[<span class="type">Iterator</span>[<span class="type">T</span>]]) &#123;</span><br><span class="line">            <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">next</span></span>(): <span class="type">T</span> = &#123;</span><br><span class="line">              existingMetrics.incRecordsRead(<span class="number">1</span>)</span><br><span class="line">              delegate.next()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, blockResult.data.asInstanceOf[<span class="type">Iterator</span>[<span class="type">T</span>]])</span><br><span class="line">        &#125;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Right</span>(iter) =&gt;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">InterruptibleIterator</span>(context, iter.asInstanceOf[<span class="type">Iterator</span>[<span class="type">T</span>]])</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3.总结"></a>3.总结</h2><p>&emsp;下面总结 checkpoint 机制的完整流程：</p><ol><li>用户程序调用rdd.checkpoint(),将当前 rdd 标志为需要 checkpoint；</li><li>action 算子触发 sc.runJob()，runJob 调用 rdd.doCheckpoint()，触发 checkpoint 操作；</li><li>ReliableRDDCheckpointData 启动一个专门的 Job 完成 RDD 的持久化操作；</li><li>持久化完成之后，当前 RDD 会清除所有依赖信息，切断依赖关系，结束 checkpoint。</li></ol><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-fault-tolerant/">http://zhoujiapeng.top/Spark/spark-fault-tolerant/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark源码阅读 之 Spark 作业和调度</title>
      <link href="/Spark/spark-job/"/>
      <url>/Spark/spark-job/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-作业和调度"><a href="#Spark-作业和调度" class="headerlink" title="Spark 作业和调度"></a>Spark 作业和调度</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><p>&emsp;Spark 应用程序由 driver program 和在 Executor 内执行的代码两部分组成，Spark的作业调度主要说的就是这些基于 RDD 的一系列操作算子构成一个 Job，然后在Executor中执行。操作算子分为 transformation 算子和 action 算子，transformation 算子是 lazy 的，即延迟执行，只有出现 action才会真正触发 Job 的提交和调度执行。</p><h2 id="1-作业-Job-提交"><a href="#1-作业-Job-提交" class="headerlink" title="1.作业(Job)提交"></a>1.作业(Job)提交</h2><p>&emsp;以单词计数程序为例：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> line = sc.textFile(<span class="string">"README.md"</span>)</span><br><span class="line"><span class="keyword">val</span> wordcout = line.flatMap(_.split(<span class="string">""</span>)).map(x=&gt;(x,<span class="number">1</span>)).reduceByKey(_+_).count()</span><br></pre></td></tr></table></figure><br>&emsp;这个Job的真正执行是 count() 这个 action 算子触发的，打开该方法，可以看到这个方法调用了 SparkContext.runJob 方法来提交作业：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">count</span></span>(): <span class="type">Long</span> = sc.runJob(<span class="keyword">this</span>, <span class="type">Utils</span>.getIteratorSize _).sum</span><br></pre></td></tr></table></figure><br>&emsp;对于 RDD 来说，它们会根据彼此之间的依赖关系形成一个DAG有向无环图,然后把这DAG图交给DAGScheduler来处理。SparkContext.runJob 经过几次回调之后会调用 DAGScheduler 的 runJob 方法，这时作业提交就进入了 DAGScheduler 的处理阶段。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.SparkContext</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runJob</span></span>[<span class="type">T</span>, <span class="type">U</span>: <span class="type">ClassTag</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">      resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (stopped.get()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">"SparkContext has been shutdown"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">val</span> callSite = getCallSite</span><br><span class="line">    <span class="keyword">val</span> cleanedFunc = clean(func)</span><br><span class="line">    logInfo(<span class="string">"Starting job: "</span> + callSite.shortForm)</span><br><span class="line">    <span class="keyword">if</span> (conf.getBoolean(<span class="string">"spark.logLineage"</span>, <span class="literal">false</span>)) &#123;</span><br><span class="line">      logInfo(<span class="string">"RDD's recursive dependencies:\n"</span> + rdd.toDebugString)</span><br><span class="line">    &#125;</span><br><span class="line">    dagScheduler.runJob(rdd, cleanedFunc, partitions, callSite, resultHandler, localProperties.get)</span><br><span class="line">    progressBar.foreach(_.finishAll())</span><br><span class="line">    rdd.doCheckpoint()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="2-DAGScheduler划分Stage并提交"><a href="#2-DAGScheduler划分Stage并提交" class="headerlink" title="2.DAGScheduler划分Stage并提交"></a>2.DAGScheduler划分Stage并提交</h2><p>&emsp;DAGScheduler 是面向 Stage 的任务调度器，负责接收 Spark 应用提交的 Job，并根据 RDD 的依赖关系划分 Stage，并提交 Stage 给 TaskScheduler 调度器。<br>&emsp;下面是 DAGScheduler 的 runJob 方法实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">runJob</span></span>[<span class="type">T</span>, <span class="type">U</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">      callSite: <span class="type">CallSite</span>,</span><br><span class="line">      resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>,</span><br><span class="line">      properties: <span class="type">Properties</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> start = <span class="type">System</span>.nanoTime</span><br><span class="line">    <span class="keyword">val</span> waiter = submitJob(rdd, func, partitions, callSite, resultHandler, properties)</span><br><span class="line">    <span class="type">ThreadUtils</span>.awaitReady(waiter.completionFuture, <span class="type">Duration</span>.<span class="type">Inf</span>)</span><br><span class="line">    waiter.completionFuture.value.get <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> scala.util.<span class="type">Success</span>(_) =&gt;</span><br><span class="line">        logInfo(<span class="string">"Job %d finished: %s, took %f s"</span>.format</span><br><span class="line">          (waiter.jobId, callSite.shortForm, (<span class="type">System</span>.nanoTime - start) / <span class="number">1e9</span>))</span><br><span class="line">      <span class="keyword">case</span> scala.util.<span class="type">Failure</span>(exception) =&gt;</span><br><span class="line">        logInfo(<span class="string">"Job %d failed: %s, took %f s"</span>.format</span><br><span class="line">          (waiter.jobId, callSite.shortForm, (<span class="type">System</span>.nanoTime - start) / <span class="number">1e9</span>))</span><br><span class="line">        <span class="comment">// SPARK-8644: Include user stack trace in exceptions coming from DAGScheduler.</span></span><br><span class="line">        <span class="keyword">val</span> callerStackTrace = <span class="type">Thread</span>.currentThread().getStackTrace.tail</span><br><span class="line">        exception.setStackTrace(exception.getStackTrace ++ callerStackTrace)</span><br><span class="line">        <span class="keyword">throw</span> exception</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>调用了 submitJob 方法来提交作业，这里会发生阻塞，等待作业完成。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">submitJob</span></span>[<span class="type">T</span>, <span class="type">U</span>](</span><br><span class="line">      rdd: <span class="type">RDD</span>[<span class="type">T</span>],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[<span class="type">T</span>]) =&gt; <span class="type">U</span>,</span><br><span class="line">      partitions: <span class="type">Seq</span>[<span class="type">Int</span>],</span><br><span class="line">      callSite: <span class="type">CallSite</span>,</span><br><span class="line">      resultHandler: (<span class="type">Int</span>, <span class="type">U</span>) =&gt; <span class="type">Unit</span>,</span><br><span class="line">      properties: <span class="type">Properties</span>): <span class="type">JobWaiter</span>[<span class="type">U</span>] = &#123;</span><br><span class="line">    <span class="comment">// Check to make sure we are not launching a task on a partition that does not exist.</span></span><br><span class="line">    </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    assert(partitions.size &gt; <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">val</span> func2 = func.asInstanceOf[(<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _]</span><br><span class="line">    <span class="keyword">val</span> waiter = <span class="keyword">new</span> <span class="type">JobWaiter</span>(<span class="keyword">this</span>, jobId, partitions.size, resultHandler)</span><br><span class="line">    eventProcessLoop.post(<span class="type">JobSubmitted</span>(</span><br><span class="line">      jobId, rdd, func2, partitions.toArray, callSite, waiter,</span><br><span class="line">      <span class="type">SerializationUtils</span>.clone(properties)))</span><br><span class="line">    waiter</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>submitJob 创建了 JobWaiter 对象，并发送 JobSubmitted 消息给 DAGScheduler 内嵌的 DAGSchedulerEventProcessLoop 类对象 eventProcessLoop 进行处理:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.DAGSchedulerEventProcessLoop</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">doOnReceive</span></span>(event: <span class="type">DAGSchedulerEvent</span>): <span class="type">Unit</span> = event <span class="keyword">match</span> &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">JobSubmitted</span>(jobId, rdd, func, partitions, callSite, listener, properties) =&gt;</span><br><span class="line">      dagScheduler.handleJobSubmitted(jobId, rdd, func, partitions, callSite, listener, properties)</span><br><span class="line"></span><br><span class="line">      ...</span><br></pre></td></tr></table></figure><br>handleJobSubmitted 方法是个很关键的方法，在其内部会根据 finalRDD 构建一个 Stage，这也意味着 Stage 划分的开始，最后调用 submitStage 方法来提交这个 Stage<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[scheduler] <span class="function"><span class="keyword">def</span> <span class="title">handleJobSubmitted</span></span>(jobId: <span class="type">Int</span>,</span><br><span class="line">      finalRDD: <span class="type">RDD</span>[_],</span><br><span class="line">      func: (<span class="type">TaskContext</span>, <span class="type">Iterator</span>[_]) =&gt; _,</span><br><span class="line">      partitions: <span class="type">Array</span>[<span class="type">Int</span>],</span><br><span class="line">      callSite: <span class="type">CallSite</span>,</span><br><span class="line">      listener: <span class="type">JobListener</span>,</span><br><span class="line">      properties: <span class="type">Properties</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> finalStage: <span class="type">ResultStage</span> = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// New stage creation may throw an exception if, for example, jobs are run on a</span></span><br><span class="line">      <span class="comment">// HadoopRDD whose underlying HDFS files have been deleted.</span></span><br><span class="line">      finalStage = createResultStage(finalRDD, func, partitions, jobId, callSite)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      </span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    finalStage.setActiveJob(job)</span><br><span class="line">    <span class="keyword">val</span> stageIds = jobIdToStageIds(jobId).toArray</span><br><span class="line">    <span class="keyword">val</span> stageInfos = stageIds.flatMap(id =&gt; stageIdToStage.get(id).map(_.latestInfo))</span><br><span class="line">    listenerBus.post(</span><br><span class="line">      <span class="type">SparkListenerJobStart</span>(job.jobId, jobSubmissionTime, stageInfos, properties))</span><br><span class="line">    submitStage(finalStage)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>finalRDD 是这 RDD 依赖链的最后一个RDD，即 action 触发作业提交的那个RDD，这里的 finalStage 并不是切分好的 Stage，是根据 finalRDD 生成的一个跟当前作业关联的一个 Stage，后续要使用 finalStage 来进行 Stage 的切分，即 submitStage 方法：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.DAGScheduler</span></span><br><span class="line"><span class="comment">/** Submits stage, but first recursively submits any missing parents. */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submitStage</span></span>(stage: <span class="type">Stage</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> jobId = activeJobForStage(stage)</span><br><span class="line">    <span class="keyword">if</span> (jobId.isDefined) &#123;</span><br><span class="line">      logDebug(<span class="string">"submitStage("</span> + stage + <span class="string">")"</span>)</span><br><span class="line">      <span class="keyword">if</span> (!waitingStages(stage) &amp;&amp; !runningStages(stage) &amp;&amp; !failedStages(stage)) &#123;</span><br><span class="line">        <span class="keyword">val</span> missing = getMissingParentStages(stage).sortBy(_.id)</span><br><span class="line">        logDebug(<span class="string">"missing: "</span> + missing)</span><br><span class="line">        <span class="keyword">if</span> (missing.isEmpty) &#123;</span><br><span class="line">          logInfo(<span class="string">"Submitting "</span> + stage + <span class="string">" ("</span> + stage.rdd + <span class="string">"), which has no missing parents"</span>)</span><br><span class="line">          submitMissingTasks(stage, jobId.get)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">for</span> (parent &lt;- missing) &#123;</span><br><span class="line">            submitStage(parent)</span><br><span class="line">          &#125;</span><br><span class="line">          waitingStages += stage</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      abortStage(stage, <span class="string">"No active job for stage "</span> + stage.id, <span class="type">None</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;submitStage 会根据依赖关系划分 Stage，通过递归调用从 finalStage 一直往前找到它的父 Stage，直到 Stage 没有父 Stage（missing.isEmpty 为 true） 时就调用 submitMissingTasks 方法提交 Stage 执行该 Stage 中的 tasks；如果有父 Stage，即 missing 不为空，则遍历 missing，回调当前 Stage 的所有父 Stage submitStage(parent)，然后将当前 Stage被放入 waitingStages 中，等待以后执行 (后面 submitMissingTasks 会介绍)。通过这种方式将 job 划分为一个或者多个 Stage，并且能够保证父 Stage 比子 Stage 先执行其中的任务。&nbsp;<br>&emsp;这里有两个关键的函数，getMissingParentStages 和 submitMissingTasks，下面具体介绍这两个函数。&nbsp;<br>&emsp;getMissingParentStages 会根据传入的 Stage 中的 finalRDD 的 dependence 类型来创建它的父 Stage。这里以是否为 ShuffleDependency(宽依赖) 作为划分 Stage 的 界限，如果 RDD 的依赖是宽依赖，说明已经找到当前 Stage 的边界，可以进行切分，则调用 getOrCreateShuffleMapStage 生成该 Stage 的父 Stage；如果是窄依赖，则压入 waitingForVisit 栈顶，等待下一次调用 visit 方法时回溯。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">getMissingParentStages</span></span>(stage: <span class="type">Stage</span>): <span class="type">List</span>[<span class="type">Stage</span>] = &#123;</span><br><span class="line">    <span class="keyword">val</span> missing = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">Stage</span>]</span><br><span class="line">    <span class="keyword">val</span> visited = <span class="keyword">new</span> <span class="type">HashSet</span>[<span class="type">RDD</span>[_]]</span><br><span class="line">    <span class="comment">// We are manually maintaining a stack here to prevent StackOverflowError</span></span><br><span class="line">    <span class="comment">// caused by recursively visiting</span></span><br><span class="line">    <span class="keyword">val</span> waitingForVisit = <span class="keyword">new</span> <span class="type">ArrayStack</span>[<span class="type">RDD</span>[_]]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">visit</span></span>(rdd: <span class="type">RDD</span>[_]) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!visited(rdd)) &#123;</span><br><span class="line">        visited += rdd</span><br><span class="line">        <span class="keyword">val</span> rddHasUncachedPartitions = getCacheLocs(rdd).contains(<span class="type">Nil</span>)</span><br><span class="line">        <span class="keyword">if</span> (rddHasUncachedPartitions) &#123;</span><br><span class="line">          <span class="keyword">for</span> (dep &lt;- rdd.dependencies) &#123;</span><br><span class="line">            dep <span class="keyword">match</span> &#123;</span><br><span class="line">              <span class="keyword">case</span> shufDep: <span class="type">ShuffleDependency</span>[_, _, _] =&gt;</span><br><span class="line">                <span class="keyword">val</span> mapStage = getOrCreateShuffleMapStage(shufDep, stage.firstJobId)</span><br><span class="line">                <span class="keyword">if</span> (!mapStage.isAvailable) &#123;</span><br><span class="line">                  missing += mapStage</span><br><span class="line">                &#125;</span><br><span class="line">              <span class="keyword">case</span> narrowDep: <span class="type">NarrowDependency</span>[_] =&gt;</span><br><span class="line">                waitingForVisit.push(narrowDep.rdd)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    waitingForVisit.push(stage.rdd)</span><br><span class="line">    <span class="keyword">while</span> (waitingForVisit.nonEmpty) &#123;</span><br><span class="line">      visit(waitingForVisit.pop())</span><br><span class="line">    &#125;</span><br><span class="line">    missing.toList</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;submitMissingTasks 会提交当前切分好的 Stage 并执行其中的任务。submitMissingTasks 中将 Stage 封装成 TaskSet 通过 taskScheduler.submitTasks 提交给 TaskScheduler 处理。&nbsp;<br>&emsp;另外，submitMissingTasks 会首先生成 Tasks 的具体执行位置，然后在根据这些位置创建 TaskSet。Task 有两种类型，ShuffleMapStage 和 ResultStage，ShuffleMapStage 会根据 Stage 所依赖的 RDD 的partition 分布产生和 partition 数量相等的 Task，这些 Task 根据 partition 的 locality 进行分布。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submitMissingTasks</span></span>(stage: <span class="type">Stage</span>, jobId: <span class="type">Int</span>) &#123;</span><br><span class="line">    logDebug(<span class="string">"submitMissingTasks("</span> + stage + <span class="string">")"</span>)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> taskIdToLocations: <span class="type">Map</span>[<span class="type">Int</span>, <span class="type">Seq</span>[<span class="type">TaskLocation</span>]] = <span class="keyword">try</span> &#123;</span><br><span class="line">      stage <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> s: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt; (id, getPreferredLocs(stage.rdd, id))&#125;.toMap</span><br><span class="line">        <span class="keyword">case</span> s: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> p = s.partitions(id)</span><br><span class="line">            (id, getPreferredLocs(stage.rdd, p))</span><br><span class="line">          &#125;.toMap</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> tasks: <span class="type">Seq</span>[<span class="type">Task</span>[_]] = <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> serializedTaskMetrics = closureSerializer.serialize(stage.latestInfo.taskMetrics).array()</span><br><span class="line">      stage <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ShuffleMapStage</span> =&gt;</span><br><span class="line">          stage.pendingPartitions.clear()</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">            <span class="keyword">val</span> part = partitions(id)</span><br><span class="line">            stage.pendingPartitions += id</span><br><span class="line">            <span class="keyword">new</span> <span class="type">ShuffleMapTask</span>(stage.id, stage.latestInfo.attemptNumber,</span><br><span class="line">              taskBinary, part, locs, properties, serializedTaskMetrics, <span class="type">Option</span>(jobId),</span><br><span class="line">              <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId, stage.rdd.isBarrier())</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> stage: <span class="type">ResultStage</span> =&gt;</span><br><span class="line">          partitionsToCompute.map &#123; id =&gt;</span><br><span class="line">            <span class="keyword">val</span> p: <span class="type">Int</span> = stage.partitions(id)</span><br><span class="line">            <span class="keyword">val</span> part = partitions(p)</span><br><span class="line">            <span class="keyword">val</span> locs = taskIdToLocations(id)</span><br><span class="line">            <span class="keyword">new</span> <span class="type">ResultTask</span>(stage.id, stage.latestInfo.attemptNumber,</span><br><span class="line">              taskBinary, part, locs, id, properties, serializedTaskMetrics,</span><br><span class="line">              <span class="type">Option</span>(jobId), <span class="type">Option</span>(sc.applicationId), sc.applicationAttemptId,</span><br><span class="line">              stage.rdd.isBarrier())</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt;</span><br><span class="line">        abortStage(stage, <span class="string">s"Task creation failed: <span class="subst">$e</span>\n<span class="subst">$&#123;Utils.exceptionString(e)&#125;</span>"</span>, <span class="type">Some</span>(e))</span><br><span class="line">        runningStages -= stage</span><br><span class="line">        <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (tasks.size &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      logInfo(<span class="string">s"Submitting <span class="subst">$&#123;tasks.size&#125;</span> missing tasks from <span class="subst">$stage</span> (<span class="subst">$&#123;stage.rdd&#125;</span>) (first 15 "</span> +</span><br><span class="line">        <span class="string">s"tasks are for partitions <span class="subst">$&#123;tasks.take(15).map(_.partitionId)&#125;</span>)"</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">//提交任务</span></span><br><span class="line">      taskScheduler.submitTasks(<span class="keyword">new</span> <span class="type">TaskSet</span>(</span><br><span class="line">        tasks.toArray, stage.id, stage.latestInfo.attemptNumber, jobId, properties))</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      </span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">      submitWaitingChildStages(stage)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>&emsp;当前 Stage 的 Task 提交之后，最后执行 submitWaitingChildStages(stage)，这里会从之前放入 waitingStages 的 Stage 中过滤出属于当前 Stage 的子 Stage，继续调用 submitStage。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">submitWaitingChildStages</span></span>(parent: <span class="type">Stage</span>) &#123;</span><br><span class="line">    logTrace(<span class="string">s"Checking if any dependencies of <span class="subst">$parent</span> are now runnable"</span>)</span><br><span class="line">    logTrace(<span class="string">"running: "</span> + runningStages)</span><br><span class="line">    logTrace(<span class="string">"waiting: "</span> + waitingStages)</span><br><span class="line">    logTrace(<span class="string">"failed: "</span> + failedStages)</span><br><span class="line">    <span class="keyword">val</span> childStages = waitingStages.filter(_.parents.contains(parent)).toArray</span><br><span class="line">    waitingStages --= childStages</span><br><span class="line">    <span class="keyword">for</span> (stage &lt;- childStages.sortBy(_.firstJobId)) &#123;</span><br><span class="line">      submitStage(stage)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="3-TaskScheduler提交Task"><a href="#3-TaskScheduler提交Task" class="headerlink" title="3.TaskScheduler提交Task"></a>3.TaskScheduler提交Task</h2><p>&emsp;前面 DAGScheduler 调用 taskScheduler.submitTasks，将 Task 提交给 TaskScheduler 去处理。TaskSchedulerImpl(TaskScheduler的实现子类) 会初始化一个 TaskSetManager 对其生命周期进行管理，当 TaskSchedulerImpl 得到 Worker 节点上 Executor 计算资源的时候，会通过 TaskSetManager 来发送具体的 Task 到　Executor 上执行计算。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.TaskSchedulerImpl</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">submitTasks</span></span>(taskSet: <span class="type">TaskSet</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> tasks = taskSet.tasks</span><br><span class="line">    logInfo(<span class="string">"Adding task set "</span> + taskSet.id + <span class="string">" with "</span> + tasks.length + <span class="string">" tasks"</span>)</span><br><span class="line">    <span class="keyword">this</span>.synchronized &#123;</span><br><span class="line">      <span class="keyword">val</span> manager = createTaskSetManager(taskSet, maxTaskFailures)</span><br><span class="line">      <span class="keyword">val</span> stage = taskSet.stageId</span><br><span class="line">      <span class="keyword">val</span> stageTaskSets =</span><br><span class="line">        taskSetsByStageIdAndAttempt.getOrElseUpdate(stage, <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">Int</span>, <span class="type">TaskSetManager</span>])</span><br><span class="line">      stageTaskSets(taskSet.stageAttemptId) = manager</span><br><span class="line">      <span class="keyword">val</span> conflictingTaskSet = stageTaskSets.exists &#123; <span class="keyword">case</span> (_, ts) =&gt;</span><br><span class="line">        ts.taskSet != taskSet &amp;&amp; !ts.isZombie</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> (conflictingTaskSet) &#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalStateException</span>(<span class="string">s"more than one active taskSet for stage <span class="subst">$stage</span>:"</span> +</span><br><span class="line">          <span class="string">s" <span class="subst">$&#123;stageTaskSets.toSeq.map&#123;_._2.taskSet.id&#125;</span>.mkString("</span>,<span class="string">")&#125;"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      schedulableBuilder.addTaskSetManager(manager, manager.taskSet.properties)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (!isLocal &amp;&amp; !hasReceivedTask) &#123;</span><br><span class="line">        starvationTimer.scheduleAtFixedRate(<span class="keyword">new</span> <span class="type">TimerTask</span>() &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123;</span><br><span class="line">            <span class="keyword">if</span> (!hasLaunchedTask) &#123;</span><br><span class="line">              logWarning(<span class="string">"Initial job has not accepted any resources; "</span> +</span><br><span class="line">                <span class="string">"check your cluster UI to ensure that workers are registered "</span> +</span><br><span class="line">                <span class="string">"and have sufficient resources"</span>)</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">              <span class="keyword">this</span>.cancel()</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;, <span class="type">STARVATION_TIMEOUT_MS</span>, <span class="type">STARVATION_TIMEOUT_MS</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      hasReceivedTask = <span class="literal">true</span></span><br><span class="line">    &#125;</span><br><span class="line">    backend.reviveOffers()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>最后调用 backend.reviveOffers(),进行计算资源的分配并启动 Task，这里的 backend 是 StandaloneSchedulerBackend ，它直接从父类 CoarseGrainedSchedulerBackend 继承 reviveOffers 方法。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.cluster.CoarseGrainedSchedulerBackend</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">reviveOffers</span></span>() &#123;</span><br><span class="line">    driverEndpoint.send(<span class="type">ReviveOffers</span>)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>这里会向 driver 发送 ReviveOffers 消息,从 driverEndpoint 的初始化可以看到实际上接收并处理消息的类是 CoarseGrainedSchedulerBackend 的内嵌类 DriverEndpoint。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.cluster.CoarseGrainedSchedulerBackend</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line">    <span class="keyword">val</span> properties = <span class="keyword">new</span> <span class="type">ArrayBuffer</span>[(<span class="type">String</span>, <span class="type">String</span>)]</span><br><span class="line">    <span class="keyword">for</span> ((key, value) &lt;- scheduler.sc.conf.getAll) &#123;</span><br><span class="line">      <span class="keyword">if</span> (key.startsWith(<span class="string">"spark."</span>)) &#123;</span><br><span class="line">        properties += ((key, value))</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// TODO (prashant) send conf instead of properties</span></span><br><span class="line">    driverEndpoint = createDriverEndpointRef(properties)</span><br><span class="line">  &#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">createDriverEndpointRef</span></span>(</span><br><span class="line">    properties: <span class="type">ArrayBuffer</span>[(<span class="type">String</span>, <span class="type">String</span>)]): <span class="type">RpcEndpointRef</span> = &#123;</span><br><span class="line">    rpcEnv.setupEndpoint(<span class="type">ENDPOINT_NAME</span>, createDriverEndpoint(properties))</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">createDriverEndpoint</span></span>(properties: <span class="type">Seq</span>[(<span class="type">String</span>, <span class="type">String</span>)]): <span class="type">DriverEndpoint</span> = &#123;</span><br><span class="line">    <span class="keyword">new</span> <span class="type">DriverEndpoint</span>(rpcEnv, properties)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>我们看一下处理消息的逻辑：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ReviveOffers</span> =&gt;</span><br><span class="line">        makeOffers()</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Make fake resource offers on all executors</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">makeOffers</span></span>() &#123;</span><br><span class="line">    <span class="comment">// Make sure no executor is killed while some task is launching on it</span></span><br><span class="line">    <span class="keyword">val</span> taskDescs = <span class="type">CoarseGrainedSchedulerBackend</span>.<span class="keyword">this</span>.synchronized &#123;</span><br><span class="line">    <span class="comment">// Filter out executors under killing</span></span><br><span class="line">    <span class="keyword">val</span> activeExecutors = executorDataMap.filterKeys(executorIsAlive)</span><br><span class="line">    <span class="keyword">val</span> workOffers = activeExecutors.map &#123;</span><br><span class="line">        <span class="keyword">case</span> (id, executorData) =&gt;</span><br><span class="line">            <span class="keyword">new</span> <span class="type">WorkerOffer</span>(id, executorData.executorHost, executorData.freeCores,</span><br><span class="line">              <span class="type">Some</span>(executorData.executorAddress.hostPort))</span><br><span class="line">    &#125;.toIndexedSeq</span><br><span class="line">        scheduler.resourceOffers(workOffers)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!taskDescs.isEmpty) &#123;</span><br><span class="line">        launchTasks(taskDescs)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Launch tasks returned by a set of resource offers</span></span><br><span class="line">    <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">launchTasks</span></span>(tasks: <span class="type">Seq</span>[<span class="type">Seq</span>[<span class="type">TaskDescription</span>]]) &#123;</span><br><span class="line">      <span class="keyword">for</span> (task &lt;- tasks.flatten) &#123;</span><br><span class="line">        <span class="keyword">val</span> serializedTask = <span class="type">TaskDescription</span>.encode(task)</span><br><span class="line">        <span class="keyword">if</span> (serializedTask.limit() &gt;= maxRpcMessageSize) &#123;</span><br><span class="line">          <span class="type">Option</span>(scheduler.taskIdToTaskSetManager.get(task.taskId)).foreach &#123; taskSetMgr =&gt;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">              <span class="keyword">var</span> msg = <span class="string">"Serialized task %s:%d was %d bytes, which exceeds max allowed: "</span> +</span><br><span class="line">                <span class="string">"spark.rpc.message.maxSize (%d bytes). Consider increasing "</span> +</span><br><span class="line">                <span class="string">"spark.rpc.message.maxSize or using broadcast variables for large values."</span></span><br><span class="line">              msg = msg.format(task.taskId, task.index, serializedTask.limit(), maxRpcMessageSize)</span><br><span class="line">              taskSetMgr.abort(msg)</span><br><span class="line">            &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">              <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt; logError(<span class="string">"Exception in error callback"</span>, e)</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">val</span> executorData = executorDataMap(task.executorId)</span><br><span class="line">          executorData.freeCores -= scheduler.<span class="type">CPUS_PER_TASK</span></span><br><span class="line"></span><br><span class="line">          logDebug(<span class="string">s"Launching task <span class="subst">$&#123;task.taskId&#125;</span> on executor id: <span class="subst">$&#123;task.executorId&#125;</span> hostname: "</span> +</span><br><span class="line">            <span class="string">s"<span class="subst">$&#123;executorData.executorHost&#125;</span>."</span>)</span><br><span class="line"></span><br><span class="line">          executorData.executorEndpoint.send(<span class="type">LaunchTask</span>(<span class="keyword">new</span> <span class="type">SerializableBuffer</span>(serializedTask)))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">`</span><br></pre></td></tr></table></figure><br>&emsp;scheduler.resourceOffers(workOffers) 会申请分配计算所需要的资源，最后调用launchTasks(taskDescs)启动任务。&nbsp;<br>&emsp;在 launchTasks 中，会根据申请的资源用 for 循环把 Task 一个个发送到Worker节点上的 CoarseGrainedSchedulerBackend 内部的 Executor 来执行 Task。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//CoarseGrainedSchedulerBackend中的Executor集合</span></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">val</span> executorDataMap = <span class="keyword">new</span> <span class="type">HashMap</span>[<span class="type">String</span>, <span class="type">ExecutorData</span>]</span><br></pre></td></tr></table></figure></p><h2 id="4-Executor运行Task并返回结果"><a href="#4-Executor运行Task并返回结果" class="headerlink" title="4.Executor运行Task并返回结果"></a>4.Executor运行Task并返回结果</h2><p>&emsp;打开Executor的LaunchTask方法,这里使用TaskRunner来管理Task运行时的所有细节，然后把TaskRunner对象放到Java的threadPool去执行。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">launchTask</span></span>(context: <span class="type">ExecutorBackend</span>, taskDescription: <span class="type">TaskDescription</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> tr = <span class="keyword">new</span> <span class="type">TaskRunner</span>(context, taskDescription)</span><br><span class="line">    runningTasks.put(taskDescription.taskId, tr)</span><br><span class="line">    threadPool.execute(tr)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>查看TaskRunner的run方法，首先会将Driver端发送过来的Task本身和它所依赖的Jar等文件反序列化<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line">        <span class="comment">//反序列化</span></span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">// Must be set before updateDependencies() is called, in case fetching dependencies</span></span><br><span class="line">        <span class="comment">// requires access to properties contained within (e.g. for access control).</span></span><br><span class="line">        <span class="type">Executor</span>.taskDeserializationProps.set(taskDescription.properties)</span><br><span class="line"></span><br><span class="line">        updateDependencies(taskDescription.addedFiles, taskDescription.addedJars)</span><br><span class="line">        task = ser.deserialize[<span class="type">Task</span>[<span class="type">Any</span>]](</span><br><span class="line">          taskDescription.serializedTask, <span class="type">Thread</span>.currentThread.getContextClassLoader)</span><br><span class="line">        task.localProperties = taskDescription.properties</span><br><span class="line">        task.setTaskMemoryManager(taskMemoryManager)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//运行Task</span></span><br><span class="line">    <span class="keyword">val</span> value = <span class="type">Utils</span>.tryWithSafeFinally &#123;</span><br><span class="line">          <span class="keyword">val</span> res = task.run(</span><br><span class="line">            taskAttemptId = taskId,</span><br><span class="line">            attemptNumber = taskDescription.attemptNumber,</span><br><span class="line">            metricsSystem = env.metricsSystem)</span><br><span class="line">          threwException = <span class="literal">false</span></span><br><span class="line">          res</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">    <span class="comment">//判断执行结果是否符合要求</span></span><br><span class="line">    <span class="keyword">val</span> serializedResult: <span class="type">ByteBuffer</span> = &#123;</span><br><span class="line">        <span class="comment">//如果结果大于１G，则丢弃这个结果</span></span><br><span class="line">          <span class="keyword">if</span> (maxResultSize &gt; <span class="number">0</span> &amp;&amp; resultSize &gt; maxResultSize) &#123;</span><br><span class="line">            logWarning(<span class="string">s"Finished <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>). Result is larger than maxResultSize "</span> +</span><br><span class="line">              <span class="string">s"(<span class="subst">$&#123;Utils.bytesToString(resultSize)&#125;</span> &gt; <span class="subst">$&#123;Utils.bytesToString(maxResultSize)&#125;</span>), "</span> +</span><br><span class="line">              <span class="string">s"dropping it."</span>)</span><br><span class="line">            ser.serialize(<span class="keyword">new</span> <span class="type">IndirectTaskResult</span>[<span class="type">Any</span>](<span class="type">TaskResultBlockId</span>(taskId), resultSize))</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (resultSize &gt; maxDirectResultSize) &#123;</span><br><span class="line">            <span class="keyword">val</span> blockId = <span class="type">TaskResultBlockId</span>(taskId)</span><br><span class="line">            env.blockManager.putBytes(</span><br><span class="line">              blockId,</span><br><span class="line">              <span class="keyword">new</span> <span class="type">ChunkedByteBuffer</span>(serializedDirectResult.duplicate()),</span><br><span class="line">              <span class="type">StorageLevel</span>.<span class="type">MEMORY_AND_DISK_SER</span>)</span><br><span class="line">            logInfo(</span><br><span class="line">              <span class="string">s"Finished <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>). <span class="subst">$resultSize</span> bytes result sent via BlockManager)"</span>)</span><br><span class="line">            ser.serialize(<span class="keyword">new</span> <span class="type">IndirectTaskResult</span>[<span class="type">Any</span>](blockId, resultSize))</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            logInfo(<span class="string">s"Finished <span class="subst">$taskName</span> (TID <span class="subst">$taskId</span>). <span class="subst">$resultSize</span> bytes result sent to driver"</span>)</span><br><span class="line">            serializedDirectResult</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将 Task 的执行状态汇报给 Driver</span></span><br><span class="line">        setTaskFinishedAndClearInterruptStatus()</span><br><span class="line">        execBackend.statusUpdate(taskId, <span class="type">TaskState</span>.<span class="type">FINISHED</span>, serializedResult)</span><br></pre></td></tr></table></figure><br>&emsp;Task 的运行是调用 task.run 方法实现的，task.run 的方法内部会调用 Task.runTask　方法。Task是一个抽象类，它有两个实现子类 ShuffleMapTask 和 ResultTask。&nbsp;<br>&emsp;对于 ShuffleMapTask 而言，它的结果会写到 BlockManager 之中，最终返回给　DAGScheduler 的是一个 MapStatus 对象，该对象管理了 ShuffleMapTask 的运算结果储存到 BlockManager 里的相关储存信息，而不是计算结果，这些储存信息会成为下一阶段的 Task 需要获得的输入数据的依据。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.ShuffleMapTask</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">runTask</span></span>(context: <span class="type">TaskContext</span>): <span class="type">MapStatus</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> writer: <span class="type">ShuffleWriter</span>[<span class="type">Any</span>, <span class="type">Any</span>] = <span class="literal">null</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="keyword">val</span> manager = <span class="type">SparkEnv</span>.get.shuffleManager</span><br><span class="line">      writer = manager.getWriter[<span class="type">Any</span>, <span class="type">Any</span>](dep.shuffleHandle, partitionId, context)</span><br><span class="line">      writer.write(rdd.iterator(partition, context).asInstanceOf[<span class="type">Iterator</span>[_ &lt;: <span class="type">Product2</span>[<span class="type">Any</span>, <span class="type">Any</span>]]])</span><br><span class="line">      writer.stop(success = <span class="literal">true</span>).get</span><br><span class="line">    &#125; </span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>对于 ResultTask 而言，返回结果是func函数计算结果。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.ResultTask</span></span><br><span class="line">verride <span class="function"><span class="keyword">def</span> <span class="title">runTask</span></span>(context: <span class="type">TaskContext</span>): <span class="type">U</span> = &#123;</span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">    func(context, rdd.iterator(partition, context))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h2 id="5-Driver的处理"><a href="#5-Driver的处理" class="headerlink" title="5.Driver的处理"></a>5.Driver的处理</h2><p>&emsp;CoarseGrainedExecutorBackend 中有一个 driver 对象，TaskRunner 调用 execBackend.statusUpdate 函数将 Task 的执行状态汇报给 Driver。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.executor.CoarseGrainedExecutorBackend</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">statusUpdate</span></span>(taskId: <span class="type">Long</span>, state: <span class="type">TaskState</span>, data: <span class="type">ByteBuffer</span>) &#123;</span><br><span class="line">    <span class="keyword">val</span> msg = <span class="type">StatusUpdate</span>(executorId, taskId, state, data)</span><br><span class="line">    driver <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">Some</span>(driverRef) =&gt; driverRef.send(msg)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">None</span> =&gt; logWarning(<span class="string">s"Drop <span class="subst">$msg</span> because has not yet connected to driver"</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>最后由 TaskSchedulerImpl 的 statusUpdate 进行任务结束的一些处理工作。</p><h2 id="6-附"><a href="#6-附" class="headerlink" title="6.附"></a>6.附</h2><h3 id="6-1-TaskScheduler调度类型"><a href="#6-1-TaskScheduler调度类型" class="headerlink" title="6.1 TaskScheduler调度类型"></a>6.1 TaskScheduler调度类型</h3><p>&emsp;Spark 目前提供两种调度策略，一种是 FIFO (先进先出)，这是目前的默认模式；另外一种是 FAIR 模式，FAIR 模式可以通过配置作业权重等参数来决定 Job 的优先模式，TaskSchedulerImpl 的 initialize 方法中实现了对 rootPool 根调度池的初始化。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.TaskSchedulerImpl</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">initialize</span></span>(backend: <span class="type">SchedulerBackend</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.backend = backend</span><br><span class="line">    schedulableBuilder = &#123;</span><br><span class="line">      schedulingMode <span class="keyword">match</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="type">SchedulingMode</span>.<span class="type">FIFO</span> =&gt;</span><br><span class="line">          <span class="keyword">new</span> <span class="type">FIFOSchedulableBuilder</span>(rootPool)</span><br><span class="line">        <span class="keyword">case</span> <span class="type">SchedulingMode</span>.<span class="type">FAIR</span> =&gt;</span><br><span class="line">          <span class="keyword">new</span> <span class="type">FairSchedulableBuilder</span>(rootPool, conf)</span><br><span class="line">        <span class="keyword">case</span> _ =&gt;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IllegalArgumentException</span>(<span class="string">s"Unsupported <span class="subst">$SCHEDULER_MODE_PROPERTY</span>: "</span> +</span><br><span class="line">          <span class="string">s"<span class="subst">$schedulingMode</span>"</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    schedulableBuilder.buildPools()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="6-2-RDD依赖实现"><a href="#6-2-RDD依赖实现" class="headerlink" title="6.2 RDD依赖实现"></a>6.2 RDD依赖实现</h3><p>&emsp;RDD 的 action 算子会触发作业提交，transformation 算子则是返回一个新的 RDD，这个新的 RDD 就包含了对旧 RDD 的依赖。&nbsp;<br>&emsp;以 map 方法为例，map 是一个 transformation 算子，它的实现如下：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">map</span></span>[<span class="type">U</span>: <span class="type">ClassTag</span>](f: <span class="type">T</span> =&gt; <span class="type">U</span>): <span class="type">RDD</span>[<span class="type">U</span>] = withScope &#123;</span><br><span class="line">    <span class="keyword">val</span> cleanF = sc.clean(f)</span><br><span class="line">    <span class="keyword">new</span> <span class="type">MapPartitionsRDD</span>[<span class="type">U</span>, <span class="type">T</span>](<span class="keyword">this</span>, (context, pid, iter) =&gt; iter.map(cleanF))</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>它返回了一个　MapPartitionsRDD 类，该类继承自 RDD 类：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[spark] <span class="class"><span class="keyword">class</span> <span class="title">MapPartitionsRDD</span>[<span class="type">U</span>: <span class="type">ClassTag</span>, <span class="type">T</span>: <span class="type">ClassTag</span>](<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    var prev: <span class="type">RDD</span>[<span class="type">T</span>],</span></span></span><br><span class="line"><span class="class"><span class="params">    f: (<span class="type">TaskContext</span>, <span class="type">Int</span>, <span class="type">Iterator</span>[<span class="type">T</span>]</span>) <span class="title">=&gt;</span> <span class="title">Iterator</span>[<span class="type">U</span>],  <span class="title">//</span> (<span class="params"><span class="type">TaskContext</span>, partition index, iterator</span>)</span></span><br><span class="line"><span class="class">    <span class="title">preservesPartitioning</span></span>: <span class="type">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    isFromBarrier: <span class="type">Boolean</span> = <span class="literal">false</span>,</span><br><span class="line">    isOrderSensitive: <span class="type">Boolean</span> = <span class="literal">false</span>)</span><br><span class="line">  <span class="keyword">extends</span> <span class="type">RDD</span>[<span class="type">U</span>](prev)</span><br></pre></td></tr></table></figure><br>第一个参数是 prev，即父 RDD，我们看一下 RDD U(prev) 的实现：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Construct an RDD with just a one-to-one dependency on one parent */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>(<span class="meta">@transient</span> oneParent: <span class="type">RDD</span>[_]) =</span><br><span class="line">    <span class="keyword">this</span>(oneParent.context, <span class="type">List</span>(<span class="keyword">new</span> <span class="type">OneToOneDependency</span>(oneParent)))</span><br><span class="line">  ==&gt;</span><br><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">RDD</span>[<span class="type">T</span>: <span class="type">ClassTag</span>](<span class="params"></span></span></span><br><span class="line"><span class="class"><span class="params">    @transient private var _sc: <span class="type">SparkContext</span>,</span></span></span><br><span class="line"><span class="class"><span class="params">    @transient private var deps: <span class="type">Seq</span>[<span class="type">Dependency</span>[_]]</span></span></span><br><span class="line"><span class="class"><span class="params">  </span>) </span>&#123;</span><br><span class="line">      ...</span><br><span class="line">    <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">getDependencies</span></span>: <span class="type">Seq</span>[<span class="type">Dependency</span>[_]] = deps</span><br><span class="line">      ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>当调用 getDependencies 的时候，就返回构造时传入的 deps 参数，这样就实现了 RDD 的依赖链。</p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7.总结"></a>7.总结</h2><p>&emsp;下面总结 <strong>Standalone+Client</strong> 模式下，从 action 算子触发 Job 提交到任务调度的完整运行流程：</p><ol><li>(driver) action 算子触发调用 SparkContext.runJob， 经过几次回调之后会调用 DAGScheduler 的 runJob 方法，这时作业提交就进入了 DAGScheduler 的处理阶段；</li><li>(driver) DAGScheduler 根据RDD的依赖关系是否为 ShuffleDependency(宽依赖) 来划分Stage；</li><li>(driver) DAGScheduler将每个 Stage 中的 Tasks 包装成 TaskSet，调用 taskScheduler.submitTasks，将 TaskSet 交给 TaskScheduler 处理；</li><li>(driver) TaskScheduler 创建TaskSetManager 对TaskSet的生命周期进行管理；</li><li>(driver) TaskScheduler 中的 CoarseGrainedSchedulerBackend 对象调用 driverEndpoint.send(ReviveOffers) 请求分配计算资源并启动任务；</li><li>(driver) driverEndpoint 接收到请求之后调用 scheduler.resourceOffers(workOffers) 分配计算资源，然后向 Executor 发送 LaunchTask 启动任务的消息；</li><li>(Executor) Executor 执行 Task，并将执行结果发送给 Driver；</li></ol><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-job/">http://zhoujiapeng.top/Spark/spark-job/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>[Hexo] Theme zjp</title>
      <link href="/Hexo/hexo-theme-zjp/"/>
      <url>/Hexo/hexo-theme-zjp/</url>
      
        <content type="html"><![CDATA[<blockquote><p>This zjp theme created by <a href="http://www.zhoujiapeng.top" target="_blank" rel="noopener">zhoujiapeng</a> modified from the original Porter <a href="https://github.com/huweihuang/hexo-theme-huweihuang" target="_blank" rel="noopener">HuWeihuang</a></p></blockquote><h1 id="Live-Demo"><a href="#Live-Demo" class="headerlink" title="Live Demo"></a>Live Demo</h1><p>Zhou JiaPeng Blog : <a href="http://www.zhoujiapeng.top" target="_blank" rel="noopener">www.zhoujiapeng.top</a></p><p><img src="/img/article/blog-demo.png" alt="Blog demo"></p><h1 id="Install-Hexo"><a href="#Install-Hexo" class="headerlink" title="Install Hexo"></a>Install Hexo</h1><p>Install Node.js  and Git</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">For Mac</span></span><br><span class="line">brew install node</span><br><span class="line">brew install git</span><br></pre></td></tr></table></figure><p>Install hexo</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-cli -g</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">For more:https://hexo.io/zh-cn/index.html</span></span><br></pre></td></tr></table></figure><h1 id="Theme-Usage"><a href="#Theme-Usage" class="headerlink" title="Theme Usage"></a>Theme Usage</h1><h2 id="Init"><a href="#Init" class="headerlink" title="Init"></a>Init</h2><hr><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/JP6907/hexo-theme-zjp.git ./hexo-zjp</span><br><span class="line"><span class="built_in">cd</span> hexo-zjp</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><h2 id="Modify"><a href="#Modify" class="headerlink" title="Modify"></a>Modify</h2><hr><p>Modify <code>_config.yml</code> file with your own info.<br>Especially the section:</p><h3 id="Deployment"><a href="#Deployment" class="headerlink" title="Deployment"></a>Deployment</h3><p>Replace to your own repo!<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">https://github.com/&lt;yourAccount&gt;/&lt;repo&gt;</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">&lt;your-branch&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="Sidebar-settings"><a href="#Sidebar-settings" class="headerlink" title="Sidebar settings"></a>Sidebar settings</h3><p>Copy your avatar image to <code>&lt;root&gt;/img/</code> and modify the <code>_config.yml</code>:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">sidebar:</span> <span class="literal">true</span>    <span class="comment"># whether or not using Sidebar.</span></span><br><span class="line"><span class="attr">sidebar-about-description:</span> <span class="string">"&lt;your description&gt;"</span></span><br><span class="line"><span class="attr">sidebar-avatar:</span> <span class="string">img/&lt;your</span> <span class="string">avatar</span> <span class="string">path&gt;</span></span><br></pre></td></tr></table></figure><br>and activate your personal widget you like<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">widgets:</span>         <span class="comment"># here are widget you can use, you can comment out</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">featured-tags</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">short-about</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">recent-posts</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">friends-blog</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">archive</span></span><br><span class="line"><span class="bullet">-</span> <span class="string">category</span></span><br></pre></td></tr></table></figure><br>if you want to add sidebar widget, please add at <code>layout/_widget</code>.</p><h3 id="Signature-Setup"><a href="#Signature-Setup" class="headerlink" title="Signature Setup"></a>Signature Setup</h3><p>Copy your signature image to <code>&lt;root&gt;/img/signature</code> and modify the <code>_config.yml</code>:<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">signature:</span> <span class="literal">true</span>   <span class="comment"># show signature</span></span><br><span class="line"><span class="attr">signature-img:</span> <span class="string">img/signature/&lt;your-signature-ID&gt;</span></span><br></pre></td></tr></table></figure></p><h3 id="Go-to-top-icon-Setup"><a href="#Go-to-top-icon-Setup" class="headerlink" title="Go to top icon Setup"></a>Go to top icon Setup</h3><p>My icon is using iron man, you can change to your own icon at <code>css/image</code>.</p><h3 id="Post-tag"><a href="#Post-tag" class="headerlink" title="Post tag"></a>Post tag</h3><p>You can decide to show post tags or not.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">home_posts_tag:</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure><br><img src="/img/article/post-tag.png" alt="home_posts_tag-true"></p><h3 id="Markdown-render"><a href="#Markdown-render" class="headerlink" title="Markdown render"></a>Markdown render</h3><p>My markdown render engine plugin is <a href="https://github.com/celsomiranda/hexo-renderer-markdown-it" target="_blank" rel="noopener">hexo-renderer-markdown-it</a>.<br><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Markdown-it config</span></span><br><span class="line"><span class="comment">## Docs: https://github.com/celsomiranda/hexo-renderer-markdown-it/wiki</span></span><br><span class="line"><span class="attr">markdown:</span></span><br><span class="line">  <span class="attr">render:</span></span><br><span class="line">    <span class="attr">html:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">xhtmlOut:</span> <span class="literal">false</span></span><br><span class="line">    <span class="attr">breaks:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">linkify:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">typographer:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">quotes:</span> <span class="string">'“”‘’'</span></span><br></pre></td></tr></table></figure><br>and if you want to change the header anchor ‘ℬ’, you can go to <code>layout/post.ejs</code> to change it.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">async</span>(<span class="string">"https://cdn.bootcss.com/anchor-js/1.1.1/anchor.min.js"</span>,<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        anchors.options = &#123;</span><br><span class="line">          visible: <span class="string">'hover'</span>,</span><br><span class="line">          placement: <span class="string">'left'</span>,</span><br><span class="line">          icon: ℬ <span class="comment">// this is the header anchor "unicode" icon</span></span><br><span class="line">        &#125;;</span><br></pre></td></tr></table></figure></p><h2 id="Hexo-Basics"><a href="#Hexo-Basics" class="headerlink" title="Hexo Basics"></a>Hexo Basics</h2><hr><p>Some hexo command:<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hexo new post <span class="string">"&lt;post name&gt;"</span> <span class="comment"># you can change post to another layout if you want</span></span><br><span class="line">hexo clean &amp;&amp; hexo generate <span class="comment"># generate the static file</span></span><br><span class="line">hexo server <span class="comment"># run hexo in local environment</span></span><br><span class="line">hexo deploy <span class="comment"># hexo will push the static files automatically into the specific branch(gh-pages) of your repo!</span></span><br></pre></td></tr></table></figure></p><h1 id="Have-fun"><a href="#Have-fun" class="headerlink" title="Have fun ^_^"></a>Have fun ^_^</h1><hr><!-- Place this tag in your head or just before your close body tag. --><p><script async defer src="https://buttons.github.io/buttons.js"></script><br><!-- Place this tag where you want the button to render. --></p><p>Please <a class="github-button" href="https://github.com/JP6907/hexo-theme-zjp" target="_blank" rel="noopener" data-icon="octicon-star" aria-label="Star JP6907/hexo-theme-zjp on GitHub">Star</a> this Project if you like it! <a class="github-button" href="https://github.com/JP6907" target="_blank" rel="noopener" aria-label="Follow @JP6907 on GitHub">Follow</a> would also be appreciated!<br>Peace!</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark源码阅读 之 Spark Application 的提交</title>
      <link href="/Spark/spark-application/"/>
      <url>/Spark/spark-application/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark-Application-提交"><a href="#Spark-Application-提交" class="headerlink" title="Spark Application 提交"></a>Spark Application 提交</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><p>&emsp;下面分析过程为Spark Standalone运行模式，Spark Standalone是一种典型的Master-Slave架构，在这种模式下，主要包括三个组件：Master、Worker、Driver，这里的Driver我们以运行在客户端的Client模式。</p><h2 id="1-启动脚本"><a href="#1-启动脚本" class="headerlink" title="1.启动脚本"></a>1.启动脚本</h2><p>&emsp;首先我们会使用spark的sbin目录下”start-all”脚本来启动集群：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  export SPARK_HOME="$(cd "`dirname "$0"`"/..; pwd)"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Load the Spark configuration</span></span><br><span class="line">. "$&#123;SPARK_HOME&#125;/sbin/spark-config.sh"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Start Master</span></span><br><span class="line">"$&#123;SPARK_HOME&#125;/sbin"/start-master.sh</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> Start Workers</span></span><br><span class="line">"$&#123;SPARK_HOME&#125;/sbin"/start-slaves.sh</span><br></pre></td></tr></table></figure><br>可以看到分别调用了start-master.sh脚本和start-slaves.sh脚本，查看start-master.sh脚本：<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> Starts the master on the machine this script is executed on.</span></span><br><span class="line"></span><br><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  export SPARK_HOME="$(cd "`dirname "$0"`"/..; pwd)"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> NOTE: This exact class name is matched downstream by SparkSubmit.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Any changes need to be reflected there.</span></span><br><span class="line">CLASS="org.apache.spark.deploy.master.Master"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ......</span></span><br><span class="line"></span><br><span class="line">if [ "$SPARK_MASTER_WEBUI_PORT" = "" ]; then</span><br><span class="line">  SPARK_MASTER_WEBUI_PORT=8080</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">"$&#123;SPARK_HOME&#125;/sbin"/spark-daemon.sh start $CLASS 1 \</span><br><span class="line">  --host $SPARK_MASTER_HOST --port $SPARK_MASTER_PORT --webui-port $SPARK_MASTER_WEBUI_PORT \</span><br><span class="line"><span class="meta">  $</span><span class="bash">ORIGINAL_ARGS</span></span><br></pre></td></tr></table></figure><br>该脚本启动了<strong>org.apache.spark.deploy.master.Master</strong>类，同样，查看start-slaves.sh脚本，可以看到调用了start-slave.sh脚本，而start-slave.sh脚本启动了<strong>org.apache.spark.deploy.worker.Worker</strong>类。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  export SPARK_HOME="$(cd "`dirname "$0"`"/..; pwd)"</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> NOTE: This exact class name is matched downstream by SparkSubmit.</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> Any changes need to be reflected there.</span></span><br><span class="line">CLASS="org.apache.spark.deploy.worker.Worker"</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br><span class="line"></span><br><span class="line">  "$&#123;SPARK_HOME&#125;/sbin"/spark-daemon.sh start $CLASS $WORKER_NUM \</span><br><span class="line">     --webui-port "$WEBUI_PORT" $PORT_FLAG $PORT_NUM $MASTER "$@"</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> ...</span></span><br></pre></td></tr></table></figure><br>这时，Spark集群的Master节点和Worker已经全部启动，Worker会向Master完成注册，并定时向Master发送心跳，使得Master节点可以知道该Worker节点属于活跃状态。</p><h2 id="2-SparkSubmit"><a href="#2-SparkSubmit" class="headerlink" title="2.SparkSubmit"></a>2.SparkSubmit</h2><p>&emsp;打开 spark-submit 脚本，可以看到这个脚本最终启动了 org.apache.spark.deploy.SparkSubmit 这个类。<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">if [ -z "$&#123;SPARK_HOME&#125;" ]; then</span><br><span class="line">  source "$(dirname "$0")"/find-spark-home</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">disable</span> randomized <span class="built_in">hash</span> <span class="keyword">for</span> string <span class="keyword">in</span> Python 3.3+</span></span><br><span class="line">export PYTHONHASHSEED=0</span><br><span class="line"></span><br><span class="line">exec "$&#123;SPARK_HOME&#125;"/bin/spark-class org.apache.spark.deploy.SparkSubmit "$@"</span><br></pre></td></tr></table></figure><br>&emsp; Object SparkSubmit类继承自 CommandLineUtils ，名字浅显易懂，就是命令行解析工具类，它负责解析输入的命令和参数，并启动一个子类执行具体的业务逻辑。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">main</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">val</span> submit = <span class="keyword">new</span> <span class="type">SparkSubmit</span>() &#123;</span><br><span class="line">      self =&gt;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">parseArguments</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">SparkSubmitArguments</span> = &#123;</span><br><span class="line">        <span class="keyword">new</span> <span class="type">SparkSubmitArguments</span>(args) &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">logInfo</span></span>(msg: =&gt; <span class="type">String</span>): <span class="type">Unit</span> = self.logInfo(msg)</span><br><span class="line"></span><br><span class="line">          <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">logWarning</span></span>(msg: =&gt; <span class="type">String</span>): <span class="type">Unit</span> = self.logWarning(msg)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">logInfo</span></span>(msg: =&gt; <span class="type">String</span>): <span class="type">Unit</span> = printMessage(msg)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="keyword">protected</span> <span class="function"><span class="keyword">def</span> <span class="title">logWarning</span></span>(msg: =&gt; <span class="type">String</span>): <span class="type">Unit</span> = printMessage(<span class="string">s"Warning: <span class="subst">$msg</span>"</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">doSubmit</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          <span class="keyword">super</span>.doSubmit(args)</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">SparkUserAppException</span> =&gt;</span><br><span class="line">            exitFn(e.exitCode)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    submit.doSubmit(args)</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>SparkSubmit 的面函数里面重写了解析参数，打印日志等函数，最后执行 submit.doSubmit(args)，所以 doSubmit 函数是主要的入口：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSubmit</span></span>(args: <span class="type">Array</span>[<span class="type">String</span>]): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// Initialize logging if it hasn't been done yet. Keep track of whether logging needs to</span></span><br><span class="line">    <span class="comment">// be reset before the application starts.</span></span><br><span class="line">    <span class="keyword">val</span> uninitLog = initializeLogIfNecessary(<span class="literal">true</span>, silent = <span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> appArgs = parseArguments(args)</span><br><span class="line">    <span class="keyword">if</span> (appArgs.verbose) &#123;</span><br><span class="line">      logInfo(appArgs.toString)</span><br><span class="line">    &#125;</span><br><span class="line">    appArgs.action <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">SUBMIT</span> =&gt; submit(appArgs, uninitLog)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">KILL</span> =&gt; kill(appArgs)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">REQUEST_STATUS</span> =&gt; requestStatus(appArgs)</span><br><span class="line">      <span class="keyword">case</span> <span class="type">SparkSubmitAction</span>.<span class="type">PRINT_VERSION</span> =&gt; printVersion()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>doSubmit 首先调用 parseArguments 解析输入的参数，然后根据具体的参数再调用相应的处理函数，我们具体看一下submit的逻辑。</p><p>submit 函数负责根据输入参数提交 Application，执行分为两步：      </p><ol><li>准备环境，设置classpath、系统参数、程序参数等：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.deploy.SparkSubmit.submit()</span></span><br><span class="line"><span class="keyword">val</span> (childArgs, childClasspath, sparkConf, childMainClass) = prepareSubmitEnvironment(args)</span><br></pre></td></tr></table></figure></li><li>运行，通过反射机制启动 Spark Application 程序 mainClass 中的 main 方法：<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">runMain(childArgs, childClasspath, sparkConf, childMainClass, args.verbose)</span><br></pre></td></tr></table></figure></li></ol><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">runMain</span></span>(</span><br><span class="line">      childArgs: <span class="type">Seq</span>[<span class="type">String</span>],</span><br><span class="line">      childClasspath: <span class="type">Seq</span>[<span class="type">String</span>],</span><br><span class="line">      sparkConf: <span class="type">SparkConf</span>,</span><br><span class="line">      childMainClass: <span class="type">String</span>,</span><br><span class="line">      verbose: <span class="type">Boolean</span>): <span class="type">Unit</span> = &#123;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">var</span> mainClass: <span class="type">Class</span>[_] = <span class="literal">null</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      mainClass = <span class="type">Utils</span>.classForName(childMainClass)</span><br><span class="line">    &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">      <span class="comment">/// ...</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">val</span> app: <span class="type">SparkApplication</span> = <span class="keyword">if</span> (classOf[<span class="type">SparkApplication</span>].isAssignableFrom(mainClass)) &#123;</span><br><span class="line">      mainClass.newInstance().asInstanceOf[<span class="type">SparkApplication</span>]</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// SPARK-4170</span></span><br><span class="line">      <span class="keyword">if</span> (classOf[scala.<span class="type">App</span>].isAssignableFrom(mainClass)) &#123;</span><br><span class="line">        logWarning(<span class="string">"Subclasses of scala.App may not work correctly. Use a main() method instead."</span>)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">new</span> <span class="type">JavaMainApplication</span>(mainClass)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/// ...</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>上面启动的 Spark Application 程序（用户程序）会创建 SparkContext，每个 Application 都会对应着唯一一个 SparkContext ，main方法里面会完成 SparkContext的初始化。SparkContext 是 Spark 应用创建时的上下文对象，是一个重要的入口类，在内部会进行一系列重要的操作，其中最重要的是创建 TaskScheduler 和 DAGScheduler实例。</p><h2 id="3-SparkContext"><a href="#3-SparkContext" class="headerlink" title="3.SparkContext"></a>3.SparkContext</h2><p>&emsp;SparkoContext 是 Spark 应用创建时的上下文对象，是一个重要的入口类，在内部会进行一系列重要的操作，其中最重要的是创建 TaskScheduler 和 DAGScheduler实例。</p><h3 id="3-1-SparkConf"><a href="#3-1-SparkConf" class="headerlink" title="3.1 SparkConf"></a>3.1 SparkConf</h3><p>&emsp;SparkConf负责管理Spark应用中的属性设置，它通过一个HashMap容器来管理key/alue类型的属性。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SparkConf</span>(<span class="params">loadDefaults: <span class="type">Boolean</span></span>) <span class="keyword">extends</span> <span class="title">Cloneable</span> <span class="keyword">with</span> <span class="title">Logging</span> <span class="keyword">with</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">import</span> <span class="type">SparkConf</span>._</span><br><span class="line"></span><br><span class="line">  <span class="comment">/** Create a SparkConf that loads defaults from system properties and the classpath */</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">this</span></span>() = <span class="keyword">this</span>(<span class="literal">true</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">val</span> settings = <span class="keyword">new</span> <span class="type">ConcurrentHashMap</span>[<span class="type">String</span>, <span class="type">String</span>]()</span><br><span class="line"></span><br><span class="line">  <span class="comment">/// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><br>&emsp;注意，在SparkContext中会对传入的SparkConf克隆并验证，即一旦SparkConf传给SparkContext，就不能在修改了，Spark不支持运行时修改配置。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.SparkContext</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    _conf = config.clone()</span><br><span class="line">    _conf.validateSettings()</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><h3 id="3-2-LiveListenerBus"><a href="#3-2-LiveListenerBus" class="headerlink" title="3.2 LiveListenerBus"></a>3.2 LiveListenerBus</h3><p>&emsp;这里使用典型的<strong>观察者模式</strong>，SparkListener 向LiveListenerBus类注册不同类型的 SparkListenerEvent事件，LiveListenerBus会遍历它的所有监听者SparkListener， 然后使用对应事件接口进行相应。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.SparkContext</span></span><br><span class="line">_listenerBus = <span class="keyword">new</span> <span class="type">LiveListenerBus</span>(_conf)</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">setupAndStartListenerBus()</span><br><span class="line">postEnvironmentUpdate()</span><br><span class="line">postApplicationStart()</span><br></pre></td></tr></table></figure><br>当task scheduler准备好了之后，就会通过postEnvironmentUpdate通知listenerBus<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/** Post the environment update event once the task scheduler is ready */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">postEnvironmentUpdate</span></span>() &#123;</span><br><span class="line">    <span class="keyword">if</span> (taskScheduler != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">val</span> schedulingMode = getSchedulingMode.toString</span><br><span class="line">      <span class="keyword">val</span> addedJarPaths = addedJars.keys.toSeq</span><br><span class="line">      <span class="keyword">val</span> addedFilePaths = addedFiles.keys.toSeq</span><br><span class="line">      <span class="keyword">val</span> environmentDetails = <span class="type">SparkEnv</span>.environmentDetails(conf, schedulingMode, addedJarPaths,</span><br><span class="line">        addedFilePaths)</span><br><span class="line">      <span class="keyword">val</span> environmentUpdate = <span class="type">SparkListenerEnvironmentUpdate</span>(environmentDetails)</span><br><span class="line">      listenerBus.post(environmentUpdate) <span class="comment">//观察者模式</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-3-SparkEnv"><a href="#3-3-SparkEnv" class="headerlink" title="3.3 SparkEnv"></a>3.3 SparkEnv</h3><p>&emsp;SparkEnv是运行环境，封装了所有Spark运行时的环境对象，如Serializer、ShuffleManager、BroadcastManager、BlockManager、MemoryManager等。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create the Spark execution environment (cache, map output tracker, etc)</span></span><br><span class="line">    _env = createSparkEnv(_conf, isLocal, listenerBus)</span><br><span class="line">    <span class="type">SparkEnv</span>.set(_env)</span><br></pre></td></tr></table></figure></p><h3 id="3-4-SparkUI"><a href="#3-4-SparkUI" class="headerlink" title="3.4 SparkUI"></a>3.4 SparkUI</h3><p>&emsp;通过SparkUI可以观察Spark集群的运行情况和Spark Application的运行情况。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_ui =</span><br><span class="line">      <span class="keyword">if</span> (conf.getBoolean(<span class="string">"spark.ui.enabled"</span>, <span class="literal">true</span>)) &#123;</span><br><span class="line">        <span class="type">Some</span>(<span class="type">SparkUI</span>.create(<span class="type">Some</span>(<span class="keyword">this</span>), _statusStore, _conf, _env.securityManager, appName, <span class="string">""</span>,</span><br><span class="line">          startTime))</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// For tests, do not enable the UI</span></span><br><span class="line">        <span class="type">None</span></span><br><span class="line">      &#125;</span><br><span class="line">    <span class="comment">// Bind the UI before starting the task scheduler to communicate</span></span><br><span class="line">    <span class="comment">// the bound port to the cluster manager properly</span></span><br><span class="line">    _ui.foreach(_.bind())</span><br></pre></td></tr></table></figure></p><h3 id="3-5-EventLoggingListener"><a href="#3-5-EventLoggingListener" class="headerlink" title="3.5 EventLoggingListener"></a>3.5 EventLoggingListener</h3><p>&emsp;EventLoggingListener默认是关闭的，可以通过spark.eventLog.enabled配置开启，它的主要功能是以json格式记录发生的事件。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">_eventLogger =</span><br><span class="line">      <span class="keyword">if</span> (isEventLogEnabled) &#123;</span><br><span class="line">        <span class="keyword">val</span> logger =</span><br><span class="line">          <span class="keyword">new</span> <span class="type">EventLoggingListener</span>(_applicationId, _applicationAttemptId, _eventLogDir.get,</span><br><span class="line">            _conf, _hadoopConfiguration)</span><br><span class="line">        logger.start()</span><br><span class="line">        listenerBus.addToEventLogQueue(logger)</span><br><span class="line">        <span class="type">Some</span>(logger)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="type">None</span></span><br><span class="line">      &#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-6-TaskScheduler"><a href="#3-6-TaskScheduler" class="headerlink" title="3.6 TaskScheduler"></a>3.6 TaskScheduler</h3><p>&emsp;SparkContext会创建 TaskScheduler 和 DAGScheduler 调度器：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Create and start the scheduler</span></span><br><span class="line">    <span class="keyword">val</span> (sched, ts) = <span class="type">SparkContext</span>.createTaskScheduler(<span class="keyword">this</span>, master, deployMode)</span><br><span class="line">    _schedulerBackend = sched</span><br><span class="line">    _taskScheduler = ts</span><br><span class="line">    _dagScheduler = <span class="keyword">new</span> <span class="type">DAGScheduler</span>(<span class="keyword">this</span>)</span><br></pre></td></tr></table></figure><br>TaskScheduler 通过不同的 SchedulerBackend 来调度和管理任务，它实现了FIFO调度和FAIR调度。SparkContext.createTaskScheduler 会根据不同的部署模式选择不同的 SchedulerBackend<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">   * Create a task scheduler based on a given master URL.</span></span><br><span class="line"><span class="comment">   * Return a 2-tuple of the scheduler backend and the task scheduler.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">createTaskScheduler</span></span>(</span><br><span class="line">      sc: <span class="type">SparkContext</span>,</span><br><span class="line">      master: <span class="type">String</span>,</span><br><span class="line">      deployMode: <span class="type">String</span>): (<span class="type">SchedulerBackend</span>, <span class="type">TaskScheduler</span>) = &#123;</span><br><span class="line">    <span class="keyword">import</span> <span class="type">SparkMasterRegex</span>._</span><br><span class="line"></span><br><span class="line">    <span class="comment">// When running locally, don't try to re-execute tasks on failure.</span></span><br><span class="line">    <span class="keyword">val</span> <span class="type">MAX_LOCAL_TASK_FAILURES</span> = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    master <span class="keyword">match</span> &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">"local"</span> =&gt;</span><br><span class="line">        <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc, <span class="type">MAX_LOCAL_TASK_FAILURES</span>, isLocal = <span class="literal">true</span>)</span><br><span class="line">        <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">LocalSchedulerBackend</span>(sc.getConf, scheduler, <span class="number">1</span>)</span><br><span class="line">        scheduler.initialize(backend)</span><br><span class="line">        (backend, scheduler)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> <span class="type">SPARK_REGEX</span>(sparkUrl) =&gt;</span><br><span class="line">        <span class="keyword">val</span> scheduler = <span class="keyword">new</span> <span class="type">TaskSchedulerImpl</span>(sc)</span><br><span class="line">        <span class="keyword">val</span> masterUrls = sparkUrl.split(<span class="string">","</span>).map(<span class="string">"spark://"</span> + _)</span><br><span class="line">        <span class="keyword">val</span> backend = <span class="keyword">new</span> <span class="type">StandaloneSchedulerBackend</span>(scheduler, sc, masterUrls)</span><br><span class="line">        scheduler.initialize(backend)</span><br><span class="line">        (backend, scheduler)</span><br><span class="line"></span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><h3 id="3-7-StandaloneAppClient"><a href="#3-7-StandaloneAppClient" class="headerlink" title="3.7 StandaloneAppClient"></a>3.7 StandaloneAppClient</h3><p>&emsp; standalone 模式对应的是 SPARK_REGEX，这里的 SchedulerBackend 实现的是 StandaloneSchedulerBackend，它是CoarseGrainedSchedulerBackend 的子类，CoarseGrainedSchedulerBackend 实现了 SchedulerBackend 特质。StandaloneSchedulerBackend 会创建并启动 StandaloneAppClient，client 启动之后会向 Master注册 Application。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.scheduler.cluster.StandaloneSchedulerBackend</span></span><br><span class="line">client = <span class="keyword">new</span> <span class="type">StandaloneAppClient</span>(sc.env.rpcEnv, masters, appDesc, <span class="keyword">this</span>, conf)</span><br><span class="line">client.start()</span><br><span class="line"></span><br><span class="line"><span class="comment">//StandaloneAppClient.scala</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">onStart</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        registerWithMaster(<span class="number">1</span>)</span><br><span class="line">      &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">        <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">          logWarning(<span class="string">"Failed to connect to master"</span>, e)</span><br><span class="line">          markDisconnected()</span><br><span class="line">          stop()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>&emsp;client 会尝试向所有的Master（可能有多个）注册，直到成功连接上其中一个 Master。发送注册消息的过程中，如果超过20s没有接收到注册成功的消息，那么会重新注册，如果重试超过3次仍未成功，那么本次提交就以失败结束。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//StandaloneAppClient.scala</span></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">registerWithMaster</span></span>(nthRetry: <span class="type">Int</span>) &#123;</span><br><span class="line">      registerMasterFutures.set(tryRegisterAllMasters())</span><br><span class="line">      registrationRetryTimer.set(registrationRetryThread.schedule(<span class="keyword">new</span> <span class="type">Runnable</span> &#123;</span><br><span class="line">        <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">          <span class="keyword">if</span> (registered.get) &#123;</span><br><span class="line">            registerMasterFutures.get.foreach(_.cancel(<span class="literal">true</span>))</span><br><span class="line">            registerMasterThreadPool.shutdownNow()</span><br><span class="line">          &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nthRetry &gt;= <span class="type">REGISTRATION_RETRIES</span>) &#123;</span><br><span class="line">            markDead(<span class="string">"All masters are unresponsive! Giving up."</span>)</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            registerMasterFutures.get.foreach(_.cancel(<span class="literal">true</span>))</span><br><span class="line">            registerWithMaster(nthRetry + <span class="number">1</span>)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;, <span class="type">REGISTRATION_TIMEOUT_SECONDS</span>, <span class="type">TimeUnit</span>.<span class="type">SECONDS</span>))</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">tryRegisterAllMasters</span></span>(): <span class="type">Array</span>[<span class="type">JFuture</span>[_]] = &#123;</span><br><span class="line">      <span class="keyword">for</span> (masterAddress &lt;- masterRpcAddresses) <span class="keyword">yield</span> &#123;</span><br><span class="line">        registerMasterThreadPool.submit(<span class="keyword">new</span> <span class="type">Runnable</span> &#123;</span><br><span class="line">          <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>(): <span class="type">Unit</span> = <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (registered.get) &#123;</span><br><span class="line">              <span class="keyword">return</span></span><br><span class="line">            &#125;</span><br><span class="line">            logInfo(<span class="string">"Connecting to master "</span> + masterAddress.toSparkURL + <span class="string">"..."</span>)</span><br><span class="line">            <span class="keyword">val</span> masterRef = rpcEnv.setupEndpointRef(masterAddress, <span class="type">Master</span>.<span class="type">ENDPOINT_NAME</span>)</span><br><span class="line">            masterRef.send(<span class="type">RegisterApplication</span>(appDescription, self))</span><br><span class="line">          &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">            <span class="keyword">case</span> ie: <span class="type">InterruptedException</span> =&gt; <span class="comment">// Cancelled</span></span><br><span class="line">            <span class="keyword">case</span> <span class="type">NonFatal</span>(e) =&gt; logWarning(<span class="string">s"Failed to connect to master <span class="subst">$masterAddress</span>"</span>, e)</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><br>tryRegisterAllMasters 函数通过 rpcEnv 向 Master 发送一个 RegisterApplication 注册的消息，StandaloneAppClient 的 receive 方法会接收 Master 的返回消息：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="type">RegisteredApplication</span>(appId_, masterRef) =&gt;</span><br><span class="line">        <span class="comment">// FIXME How to handle the following cases?</span></span><br><span class="line">        <span class="comment">// 1. A master receives multiple registrations and sends back multiple</span></span><br><span class="line">        <span class="comment">// RegisteredApplications due to an unstable network.</span></span><br><span class="line">        <span class="comment">// 2. Receive multiple RegisteredApplication from different masters because the master is</span></span><br><span class="line">        <span class="comment">// changing.</span></span><br><span class="line">        appId.set(appId_)</span><br><span class="line">        registered.set(<span class="literal">true</span>)</span><br><span class="line">        master = <span class="type">Some</span>(masterRef)</span><br><span class="line">        listener.connected(appId.get)</span><br><span class="line"></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure></p><h3 id="3-8-Master-和-Worker"><a href="#3-8-Master-和-Worker" class="headerlink" title="3.8 Master 和 Worker"></a>3.8 Master 和 Worker</h3><p>Master 接收到 AppClient 的 RegisterApplication 消息后，会创建并注册对应的 Applicaton。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.deploy.master</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="type">ElectedLeader</span> =&gt;</span><br><span class="line">      <span class="keyword">val</span> (storedApps, storedDrivers, storedWorkers) = persistenceEngine.readPersistedData(rpcEnv)</span><br><span class="line">      </span><br><span class="line">      ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> <span class="type">RegisterApplication</span>(description, driver) =&gt;</span><br><span class="line">      <span class="comment">// TODO Prevent repeated registrations from some driver</span></span><br><span class="line">      <span class="keyword">if</span> (state == <span class="type">RecoveryState</span>.<span class="type">STANDBY</span>) &#123;</span><br><span class="line">        <span class="comment">// ignore, don't send response</span></span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        logInfo(<span class="string">"Registering app "</span> + description.name)</span><br><span class="line">        <span class="keyword">val</span> app = createApplication(description, driver)</span><br><span class="line">        registerApplication(app)</span><br><span class="line">        logInfo(<span class="string">"Registered app "</span> + description.name + <span class="string">" with ID "</span> + app.id)</span><br><span class="line">        persistenceEngine.addApplication(app)</span><br><span class="line">        driver.send(<span class="type">RegisteredApplication</span>(app.id, self))</span><br><span class="line">        schedule()</span><br><span class="line">      &#125;</span><br><span class="line">     </span><br><span class="line">     ...</span><br></pre></td></tr></table></figure><p>在registerApplication函数里面，会通过applicationMetricsSystem度量系统<strong>为该Application注册资源</strong>。Spark基于Metric构建了自己的度量系统，提供完整的系统监控功能，如可测性、性能优化、运维评估、数据统计等。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">applicationMetricsSystem.registerSource(app.appSource)</span><br></pre></td></tr></table></figure><br>在注册完成之后，会调用schedule函数，为 <strong>worker</strong> 进行资源的调度分配：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">schedule</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="keyword">if</span> (state != <span class="type">RecoveryState</span>.<span class="type">ALIVE</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// Drivers take strict precedence over executors</span></span><br><span class="line">    <span class="keyword">val</span> shuffledAliveWorkers = <span class="type">Random</span>.shuffle(workers.toSeq.filter(_.state == <span class="type">WorkerState</span>.<span class="type">ALIVE</span>))</span><br><span class="line">    <span class="keyword">val</span> numWorkersAlive = shuffledAliveWorkers.size</span><br><span class="line">    <span class="keyword">var</span> curPos = <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> (driver &lt;- waitingDrivers.toList) &#123; <span class="comment">// iterate over a copy of waitingDrivers</span></span><br><span class="line">      <span class="comment">// We assign workers to each waiting driver in a round-robin fashion. For each driver, we</span></span><br><span class="line">      <span class="comment">// start from the last worker that was assigned a driver, and continue onwards until we have</span></span><br><span class="line">      <span class="comment">// explored all alive workers.</span></span><br><span class="line">      <span class="keyword">var</span> launched = <span class="literal">false</span></span><br><span class="line">      <span class="keyword">var</span> numWorkersVisited = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span> (numWorkersVisited &lt; numWorkersAlive &amp;&amp; !launched) &#123;</span><br><span class="line">        <span class="keyword">val</span> worker = shuffledAliveWorkers(curPos)</span><br><span class="line">        numWorkersVisited += <span class="number">1</span></span><br><span class="line">        <span class="keyword">if</span> (worker.memoryFree &gt;= driver.desc.mem &amp;&amp; worker.coresFree &gt;= driver.desc.cores) &#123;</span><br><span class="line">          launchDriver(worker, driver)</span><br><span class="line">          waitingDrivers -= driver</span><br><span class="line">          launched = <span class="literal">true</span></span><br><span class="line">        &#125;</span><br><span class="line">        curPos = (curPos + <span class="number">1</span>) % numWorkersAlive</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    startExecutorsOnWorkers()</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>scheduler 会首先打散所有 worker，然后再选出符合条件的 worker 节点，使得一个 Application 尽可能多得分配到不同的节点，最后通过startExecutorsOnWorkers 在相应的worder分配资源并启动 Executor 进程：<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="function"><span class="keyword">def</span> <span class="title">startExecutorsOnWorkers</span></span>(): <span class="type">Unit</span> = &#123;</span><br><span class="line">    <span class="comment">// Right now this is a very simple FIFO scheduler. We keep trying to fit in the first app</span></span><br><span class="line">    <span class="comment">// in the queue, then the second app, etc.</span></span><br><span class="line">    <span class="keyword">for</span> (app &lt;- waitingApps) &#123;</span><br><span class="line">      <span class="keyword">val</span> coresPerExecutor = app.desc.coresPerExecutor.getOrElse(<span class="number">1</span>)</span><br><span class="line">      <span class="comment">// If the cores left is less than the coresPerExecutor,the cores left will not be allocated</span></span><br><span class="line">      <span class="keyword">if</span> (app.coresLeft &gt;= coresPerExecutor) &#123;</span><br><span class="line">        <span class="comment">// Filter out workers that don't have enough resources to launch an executor</span></span><br><span class="line">        <span class="keyword">val</span> usableWorkers = workers.toArray.filter(_.state == <span class="type">WorkerState</span>.<span class="type">ALIVE</span>)</span><br><span class="line">          .filter(worker =&gt; worker.memoryFree &gt;= app.desc.memoryPerExecutorMB &amp;&amp;</span><br><span class="line">            worker.coresFree &gt;= coresPerExecutor)</span><br><span class="line">          .sortBy(_.coresFree).reverse</span><br><span class="line">        <span class="keyword">val</span> assignedCores = scheduleExecutorsOnWorkers(app, usableWorkers, spreadOutApps)</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Now that we've decided how many cores to allocate on each worker, let's allocate them</span></span><br><span class="line">        <span class="keyword">for</span> (pos &lt;- <span class="number">0</span> until usableWorkers.length <span class="keyword">if</span> assignedCores(pos) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          allocateWorkerResourceToExecutors(</span><br><span class="line">            app, assignedCores(pos), app.desc.coresPerExecutor, usableWorkers(pos))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>allocateWorkerResourceToExecutors 函数会发送一个 LaunchExecutor消息给对应 Worker，Worker 根据 Master 的资源分配结果类创建 Executor 进程。</p><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//org.apache.spark.deploy.worker</span></span><br><span class="line"><span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">receive</span></span>: <span class="type">PartialFunction</span>[<span class="type">Any</span>, <span class="type">Unit</span>] = synchronized &#123;</span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">  <span class="keyword">case</span> <span class="type">LaunchExecutor</span>(masterUrl, appId, execId, appDesc, cores_, memory_) =&gt;</span><br><span class="line">      <span class="keyword">if</span> (masterUrl != activeMasterUrl) &#123;</span><br><span class="line">        logWarning(<span class="string">"Invalid Master ("</span> + masterUrl + <span class="string">") attempted to launch executor."</span>)</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          logInfo(<span class="string">"Asked to launch executor %s/%d for %s"</span>.format(appId, execId, appDesc.name))</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Create the executor's working directory</span></span><br><span class="line">          <span class="keyword">val</span> executorDir = <span class="keyword">new</span> <span class="type">File</span>(workDir, appId + <span class="string">"/"</span> + execId)</span><br><span class="line">          <span class="keyword">if</span> (!executorDir.mkdirs()) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">"Failed to create directory "</span> + executorDir)</span><br><span class="line">          &#125;</span><br><span class="line"></span><br><span class="line">          <span class="comment">// Create local dirs for the executor. These are passed to the executor via the</span></span><br><span class="line">          <span class="comment">// SPARK_EXECUTOR_DIRS environment variable, and deleted by the Worker when the</span></span><br><span class="line">          <span class="comment">// application finishes.</span></span><br><span class="line">          <span class="keyword">val</span> appLocalDirs = appDirectories.getOrElse(appId, &#123;</span><br><span class="line">            <span class="keyword">val</span> localRootDirs = <span class="type">Utils</span>.getOrCreateLocalRootDirs(conf)</span><br><span class="line">            <span class="keyword">val</span> dirs = localRootDirs.flatMap &#123; dir =&gt;</span><br><span class="line">              <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">val</span> appDir = <span class="type">Utils</span>.createDirectory(dir, namePrefix = <span class="string">"executor"</span>)</span><br><span class="line">                <span class="type">Utils</span>.chmod700(appDir)</span><br><span class="line">                <span class="type">Some</span>(appDir.getAbsolutePath())</span><br><span class="line">              &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">                <span class="keyword">case</span> e: <span class="type">IOException</span> =&gt;</span><br><span class="line">                  logWarning(<span class="string">s"<span class="subst">$&#123;e.getMessage&#125;</span>. Ignoring this directory."</span>)</span><br><span class="line">                  <span class="type">None</span></span><br><span class="line">              &#125;</span><br><span class="line">            &#125;.toSeq</span><br><span class="line">            <span class="keyword">if</span> (dirs.isEmpty) &#123;</span><br><span class="line">              <span class="keyword">throw</span> <span class="keyword">new</span> <span class="type">IOException</span>(<span class="string">"No subfolder can be created in "</span> +</span><br><span class="line">                <span class="string">s"<span class="subst">$&#123;localRootDirs.mkString(",")&#125;</span>."</span>)</span><br><span class="line">            &#125;</span><br><span class="line">            dirs</span><br><span class="line">          &#125;)</span><br><span class="line">          appDirectories(appId) = appLocalDirs</span><br><span class="line">          <span class="keyword">val</span> manager = <span class="keyword">new</span> <span class="type">ExecutorRunner</span>(</span><br><span class="line">            appId,</span><br><span class="line">            execId,</span><br><span class="line">            appDesc.copy(command = <span class="type">Worker</span>.maybeUpdateSSLSettings(appDesc.command, conf)),</span><br><span class="line">            cores_,</span><br><span class="line">            memory_,</span><br><span class="line">            self,</span><br><span class="line">            workerId,</span><br><span class="line">            host,</span><br><span class="line">            webUi.boundPort,</span><br><span class="line">            publicAddress,</span><br><span class="line">            sparkHome,</span><br><span class="line">            executorDir,</span><br><span class="line">            workerUri,</span><br><span class="line">            conf,</span><br><span class="line">            appLocalDirs, <span class="type">ExecutorState</span>.<span class="type">RUNNING</span>)</span><br><span class="line">          executors(appId + <span class="string">"/"</span> + execId) = manager</span><br><span class="line">          manager.start()</span><br><span class="line">          coresUsed += cores_</span><br><span class="line">          memoryUsed += memory_</span><br><span class="line">          sendToMaster(<span class="type">ExecutorStateChanged</span>(appId, execId, manager.state, <span class="type">None</span>, <span class="type">None</span>))</span><br><span class="line">        &#125; <span class="keyword">catch</span> &#123;</span><br><span class="line">          <span class="keyword">case</span> e: <span class="type">Exception</span> =&gt;</span><br><span class="line">            logError(<span class="string">s"Failed to launch executor <span class="subst">$appId</span>/<span class="subst">$execId</span> for <span class="subst">$&#123;appDesc.name&#125;</span>."</span>, e)</span><br><span class="line">            <span class="keyword">if</span> (executors.contains(appId + <span class="string">"/"</span> + execId)) &#123;</span><br><span class="line">              executors(appId + <span class="string">"/"</span> + execId).kill()</span><br><span class="line">              executors -= appId + <span class="string">"/"</span> + execId</span><br><span class="line">            &#125;</span><br><span class="line">            sendToMaster(<span class="type">ExecutorStateChanged</span>(appId, execId, <span class="type">ExecutorState</span>.<span class="type">FAILED</span>,</span><br><span class="line">              <span class="type">Some</span>(e.toString), <span class="type">None</span>))</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line"></span><br><span class="line">  ...</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Worker 接收到 LaunchExecutor 消息后会创建相应的工作目录，并启动 ExecutorRunner。Worker 会记录本身资源的使用情况，包括CPU、内存等，但这个统计只是为了 WebUI 的展现。Master 本身会记录 Worker 的资源使用情况，无需 Worker 汇报。<strong>Worker 和 Master 之间传送的心跳的目的仅仅是汇报存活状态，不会携带其它信息</strong>。</p><p>ExecutorRunner 会启动一个线程来执行任务:<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span>[worker] <span class="function"><span class="keyword">def</span> <span class="title">start</span></span>() &#123;</span><br><span class="line">    workerThread = <span class="keyword">new</span> <span class="type">Thread</span>(<span class="string">"ExecutorRunner for "</span> + fullId) &#123;</span><br><span class="line">      <span class="keyword">override</span> <span class="function"><span class="keyword">def</span> <span class="title">run</span></span>() &#123; fetchAndRunExecutor() &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    workerThread.start()</span><br><span class="line">    <span class="comment">// Shutdown hook that kills actors on shutdown.</span></span><br><span class="line">    shutdownHook = <span class="type">ShutdownHookManager</span>.addShutdownHook &#123; () =&gt;</span><br><span class="line">      <span class="comment">// It's possible that we arrive here before calling `fetchAndRunExecutor`, then `state` will</span></span><br><span class="line">      <span class="comment">// be `ExecutorState.RUNNING`. In this case, we should set `state` to `FAILED`.</span></span><br><span class="line">      <span class="keyword">if</span> (state == <span class="type">ExecutorState</span>.<span class="type">RUNNING</span>) &#123;</span><br><span class="line">        state = <span class="type">ExecutorState</span>.<span class="type">FAILED</span></span><br><span class="line">      &#125;</span><br><span class="line">      killProcess(<span class="type">Some</span>(<span class="string">"Worker shutting down"</span>)) &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><br>主要的线程逻辑在 fetchAndRunExecutor 函数中，里面首先根据ApplicationDescription设置一些环境参数、创建工作目录，最后再执行相应的程序。</p><h2 id="4-总结"><a href="#4-总结" class="headerlink" title="4.总结"></a>4.总结</h2><p>&emsp;现总结 <strong>Standalone+Client</strong> 模式下，Spark Application 提交后整个系统的运行流程：</p><ol><li>(client/driver端) 使用 spark-submit 脚本提交 Application；</li><li>(client/driver端) spark-submit 脚本执行 org.apache.spark.deploy.SparkSubmit 类的主函数入口，如果脚本执行submit命令，则 SparkSubmit 首先解析传入参数，然后使用 Java 的反射机制运行参数中指定的 mainClass 主类的main函数，即用户程序中的 main 函数；</li><li>(client/driver端) main函数中会创建 SparkContext，它程序的重要入口，包含系统运行的上下文信息，SparkContext 会根据传入的 SparkConf创建一系列组建，包括 LiveListenerBus、SparkEnv、RpcEndpointRef、TaskScheduler、DAGScheduler等；</li><li>(client/driver端) SparkContext.createTaskScheduler 会根据部署模式创建对应的 SchedulerBackend，Standalone 模式下是 StandaloneSchedulerBackend，StandaloneSchedulerBackend 会创建 StandaloneAppClient，并启动 client；</li><li>(client/driver端) StandaloneAppClient 启动过程中会向 Master 注册 Application,通过 rpcEnv 发送一个 RegisterApplication 信息；</li><li>(Master节点) Master 接收到 RegisterApplication 信息后，会在 MetricsSystem 度量系统中注册 Applicaiton 需要的资源，然后调用 schedule 函数执行调度过程，schedule函数会为 worker 进行计算资源的调度分配，最后发送 LaunchExecutor 给各个 Worker 通知其启动相应的 Executor 进程；</li><li>(Worker节点) Worker 接收到 LaunchExecutor 消息后会创建相应的工作目录，并启动 ExecutorRunner，ExecutorRunner 会启动一个线程来执行具体的任务；</li></ol><p>&nbsp;<br>&nbsp;</p><blockquote><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-application/">http://zhoujiapeng.top/Spark/spark-application/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
            <tag> 源码阅读 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spark Overview</title>
      <link href="/Spark/spark-overview/"/>
      <url>/Spark/spark-overview/</url>
      
        <content type="html"><![CDATA[<h1 id="Spark集群架构"><a href="#Spark集群架构" class="headerlink" title="Spark集群架构"></a>Spark集群架构</h1><blockquote><p>Spark版本：2.4.0</p></blockquote><h2 id="1-Spark运行架构"><a href="#1-Spark运行架构" class="headerlink" title="1. Spark运行架构"></a>1. Spark运行架构</h2><p>&emsp;Spark集群中的Spark Application的运行架构由两部分组成：包含SparkContext的Driver Program（驱动程序）和在Executor中执行计算的程序。Spark Application一般都是在集群上以独立的进程集合运行。<br><img src="https://gitee.com/JP6907/Pic/raw/master/spark/cluster-overview.png?raw=true" alt="spark运行架构图"><br>&emsp;Spark有多种<strong>运行模式</strong>，比如standalone(spark自身单独的集群资源管理器), Mesos 和 YARN，这些资源管理器负责计算资源的管理和分配。</p><p>&emsp;根据 Spark Application是否在集群资源中运行，Spark Application的<strong>运行方式</strong>又可分为Cluster模式和Client模式，如果是Cluster模式，Spark会把Application代码发送到Executor，即Driver会在集群中某个节点运行；Client模式下Driver会在提交的机器上运行。  </p><p>&emsp;每个Application都有专属它的executor进行，该进程在application运行过程中一直在内存驻留，并以多线程的方式运行task。这种Application隔离机制无论是从调度角度看（每个driver调度它自己的任务），还是从运行角度（来自不同的Application的Task运行在不同的JVM中）都很有优势。这意味着Spark Application不能跨Application共享数据，除非将数据写入外部储存系统。</p><p>&emsp;Spark与集群资源管理器无关，只要能获取到Executor进程，并能保持相互通信就可以。</p><p>&emsp;提交Application的Client应该靠近Worker节点，最好是在同一个Rack（局域网）中，因为Application的Driver和Executor之间有大量的信息交换；如果想在远程集群运行，最好使用<strong>RPC</strong>(Remote Procedure Call Protocol，即远程过程调用协议)将Spark Aplication提交给集群(Cluster模式)，<strong>不要远离Worker运行Driver！</strong></p><h2 id="2-集群管理模式"><a href="#2-集群管理模式" class="headerlink" title="2. 集群管理模式"></a>2. 集群管理模式</h2><p>&emsp;Spark系统当前支持三种外部集群资源管理器：</p><ul><li><a href="http://spark.apache.org/docs/2.4.0/spark-standalone.html" target="_blank" rel="noopener">Standalone</a> - Spark自身提供的集群资源管理器</li><li><a href="http://spark.apache.org/docs/2.4.0/running-on-mesos.html" target="_blank" rel="noopener">Mesos</a></li><li><a href="http://spark.apache.org/docs/2.4.0/running-on-yarn.html" target="_blank" rel="noopener">Yarn</a></li><li><a href="http://spark.apache.org/docs/2.4.0/running-on-kubernetes.html" target="_blank" rel="noopener">Kubernetes</a></li></ul><h2 id="3-监控"><a href="#3-监控" class="headerlink" title="3. 监控"></a>3. 监控</h2><p>&emsp;每一个Driver程序都有一个WebUI监控器，一般是4040端口，可以看到有关Spark Application 运行的任务、程序和储存空间大小等信息，方便我们监控Spark Application在集群中的运行状态。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;&lt;driver-node&gt;:4040</span><br></pre></td></tr></table></figure><br>详细使用指南可见：<a href="http://spark.apache.org/docs/2.4.0/monitoring.html" target="_blank" rel="noopener">http://spark.apache.org/docs/2.4.0/monitoring.html</a></p><h2 id="4-作业和任务调度"><a href="#4-作业和任务调度" class="headerlink" title="4. 作业和任务调度"></a>4. 作业和任务调度</h2><p>&emsp;Spark作业和任务调度是Spark的核心，Spark有多种运行模式，下面以Spark自身的Standalone模式，并且Driver运行在客户端的Client模式来介绍。</p><p>&emsp;下图是Spark的作业和任务调度系统整体概况：<br><img src="https://gitee.com/JP6907/Pic/raw/master/spark/spark-schedule" alt="spark-schedule"><br>根据该图，具体的调度过程为：</p><ol><li>Spark应用程序经过RDD的各种transform操作计算，最后通过RDD的action操作触发job，图中的join、groupby、和filter操作都是transform操作。</li><li>提交之后首先根据RDD之间的依赖关系<strong>构建DAG</strong>(Directed Acyclic Graph)有向无环图，然后将DAG图提交给DAGScheduler进行解析，就进入了DAGScheduler阶段。</li><li><strong>DAGScheduler</strong>是面向Stage的高级层的调度器，DAGScheduler把DAG拆分成很多个Tasks，每组的Tasks是一个Stage，解析时是以Shuffle为边界反向解析构建Stage，每次遇到Shuffle就会产生新的Stage，然后以一个个TaskSet（TaskSet等同于Stage，是对Stage的一次封装）的形式提交给底层调度器TaskScheduler。DAGScheduler还要记录哪些RDD被存入磁盘等物化动作，还需要监视因为Shuffle输出导致的失败，如果发现这个Stage失败，可能就要重新提交该Stage。</li><li>一个<strong>TaskScheduler</strong>只为一个SparkContext实例服务，TaskScheduler接收来自DAGScheduler发送过来的TaskSet，TaskScheduler收到TaskSet后负责把TaskSet以Task的形式一个个发到集群Worker节点中的Executor中去运行。如果某个Task运行失败，TaskScheduler要负责重试，如果发现某个Task一直未运行完，就可能在其它节点启动同样的任务运行同一个Task，哪个任务先运行完就用哪个任务的结果。</li><li><strong>Executor</strong>收到TaskScheduler发送过来的Task后，以多线程的方式运行，每一个线程负责一个Task。Task运行结束后要返回给DAGScheudler，不同类型的Task返回的方式不同。ShuffleMapTask返回的是一个MapStatue对象，而不是结果本身；ResultTask根据结果大小不同，返回的方式又可分为两类。</li></ol><h2 id="5-相关术语"><a href="#5-相关术语" class="headerlink" title="5. 相关术语"></a>5. 相关术语</h2><p>下面是一些常见的术语：<br>Term | Meaning<br>-|-<br>Application | 用户程序，包含Driver程序和Executor程序<br>Application jar | 在Application中的Jar包，包含用户程序的一些依赖jar包，注意不需要包含Hadoop或Spark的jar包<br>Driver program | Application运行main函数并创建SparkContext的进程<br>Cluster manager | 负责集群资源调度和管理<br>Deploy mode | 区分Driver运行的位置，cluster模式：driver在集群内部运行，client模式：driver在集群外部运行<br>Worker node | 集群中运行application程序的节点<br>Executor | Worker节点中运行application程序的进程，会运行tasks，将数据储存在内存或磁盘中。每个Application都有属于它自己的Executors<br>Task | Executor上运行任务的单位<br>Job | 用户程序中提交的作业，包含多个task<br>Stage | 每个job可以被分解为更小的task集，每个task集成为一个stage，stage之间存在一定的依赖关系</p><blockquote><p>参考：<a href="http://spark.apache.org/docs/2.4.0/index.html" target="_blank" rel="noopener">http://spark.apache.org/docs/2.4.0/index.html</a></p><p>本文作者：ZJP<br>版权声明：本文为博主原创文章，遵循 <a href="http://creativecommons.org/licenses/by-sa/4.0/" target="_blank" rel="noopener">CC 4.0 BY-SA</a> 版权协议，转载请附上原文出处链接和本声明。<br>本文链接：<a href="http://zhoujiapeng.top/Spark/spark-overview/">http://zhoujiapeng.top/Spark/spark-overview/</a></p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Spark </category>
          
      </categories>
      
      
        <tags>
            
            <tag> spark </tag>
            
            <tag> 大数据 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
