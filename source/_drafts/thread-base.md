---
title: thread-base
catalog: true
subtitle:
header-img:
tags:
---


## 1. 线程的创建与运行
Java 中由三种线程创建方式，分别为实现 Runnable 接口的run方法，继承 Thread 类并重写run方法，使用 FutureTask 方式。
### 1.1 Thread 方式
示例


### 1.2 Runnable 方式
示例


### 1.3 FutureTask 方式
示例


## 2. 线程通知与等待
Object 类包含了通知和等待系列函数，由于继承机制，Java 中所有类都带有这类函数。

### 2.1 wait 函数
当一个线程调用一个共享变量的wait方法时，该线程会被阻塞挂起，直到发生以下情况：
- 其它线程调用该共享变量的 notify 方法 或 notifyAll 方法；
- 其它线程调用了该线程的 interrupt 方法，该线程抛出 InterruptedException 异常返回；

需要注意的是，调用 wait 方法需要事先获取该对象的监视器锁，否则会抛出 IllegalMonitorStateException 异常。
获取监视器锁的方法：
```
synchronized{}
```

另外需要注意的是，一个线程可以从挂起状态变为运行状态（也就是被唤醒），即使其它线程没有调用 notify 方法或 notifyAll 方法，或者被中断，或者等待超时，这就是所谓的**虚假唤醒**。

虽然虚假唤醒在实际中很少发生，但要防范于未然，做法就是不停去测试该线程被唤醒的条件是否满足，不满足则继续等待。
```

```

线程调用 wait 方法之后，会释放锁该变量的监视器锁，然后阻塞一直等待到被唤醒，并且重新获得监视器锁才会返回。
需要注意的是，调用 wait 方法只会释放当前共享变量上的锁，如果当前线程还持有其它共享变量的锁，则这些锁是不会被释放的。
```

```

当一个线程调用wait被阻塞后，其它线程中断了该线程，则该线程会抛出 InterruptedException 异常并返回。

wait(long timeout)



### 2.2 notify 函数
一个线程调用 notify 方法，会唤醒一个在该共享变量上调用 wait 方法后被挂起的线程。一个共享变量上可能会有多个线程在等待，具体唤醒哪个等待的线程是随机的。此外，被唤醒的线程必须在重新获取该共享对象的监视器锁后才会返回，因为被唤醒的线程可能还需要和其它线程竞争该监视器锁，所以被唤醒的线程不一定能够继续执行。

notifyAll 方法则会唤醒所有在该共享变量上调用wait被阻塞的线程。
```

```


## 3. join 方法
Thread类的join方法可以使得当前线程被阻塞，等待某个线程结束再继续往下执行，join是无参且返回值为void的方法。
另外，线程A调用线程B的join方法后被阻塞，当其它线程调用了线程A的interrupt方法中断了线程A，线程A会抛出 InterruptedException 异常而返回。
```

```

## 4. sleep 方法
sleep是Thread类的静态方法，当一个线程调用 Thread.sleep 后，调用线程会暂时让出指定时间的执行权，在这段时间内不参与CPU调度。
当时该线程持有的监视器资源，比如锁是保持持有不让出的。在睡眠期间其它线程调用了该线程的 interrupt 方法中断该线程，则该线程会抛出 InterruptedException 异常而返回。

## 5. yield 方法
yield是Thread的静态方法，当一个线程调用 yield 方法时，当前线程会让出 CPU 使用权，然后处于就绪状态，线程调度器会从线程就绪队列中获取一个线程优先级最高的线程，当然也可能会调度到刚刚让出 CPU 的那个线程来获取 CPU 执行权。

## 6. 线程中断
Java中的线程中断是一种线程间协作模式，实际是通过设置线程的中断标志，并不能直接终止该线程的执行，而需要被中断线程根据中断状态自行处理。
关于中断有几个方法需要区分：
- void interrupt()：该方法会设置被调用线程的中断标志为true，实际并不会直接中断该线程。如果线程A因为调用 wait、join 或 sleep 方法而被阻塞，其它线程调用线程A的interrupt方法会导致线程A在调用这些方法的地方抛出 InterruptedException 异常而返回。
```
interrupt
```
- boolean isInterrupted()：检测当前线程？？？？？？？？？是否被中断，返回中断标志状态
```

```
- boolean interrupted()：静态方法，检测**当前线程**是否被中断，与 isInterrupted 不同的是，该方法如果发现当前线程被中断，则会清除中断标志
```

```

下面看一个线程使用 interrupted 优雅退出的例子：
```

```

下面看一个根据中断标志判断线程是否中止的例子：
```

```


## 7. 守护线程与用户线程