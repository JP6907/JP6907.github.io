---
title: Java 内存模型
catalog: true
subtitle: Java 内存模型
header-img: "/img/article_header/article_header.png"
tags:
- java
- 编程语言
- jvm
- 并发
categories:
- java
---

# Java 内存模型

# 1. 硬件的效率与一致性
&emsp;Java 内存模型的设计关键的一点在于处理并发问题，物理机遇到的并发问题与虚拟机中的情况有不少相似之处，物理机对并发的处理方案对于虚拟机的实现有相当大的参考意义。
&emsp;由于计算机的储存设备与处理器的运算速度有几个数量级的差距，所以现代计算机不得不加上一层读写速度尽可能接近处理器的**高速缓存（cache）**来作为内存和处理器之间的缓冲：将运算需要使用的数据复制到缓存中，让运算能够快速进行，当运算结束之后再从缓存同步回内存之中，这样处理器就无须等待缓慢的内存读写了。
&emsp;基于高速缓存的存储交互很好地解决了处理器与内存的速度矛盾，但是引入了一个新的问题：**缓存一致性**。
![cache](https://github.com/JP6907/Pic/blob/master/java/cache.png?raw=true)

&emsp;如图所示，在多处理器系统中，每个处理器都有自己的高速缓存，而它们又共享同一主内存。当多个处理器的运算任务都涉及同一块主内存区域时，将可能导致各自的缓存数据不一致，那同步回主内存的数据应该以谁的缓存数据为准？针对这个问题，需要有某种缓存一致性协议。Java 中的内存模型，可以理解为在特定的操作协议下，对特定的内存或高速缓存进行读写访问的抽象过程。
&emsp;除了增加高速缓存之外，为了使得处理器内部的运算单元能够尽量被充分利用，处理器可能会对输入的代码进行**乱序执行优化**，处理器会在计算之后将乱序执行的结果重组，保证该结果与顺序执行的结果是一致的，但不保证程序中各个语句计算的先后顺序与输入代码中的顺序一致，因此，如果存在一个计算任务依赖另外一个结算任务的中间结果，那么其顺序性不能靠代码的先后顺序来保证，与处理器的乱序执行优化类似，Java 虚拟机的即时编译器中也有类似的**指令重排序优化**。


# 2. Java 内存模型
## 2.1 主内存与工作内存
&emsp;Java 内存模型的主要目标是定义程序中各个变量的访问规则，即虚拟机将变量储存到内存和从内存中取出变量这样的底层细节。这里的变量和Java编程中所说的变量有所区别，它包括了实例字段，静态字段和构成数组对象的元素，但不包括局部变量与方法参数，因为后者是线程私有的，不会被共享，不存在竞争问题。
&emsp;Java 内存模型规定了**所有的变量都储存在主内存中**。每个线程还有自己的工作内存，线程的工作内存保存了该线程被使用到的变量的主内存**副本**拷贝，线程对变量的所有操作（读取、赋值）都必须在工作内存中进行，而不能直接读写主内存中的变量。不同的线程之间无法直接访问对方工作内存的变量，线程间变量值的传递均需要通过主内存来完成。
![java-memory-model](https://github.com/JP6907/Pic/blob/master/java/java-memory-model.png?raw=true)

## 2.2 内存间交互操作
&emsp;关于主内存与工作内存之间具体的交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步回主内存之类的实现细节，java内存模型中定义了8种操作来完成，虚拟机实现时必须保证这8种操作都是原子的、不可分割的(对于long和double类型的变量来说，load、store、read跟write在某些平台上允许例外)。
8种基本操作：
- lock(锁定):所用于主内存变量，它把一个变量标识为一条线程独占的状态。
- unlock(解锁):解锁后的变量才能被其他线程锁定。
- read(读取):所用于主内存变量，它把一个主内存变量的值，读取到工作内存中。
- load(载入):所用于工作内存变量，它把read读取的值，放到工作内存的变量副本中。
- use(使用):作用于工作内存变量，它把工作内存变量的值传递给执行引擎，当JVM遇到一个变量读取指令就会执行这个操作。
- assign(赋值):作用于工作内存变量，它把一个从执行引擎接收到的值赋值给工作内存变量。
- store(存储):作用域工作内存变量，它把工作内存变量值传送到主内存中。
- write(写入):作用于主内存变量，它把store从工作内存中得到的变量值写入到主内存变量中
&emsp;java内存模型还规定了在执行上述8种基本操作时必须满足如下规则：
- 不允许read和load、store和write操作之一单独出现，即不允许加载或同步工作到一半。
- 不允许一个线程丢弃它最近的assign操作，即变量在工作内存中改变了之后，必须吧改变化同步回主内存。
- 不允许一个线程无原因地（无assign操作）把数据从工作内存同步到主内存中。
- 一个新的变量只能在主内存中诞生。
- 一个变量在同一时刻只允许一条线程对其进行lock操作，但lock操作可以被同一条线程重复执行多次，，多次lock之后必须要执行相同次数的unlock操作，变量才会解锁。
- 如果对一个对象进行lock操作，那会清空工作内存变量中的值，在执行引擎使用这个变量前，需要重新执行load或assign操作初始化变量的值。
- 如果一个变量事先没有被lock，就不允许对它进行unlock操作，也不允许去unlock一个被其他线程锁住的变量。
- 对一个变量执行unlock操作之前，必须将此变量同步回主内存中（执行store、write）。
&emsp;有如上8种内存访问操作以及规则限定，再加上对volatile的一些特殊规定，就已经完全确定了java程序中哪些内存访问操作是在并发下安全的。


## 2.3 内存可见性问题

## 2.4 伪共享

## 2.5 原子性、可见性和有序性



