---
title: 深入理解Java虚拟机 之 Java内存区域
subtitle: Java内存区域
catalog: true
header-img: /img/article_header/article_header.png
tags:
  - java
  - 编程语言
  - jvm
categories:
  - java
date: 2019-10-16 11:24:38
---


# Java内存区域
&emsp;对C和C++的开发人员来说，在内存管理领域，他们既拥有每一个对象的“所有权”，也担负着每一个对象生命开始到终结的维护责任。
&emsp;对Java程序猿来说，在虚拟机自动内存管理机制的帮助下，不再需要为每一个new操作去写配对的delete/free代码，不容易出现内存泄露和内存溢出的问题。但是也出现问题：如果不理解虚拟机是怎么使用内存的，排查错误将会是一项非常艰难的工作。

## 1. 运行时数据区域
&emsp;Java虚拟机在执行Java程序的时候，会把它所管理的的内存分成若干个不同的数据区。包括如下几部分:
![memory-area](https://github.com/JP6907/Pic/blob/master/java/jvm/memory-area.jpg?raw=true)

### 1.1 程序计数器
&emsp;程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的**行号指示器**。字节码解释器通过改变计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都依赖与其完成。
&emsp;每条线程都需要有一个独立的程序计数器，各条线程之间计数器互不影响，独立储存，我们称这类内存区域为”**线程私有**“的内存。
&emsp;如果线程正在执行的是一个 Java 方法，这个计数器记录的是正在执行的虚拟机字节码指令的地址；如果正在执行的是 **Native** 方法，这个计数器值则为空（Undefined）。**此内存区域是唯一一个在 Java 虚拟机程序规范中没有规定任何 OutOfMemoryError 情况的区域**。

### 1.2 Java 虚拟机栈 VM Stack
&emsp;Java 虚拟机栈也是线程私有，与线程生命周期相同。虚拟机栈描述的是 Java 执行方法的内存模型。每个方法在执行时会创建一个**栈帧**，栈帧内存储的是局部变量表，操作数栈，动态链接，方法出口等信息。每个方法从调用直到执行完成，就是一个栈帧入栈到出栈的过程。
&emsp;局部变量表存放了编译期可知的各种**基本数据类型**（boolean、byte、char、short、int、float、**对象引用reference**(实际内存在堆上分配，引用指向在堆中分配的内存地址)）。其中64位长度的long和double会占用2个局部变量空间（Slot），其余数据类型只占用一个。**局部变量表所需的内存空间在编译期间完成分配**，当进入一个方法时，这个方法需要在栈中分配多大的局部变量空间是完全确定的，在方法运行期不会改变局部变量表的大小。

&emsp;虚拟机栈这块区域规定了两种异常：
- StackOverflowError：线程请求栈深度大于虚拟机所允许的深度。
- OutOfMemoryError：虚拟机栈扩展时无法申请到足够内存。

### 1.3 本地方法栈 Native Method Stack
&emsp;本地方法栈与虚拟机栈作用相似，区别就是虚拟机栈为虚拟机执行 Java 方法(也就是字节码)服务，而本地方法栈则为虚拟机使用到的 Native 方法服务，有些虚拟机（如Sun HotSpot）将两者合并。


### 1.4 Java 堆 Heap
&emsp;Java 堆是 Java 虚拟机所管理的内存最大的一块，Java 堆是被所有线程共享的一块内存区域，在虚拟机启动时创建。此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例都在这里分配内存。这一点在 Java 虚拟机规范中的描述是：**所有的对象实例以及数组都在这里分配内存**，但是随着 JIT 编译器的发展和逃逸分析技术逐渐成熟，栈上分配、标量替换优化技术将会导致一些微妙的变化发生，所有对象在堆上分配逐渐变得不是那么”绝对“。
&emsp;**Java 堆是垃圾收集器管理的主要区域**。为了更好的回收或者分配内存，堆可能会被分为多个区域，例如分代收集算法的垃圾回收器会将堆分为新生代和老年代（当然还可以继续细分：Eden、From Survivor、To Survivor等）。但不管如何划分，每个区间存储的内容是不变的，都是对象实例。
另外，堆在内存中并不是物理连续的，只要逻辑连续即可。当向堆申请内存（实例化对象），而堆中找不到这么大的空间时）会抛出OutOfMemoryError（最新虚拟机都可动态扩展，但扩无可扩时也会抛错）。

### 1.5 方法区 Mtthod Area
&emsp;方法区是各个线程**共享**的内存区域。方法区内存储的是已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。一些虚拟机实现上，将方法区称为 **“永久代”(Permanent Generation)**，意味着垃圾回收器可以向管理堆一样来管理这块内存。但本质上，方法区和永久代是不等价的，使用永久代来实现方法区可能会遇到内存溢出的问题。而且极少数方法(例如String.intern())在不同的虚拟上会因为该机制而表现不同。
&emsp;方法区内存回收的主要目标是针对常量池的回收和对类型的卸载。
&emsp;当方法区无法满足内存分配要求时，将抛出 OutOfMemoryError 异常。

### 1.6 运行时常量池 Runtime Constant Pool
&emsp;运行时常量池是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放在编译期会生成各种字面量和符号引用，这部分内容将在类加载后，放入到方法区的运行时常量池中存放。
&emsp;**运行时常量池**相对于**Class文件常量池**的另外一个重要特征是具备动态性。并非只有预置入Class文件中的常量池的部分才能进入方法区的运行时常量池，运行期间也可能将新的常量放入池中，例如String类的intern()方法。
&emsp;运行时常量池属于方法区的一部分，所以当申请不到内存的时候，会抛出 OutOfMemoryError 异常。 

### 1.7 直接内存 Direct Memory
&emsp;直接内存并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域。但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。
&emsp;在 JDK1.4 中新加入了 NIO（New Input/Output）类，引入了一种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以**使用 Native 函数库直接分配堆外内存**，然后通过一个存储在 Java &emsp;堆中的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。
直接内存不会受到 Java 堆大小限制，但会受到内机总内存的限制，动态扩展时可能出现 OutOfMemoryError。

## 2. HotSpot 虚拟机对象探秘

### 2.1 对象的创建
&emsp;在语言层面，创建一个新的对象只需要使用 new 关键字就可以，而在虚拟机上，对象的创建需要经过下面几个步骤：
- 1. 类加载
- 2. 为新生对象分配内存
- 3. 初始化
- 4. 设置对象头
- 5. 调用 init 方法

1. 类加载
虚拟机遇到一条 new 指令时，首先将去检查指令参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载、解析和初始化过。如果没有，那必须先执行相应的类加载过程。 

2. 为新生对象分配内存
在类加载检查通过后，接下来虚拟机将为新生对象分配内存。对象所需内存的大小在类加载完成后便可以完全确定，为对象分配空间的任务等同于把一块确定大小的内存从 Java 堆中划分出来。

&emsp;对象分配方式有：
- 1.指针碰撞（Bump the Pointer)
假设 Java 堆中内存是绝对规整的，所有用过的内存都放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把哪个指针向空闲那边挪动一段与对象大小相等的距离。

- 2.空闲列表（Free List)
如果 Java 堆中的内存不是规整的，已使用的内存和空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录上哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

&emsp;选择哪种分配方式由 Java 堆是否规整决定，而 Java 堆是否规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此，在使用 Serial、ParNew 等带 Compact 过程的收集器时，系统采用的分配算法是指针碰撞，而使用 CMS 这种基于 Mark-Sweep 算法的收集器时，通常采用空闲列表。

&emsp;对象创建的线程安全性问题：
&emsp;对象创建在虚拟机中是非常频繁的行为，即使是仅仅修改一个指针所指向的位置，在并发情况下也并不是线程安全的，可能出现正在给对象 A 分配地址，指针还没来得及修改，对象 B 又同时使用了原来的指针来分配内存的情况。解决这个问题有两种方案。

方案一：对分配内存空间的动作进行**同步处理**，虚拟机采用 CAS 配上失败重试 的方式保证更新操作的原子性。
方案二：将内存分配的动作按照线程划分在不同的空间中进行，每个线程在 Java 堆中预先分配一小块内存，称为 本地线程分配缓冲（Thread Local Allocation Buffer, **TLAB**） 。哪个线程需要分配内存，就在哪个线程的 TLAB 上分配，只有 TLAB 用完并分配新的 TLAB 时，才需要同步锁定。通过 -XX:+/-UseTLAB 参数设定是否使用 TLAB。


3. 初始化
&emsp;内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用 TLAB，这一过程就可以提前至 TLAB 分配时进行。
这一步保证对象的实例字段在 Java 代码中可以不赋初值就直接使用，程序能访问到这些字段的数据类型对应的零值。

4. 设置对象头
&emsp;接下来，虚拟机要为对象头数据进行设置，例如对象的实例类、类的元数据信息的地址、对象的哈希码、对象的 GC 分代年龄等。

5. 调用 init 方法
&emsp;在上面步骤完成后，从虚拟机的角度来看，一个新的对象已经产生了，但从 Java 程序的角度来看，对象的创建才刚刚开始，<init> 方法还没有被执行，所有的字段还为零值。一般来说，执行 new 指令之后会接着执行 <init> 方法，将对象按照程序员的意愿进行初始化，这样一个真正的对象才算完全产生。

### 2.2 对象的内存布局
&emsp;在 HotSpot 虚拟机中，对象在内存中存储的布局可以分为以下 3 块区域:
- 1. 对象头（Header）
- 2. 实例数据（Instance Data）
- 3. 对齐填充（Padding）

1. 对象头
&emsp;HotSpot 虚拟机的对象头包括两部分信息，存储对象自身的运行时数据的（Mark Word） 和 类型指针。

1.1 Mark Word
&emsp;用于存储对象自身的运行时数据，如（HashCode、GC 分代年龄、锁状态标志、线程持有锁、偏向线程ID、偏向时间戳），这部分数据的长度在 32 位和 64 位的虚拟机中（未开启压缩指针）分别为 32bit 和 64bit。对象需要存储的运行时数据很多，其实已经超出了 32位、64位 Bitmap 结构所能记录的限度，但是对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word 被设计成一个 非固定的数据结构 以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。
HotSpot 虚拟机对象头 Mark Word 表如下：
|                存储内容               | 标志位 |        状态        |
|:-------------------------------------:|:------:|:------------------:|
|        对象哈希码、对象分代年龄       |   01   |       未锁定       |
|            指向锁记录的指针           |   00   |     轻量级锁定     |
|           指向重量级锁的指针          |   10   | 膨胀（重量级锁定） |
|          空（不需要记录信息）         |   11   |       GC 标记      |
| 偏向线程 ID、偏向时间戳、对象分代年龄 |   01   |       可偏向       |


1.2 类型指针
&emsp;对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。
并不是所有的虚拟机实现都必须在对象数据上保留类型指针，换句话说，查找对象的元数据并不一定要经过对象本身。如果对象是一个 Java 数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通 Java 对象的元数据信息确定 Java 对象的大小，但是从数组的元数据中却无法确定数组的大小。

2. 实例数据
&emsp;实例数据是对象真正储存的有效信息，也是程序代码中所定义的各种类型的字段内存。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。

3. 对齐填充
&emsp;不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于 HotSpot VM 的自动内存管理系统要求 对象起始地址必须是 8 字节的整倍数，换句话说，就是对象的大小必须是 8 字节的整倍数。而对象头部分正好是 8 字节的整倍数（ 1 倍或 2 倍），因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补全。

### 2.3 对象的访问定位
&emsp;Java 程序需要通过栈上的 reference 数据来操作堆上的具体对象。如何通过这个引用去定位、访问堆中对象的具体位置，取决于虚拟机的实现，目前主流的有两种方式：
- 使用句柄
- 直接指针

1. 使用句柄
&emsp;Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息，如下图所示：
![handle](https://github.com/JP6907/Pic/blob/master/java/jvm/handle-access-object.jpg?raw=true)

2. 直接指针
&emsp;Java 堆对象的布局中必须考虑如何放置访问类型数据的相关信息，而 reference 中存储的直接就是对象地址，如下图所示：
![pointer](https://github.com/JP6907/Pic/blob/master/java/jvm/pointer-access-object.jpg?raw=true)


&emsp;使用句柄访问的最大好处就是 reference 中存储的是 稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。
&emsp;使用直接访问最大的好处就是速度快，它节省了一次指针定位的时间开销，由于对象的访问在 Java 中非常频繁，因此这类开销积少成多后也是一项非常可观的执行成本。

&emsp;Sun HotSpot 虚拟机使用的是直接指针方式访问对象，但从整个软件开发的范围来看，各种语言和框架使用句柄来访问的情况也十分常见。

&nbsp;
>参考：
《深入理解Java虚拟机》


